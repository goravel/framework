// Code generated by mockery. DO NOT EDIT.

package filesystem

import (
	context "context"
	time "time"

	filesystem "github.com/goravel/framework/contracts/filesystem"
	mock "github.com/stretchr/testify/mock"
)

// Driver is an autogenerated mock type for the Driver type
type Driver struct {
	mock.Mock
}

type Driver_Expecter struct {
	mock *mock.Mock
}

func (_m *Driver) EXPECT() *Driver_Expecter {
	return &Driver_Expecter{mock: &_m.Mock}
}

// AllDirectories provides a mock function with given fields: path
func (_m *Driver) AllDirectories(path string) ([]string, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for AllDirectories")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_AllDirectories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllDirectories'
type Driver_AllDirectories_Call struct {
	*mock.Call
}

// AllDirectories is a helper method to define mock.On call
//   - path string
func (_e *Driver_Expecter) AllDirectories(path interface{}) *Driver_AllDirectories_Call {
	return &Driver_AllDirectories_Call{Call: _e.mock.On("AllDirectories", path)}
}

func (_c *Driver_AllDirectories_Call) Run(run func(path string)) *Driver_AllDirectories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_AllDirectories_Call) Return(_a0 []string, _a1 error) *Driver_AllDirectories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_AllDirectories_Call) RunAndReturn(run func(string) ([]string, error)) *Driver_AllDirectories_Call {
	_c.Call.Return(run)
	return _c
}

// AllFiles provides a mock function with given fields: path
func (_m *Driver) AllFiles(path string) ([]string, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for AllFiles")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_AllFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllFiles'
type Driver_AllFiles_Call struct {
	*mock.Call
}

// AllFiles is a helper method to define mock.On call
//   - path string
func (_e *Driver_Expecter) AllFiles(path interface{}) *Driver_AllFiles_Call {
	return &Driver_AllFiles_Call{Call: _e.mock.On("AllFiles", path)}
}

func (_c *Driver_AllFiles_Call) Run(run func(path string)) *Driver_AllFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_AllFiles_Call) Return(_a0 []string, _a1 error) *Driver_AllFiles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_AllFiles_Call) RunAndReturn(run func(string) ([]string, error)) *Driver_AllFiles_Call {
	_c.Call.Return(run)
	return _c
}

// Copy provides a mock function with given fields: oldFile, newFile
func (_m *Driver) Copy(oldFile string, newFile string) error {
	ret := _m.Called(oldFile, newFile)

	if len(ret) == 0 {
		panic("no return value specified for Copy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(oldFile, newFile)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Driver_Copy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Copy'
type Driver_Copy_Call struct {
	*mock.Call
}

// Copy is a helper method to define mock.On call
//   - oldFile string
//   - newFile string
func (_e *Driver_Expecter) Copy(oldFile interface{}, newFile interface{}) *Driver_Copy_Call {
	return &Driver_Copy_Call{Call: _e.mock.On("Copy", oldFile, newFile)}
}

func (_c *Driver_Copy_Call) Run(run func(oldFile string, newFile string)) *Driver_Copy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Driver_Copy_Call) Return(_a0 error) *Driver_Copy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Driver_Copy_Call) RunAndReturn(run func(string, string) error) *Driver_Copy_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: file
func (_m *Driver) Delete(file ...string) error {
	_va := make([]interface{}, len(file))
	for _i := range file {
		_va[_i] = file[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...string) error); ok {
		r0 = rf(file...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Driver_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Driver_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - file ...string
func (_e *Driver_Expecter) Delete(file ...interface{}) *Driver_Delete_Call {
	return &Driver_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{}, file...)...)}
}

func (_c *Driver_Delete_Call) Run(run func(file ...string)) *Driver_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Driver_Delete_Call) Return(_a0 error) *Driver_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Driver_Delete_Call) RunAndReturn(run func(...string) error) *Driver_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDirectory provides a mock function with given fields: directory
func (_m *Driver) DeleteDirectory(directory string) error {
	ret := _m.Called(directory)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDirectory")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(directory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Driver_DeleteDirectory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDirectory'
type Driver_DeleteDirectory_Call struct {
	*mock.Call
}

// DeleteDirectory is a helper method to define mock.On call
//   - directory string
func (_e *Driver_Expecter) DeleteDirectory(directory interface{}) *Driver_DeleteDirectory_Call {
	return &Driver_DeleteDirectory_Call{Call: _e.mock.On("DeleteDirectory", directory)}
}

func (_c *Driver_DeleteDirectory_Call) Run(run func(directory string)) *Driver_DeleteDirectory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_DeleteDirectory_Call) Return(_a0 error) *Driver_DeleteDirectory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Driver_DeleteDirectory_Call) RunAndReturn(run func(string) error) *Driver_DeleteDirectory_Call {
	_c.Call.Return(run)
	return _c
}

// Directories provides a mock function with given fields: path
func (_m *Driver) Directories(path string) ([]string, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for Directories")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_Directories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Directories'
type Driver_Directories_Call struct {
	*mock.Call
}

// Directories is a helper method to define mock.On call
//   - path string
func (_e *Driver_Expecter) Directories(path interface{}) *Driver_Directories_Call {
	return &Driver_Directories_Call{Call: _e.mock.On("Directories", path)}
}

func (_c *Driver_Directories_Call) Run(run func(path string)) *Driver_Directories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_Directories_Call) Return(_a0 []string, _a1 error) *Driver_Directories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_Directories_Call) RunAndReturn(run func(string) ([]string, error)) *Driver_Directories_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function with given fields: file
func (_m *Driver) Exists(file string) bool {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Driver_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type Driver_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - file string
func (_e *Driver_Expecter) Exists(file interface{}) *Driver_Exists_Call {
	return &Driver_Exists_Call{Call: _e.mock.On("Exists", file)}
}

func (_c *Driver_Exists_Call) Run(run func(file string)) *Driver_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_Exists_Call) Return(_a0 bool) *Driver_Exists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Driver_Exists_Call) RunAndReturn(run func(string) bool) *Driver_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Files provides a mock function with given fields: path
func (_m *Driver) Files(path string) ([]string, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for Files")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_Files_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Files'
type Driver_Files_Call struct {
	*mock.Call
}

// Files is a helper method to define mock.On call
//   - path string
func (_e *Driver_Expecter) Files(path interface{}) *Driver_Files_Call {
	return &Driver_Files_Call{Call: _e.mock.On("Files", path)}
}

func (_c *Driver_Files_Call) Run(run func(path string)) *Driver_Files_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_Files_Call) Return(_a0 []string, _a1 error) *Driver_Files_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_Files_Call) RunAndReturn(run func(string) ([]string, error)) *Driver_Files_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: file
func (_m *Driver) Get(file string) (string, error) {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Driver_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - file string
func (_e *Driver_Expecter) Get(file interface{}) *Driver_Get_Call {
	return &Driver_Get_Call{Call: _e.mock.On("Get", file)}
}

func (_c *Driver_Get_Call) Run(run func(file string)) *Driver_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_Get_Call) Return(_a0 string, _a1 error) *Driver_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_Get_Call) RunAndReturn(run func(string) (string, error)) *Driver_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetBytes provides a mock function with given fields: file
func (_m *Driver) GetBytes(file string) ([]byte, error) {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for GetBytes")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]byte, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = rf(file)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_GetBytes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBytes'
type Driver_GetBytes_Call struct {
	*mock.Call
}

// GetBytes is a helper method to define mock.On call
//   - file string
func (_e *Driver_Expecter) GetBytes(file interface{}) *Driver_GetBytes_Call {
	return &Driver_GetBytes_Call{Call: _e.mock.On("GetBytes", file)}
}

func (_c *Driver_GetBytes_Call) Run(run func(file string)) *Driver_GetBytes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_GetBytes_Call) Return(_a0 []byte, _a1 error) *Driver_GetBytes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_GetBytes_Call) RunAndReturn(run func(string) ([]byte, error)) *Driver_GetBytes_Call {
	_c.Call.Return(run)
	return _c
}

// LastModified provides a mock function with given fields: file
func (_m *Driver) LastModified(file string) (time.Time, error) {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for LastModified")
	}

	var r0 time.Time
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (time.Time, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(string) time.Time); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_LastModified_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LastModified'
type Driver_LastModified_Call struct {
	*mock.Call
}

// LastModified is a helper method to define mock.On call
//   - file string
func (_e *Driver_Expecter) LastModified(file interface{}) *Driver_LastModified_Call {
	return &Driver_LastModified_Call{Call: _e.mock.On("LastModified", file)}
}

func (_c *Driver_LastModified_Call) Run(run func(file string)) *Driver_LastModified_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_LastModified_Call) Return(_a0 time.Time, _a1 error) *Driver_LastModified_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_LastModified_Call) RunAndReturn(run func(string) (time.Time, error)) *Driver_LastModified_Call {
	_c.Call.Return(run)
	return _c
}

// MakeDirectory provides a mock function with given fields: directory
func (_m *Driver) MakeDirectory(directory string) error {
	ret := _m.Called(directory)

	if len(ret) == 0 {
		panic("no return value specified for MakeDirectory")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(directory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Driver_MakeDirectory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MakeDirectory'
type Driver_MakeDirectory_Call struct {
	*mock.Call
}

// MakeDirectory is a helper method to define mock.On call
//   - directory string
func (_e *Driver_Expecter) MakeDirectory(directory interface{}) *Driver_MakeDirectory_Call {
	return &Driver_MakeDirectory_Call{Call: _e.mock.On("MakeDirectory", directory)}
}

func (_c *Driver_MakeDirectory_Call) Run(run func(directory string)) *Driver_MakeDirectory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_MakeDirectory_Call) Return(_a0 error) *Driver_MakeDirectory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Driver_MakeDirectory_Call) RunAndReturn(run func(string) error) *Driver_MakeDirectory_Call {
	_c.Call.Return(run)
	return _c
}

// MimeType provides a mock function with given fields: file
func (_m *Driver) MimeType(file string) (string, error) {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for MimeType")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_MimeType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MimeType'
type Driver_MimeType_Call struct {
	*mock.Call
}

// MimeType is a helper method to define mock.On call
//   - file string
func (_e *Driver_Expecter) MimeType(file interface{}) *Driver_MimeType_Call {
	return &Driver_MimeType_Call{Call: _e.mock.On("MimeType", file)}
}

func (_c *Driver_MimeType_Call) Run(run func(file string)) *Driver_MimeType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_MimeType_Call) Return(_a0 string, _a1 error) *Driver_MimeType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_MimeType_Call) RunAndReturn(run func(string) (string, error)) *Driver_MimeType_Call {
	_c.Call.Return(run)
	return _c
}

// Missing provides a mock function with given fields: file
func (_m *Driver) Missing(file string) bool {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Missing")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Driver_Missing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Missing'
type Driver_Missing_Call struct {
	*mock.Call
}

// Missing is a helper method to define mock.On call
//   - file string
func (_e *Driver_Expecter) Missing(file interface{}) *Driver_Missing_Call {
	return &Driver_Missing_Call{Call: _e.mock.On("Missing", file)}
}

func (_c *Driver_Missing_Call) Run(run func(file string)) *Driver_Missing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_Missing_Call) Return(_a0 bool) *Driver_Missing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Driver_Missing_Call) RunAndReturn(run func(string) bool) *Driver_Missing_Call {
	_c.Call.Return(run)
	return _c
}

// Move provides a mock function with given fields: oldFile, newFile
func (_m *Driver) Move(oldFile string, newFile string) error {
	ret := _m.Called(oldFile, newFile)

	if len(ret) == 0 {
		panic("no return value specified for Move")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(oldFile, newFile)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Driver_Move_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Move'
type Driver_Move_Call struct {
	*mock.Call
}

// Move is a helper method to define mock.On call
//   - oldFile string
//   - newFile string
func (_e *Driver_Expecter) Move(oldFile interface{}, newFile interface{}) *Driver_Move_Call {
	return &Driver_Move_Call{Call: _e.mock.On("Move", oldFile, newFile)}
}

func (_c *Driver_Move_Call) Run(run func(oldFile string, newFile string)) *Driver_Move_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Driver_Move_Call) Return(_a0 error) *Driver_Move_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Driver_Move_Call) RunAndReturn(run func(string, string) error) *Driver_Move_Call {
	_c.Call.Return(run)
	return _c
}

// Path provides a mock function with given fields: file
func (_m *Driver) Path(file string) string {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Path")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Driver_Path_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Path'
type Driver_Path_Call struct {
	*mock.Call
}

// Path is a helper method to define mock.On call
//   - file string
func (_e *Driver_Expecter) Path(file interface{}) *Driver_Path_Call {
	return &Driver_Path_Call{Call: _e.mock.On("Path", file)}
}

func (_c *Driver_Path_Call) Run(run func(file string)) *Driver_Path_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_Path_Call) Return(_a0 string) *Driver_Path_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Driver_Path_Call) RunAndReturn(run func(string) string) *Driver_Path_Call {
	_c.Call.Return(run)
	return _c
}

// Put provides a mock function with given fields: file, content
func (_m *Driver) Put(file string, content string) error {
	ret := _m.Called(file, content)

	if len(ret) == 0 {
		panic("no return value specified for Put")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(file, content)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Driver_Put_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Put'
type Driver_Put_Call struct {
	*mock.Call
}

// Put is a helper method to define mock.On call
//   - file string
//   - content string
func (_e *Driver_Expecter) Put(file interface{}, content interface{}) *Driver_Put_Call {
	return &Driver_Put_Call{Call: _e.mock.On("Put", file, content)}
}

func (_c *Driver_Put_Call) Run(run func(file string, content string)) *Driver_Put_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Driver_Put_Call) Return(_a0 error) *Driver_Put_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Driver_Put_Call) RunAndReturn(run func(string, string) error) *Driver_Put_Call {
	_c.Call.Return(run)
	return _c
}

// PutFile provides a mock function with given fields: path, source
func (_m *Driver) PutFile(path string, source filesystem.File) (string, error) {
	ret := _m.Called(path, source)

	if len(ret) == 0 {
		panic("no return value specified for PutFile")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, filesystem.File) (string, error)); ok {
		return rf(path, source)
	}
	if rf, ok := ret.Get(0).(func(string, filesystem.File) string); ok {
		r0 = rf(path, source)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, filesystem.File) error); ok {
		r1 = rf(path, source)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_PutFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutFile'
type Driver_PutFile_Call struct {
	*mock.Call
}

// PutFile is a helper method to define mock.On call
//   - path string
//   - source filesystem.File
func (_e *Driver_Expecter) PutFile(path interface{}, source interface{}) *Driver_PutFile_Call {
	return &Driver_PutFile_Call{Call: _e.mock.On("PutFile", path, source)}
}

func (_c *Driver_PutFile_Call) Run(run func(path string, source filesystem.File)) *Driver_PutFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(filesystem.File))
	})
	return _c
}

func (_c *Driver_PutFile_Call) Return(_a0 string, _a1 error) *Driver_PutFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_PutFile_Call) RunAndReturn(run func(string, filesystem.File) (string, error)) *Driver_PutFile_Call {
	_c.Call.Return(run)
	return _c
}

// PutFileAs provides a mock function with given fields: path, source, name
func (_m *Driver) PutFileAs(path string, source filesystem.File, name string) (string, error) {
	ret := _m.Called(path, source, name)

	if len(ret) == 0 {
		panic("no return value specified for PutFileAs")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, filesystem.File, string) (string, error)); ok {
		return rf(path, source, name)
	}
	if rf, ok := ret.Get(0).(func(string, filesystem.File, string) string); ok {
		r0 = rf(path, source, name)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, filesystem.File, string) error); ok {
		r1 = rf(path, source, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_PutFileAs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutFileAs'
type Driver_PutFileAs_Call struct {
	*mock.Call
}

// PutFileAs is a helper method to define mock.On call
//   - path string
//   - source filesystem.File
//   - name string
func (_e *Driver_Expecter) PutFileAs(path interface{}, source interface{}, name interface{}) *Driver_PutFileAs_Call {
	return &Driver_PutFileAs_Call{Call: _e.mock.On("PutFileAs", path, source, name)}
}

func (_c *Driver_PutFileAs_Call) Run(run func(path string, source filesystem.File, name string)) *Driver_PutFileAs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(filesystem.File), args[2].(string))
	})
	return _c
}

func (_c *Driver_PutFileAs_Call) Return(_a0 string, _a1 error) *Driver_PutFileAs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_PutFileAs_Call) RunAndReturn(run func(string, filesystem.File, string) (string, error)) *Driver_PutFileAs_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function with given fields: file
func (_m *Driver) Size(file string) (int64, error) {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (int64, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(string) int64); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type Driver_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
//   - file string
func (_e *Driver_Expecter) Size(file interface{}) *Driver_Size_Call {
	return &Driver_Size_Call{Call: _e.mock.On("Size", file)}
}

func (_c *Driver_Size_Call) Run(run func(file string)) *Driver_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_Size_Call) Return(_a0 int64, _a1 error) *Driver_Size_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_Size_Call) RunAndReturn(run func(string) (int64, error)) *Driver_Size_Call {
	_c.Call.Return(run)
	return _c
}

// TemporaryUrl provides a mock function with given fields: file, _a1
func (_m *Driver) TemporaryUrl(file string, _a1 time.Time) (string, error) {
	ret := _m.Called(file, _a1)

	if len(ret) == 0 {
		panic("no return value specified for TemporaryUrl")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, time.Time) (string, error)); ok {
		return rf(file, _a1)
	}
	if rf, ok := ret.Get(0).(func(string, time.Time) string); ok {
		r0 = rf(file, _a1)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, time.Time) error); ok {
		r1 = rf(file, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Driver_TemporaryUrl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TemporaryUrl'
type Driver_TemporaryUrl_Call struct {
	*mock.Call
}

// TemporaryUrl is a helper method to define mock.On call
//   - file string
//   - _a1 time.Time
func (_e *Driver_Expecter) TemporaryUrl(file interface{}, _a1 interface{}) *Driver_TemporaryUrl_Call {
	return &Driver_TemporaryUrl_Call{Call: _e.mock.On("TemporaryUrl", file, _a1)}
}

func (_c *Driver_TemporaryUrl_Call) Run(run func(file string, _a1 time.Time)) *Driver_TemporaryUrl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Time))
	})
	return _c
}

func (_c *Driver_TemporaryUrl_Call) Return(_a0 string, _a1 error) *Driver_TemporaryUrl_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Driver_TemporaryUrl_Call) RunAndReturn(run func(string, time.Time) (string, error)) *Driver_TemporaryUrl_Call {
	_c.Call.Return(run)
	return _c
}

// Url provides a mock function with given fields: file
func (_m *Driver) Url(file string) string {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Url")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Driver_Url_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Url'
type Driver_Url_Call struct {
	*mock.Call
}

// Url is a helper method to define mock.On call
//   - file string
func (_e *Driver_Expecter) Url(file interface{}) *Driver_Url_Call {
	return &Driver_Url_Call{Call: _e.mock.On("Url", file)}
}

func (_c *Driver_Url_Call) Run(run func(file string)) *Driver_Url_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Driver_Url_Call) Return(_a0 string) *Driver_Url_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Driver_Url_Call) RunAndReturn(run func(string) string) *Driver_Url_Call {
	_c.Call.Return(run)
	return _c
}

// WithContext provides a mock function with given fields: ctx
func (_m *Driver) WithContext(ctx context.Context) filesystem.Driver {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WithContext")
	}

	var r0 filesystem.Driver
	if rf, ok := ret.Get(0).(func(context.Context) filesystem.Driver); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filesystem.Driver)
		}
	}

	return r0
}

// Driver_WithContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithContext'
type Driver_WithContext_Call struct {
	*mock.Call
}

// WithContext is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Driver_Expecter) WithContext(ctx interface{}) *Driver_WithContext_Call {
	return &Driver_WithContext_Call{Call: _e.mock.On("WithContext", ctx)}
}

func (_c *Driver_WithContext_Call) Run(run func(ctx context.Context)) *Driver_WithContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Driver_WithContext_Call) Return(_a0 filesystem.Driver) *Driver_WithContext_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Driver_WithContext_Call) RunAndReturn(run func(context.Context) filesystem.Driver) *Driver_WithContext_Call {
	_c.Call.Return(run)
	return _c
}

// NewDriver creates a new instance of Driver. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDriver(t interface {
	mock.TestingT
	Cleanup(func())
}) *Driver {
	mock := &Driver{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
