// Code generated by mockery. DO NOT EDIT.

package filesystem

import (
	context "context"
	time "time"

	filesystem "github.com/goravel/framework/contracts/filesystem"
	mock "github.com/stretchr/testify/mock"
)

// Storage is an autogenerated mock type for the Storage type
type Storage struct {
	mock.Mock
}

type Storage_Expecter struct {
	mock *mock.Mock
}

func (_m *Storage) EXPECT() *Storage_Expecter {
	return &Storage_Expecter{mock: &_m.Mock}
}

// AllDirectories provides a mock function with given fields: path
func (_m *Storage) AllDirectories(path string) ([]string, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for AllDirectories")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_AllDirectories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllDirectories'
type Storage_AllDirectories_Call struct {
	*mock.Call
}

// AllDirectories is a helper method to define mock.On call
//   - path string
func (_e *Storage_Expecter) AllDirectories(path interface{}) *Storage_AllDirectories_Call {
	return &Storage_AllDirectories_Call{Call: _e.mock.On("AllDirectories", path)}
}

func (_c *Storage_AllDirectories_Call) Run(run func(path string)) *Storage_AllDirectories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_AllDirectories_Call) Return(_a0 []string, _a1 error) *Storage_AllDirectories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_AllDirectories_Call) RunAndReturn(run func(string) ([]string, error)) *Storage_AllDirectories_Call {
	_c.Call.Return(run)
	return _c
}

// AllFiles provides a mock function with given fields: path
func (_m *Storage) AllFiles(path string) ([]string, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for AllFiles")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_AllFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllFiles'
type Storage_AllFiles_Call struct {
	*mock.Call
}

// AllFiles is a helper method to define mock.On call
//   - path string
func (_e *Storage_Expecter) AllFiles(path interface{}) *Storage_AllFiles_Call {
	return &Storage_AllFiles_Call{Call: _e.mock.On("AllFiles", path)}
}

func (_c *Storage_AllFiles_Call) Run(run func(path string)) *Storage_AllFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_AllFiles_Call) Return(_a0 []string, _a1 error) *Storage_AllFiles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_AllFiles_Call) RunAndReturn(run func(string) ([]string, error)) *Storage_AllFiles_Call {
	_c.Call.Return(run)
	return _c
}

// Copy provides a mock function with given fields: oldFile, newFile
func (_m *Storage) Copy(oldFile string, newFile string) error {
	ret := _m.Called(oldFile, newFile)

	if len(ret) == 0 {
		panic("no return value specified for Copy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(oldFile, newFile)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Storage_Copy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Copy'
type Storage_Copy_Call struct {
	*mock.Call
}

// Copy is a helper method to define mock.On call
//   - oldFile string
//   - newFile string
func (_e *Storage_Expecter) Copy(oldFile interface{}, newFile interface{}) *Storage_Copy_Call {
	return &Storage_Copy_Call{Call: _e.mock.On("Copy", oldFile, newFile)}
}

func (_c *Storage_Copy_Call) Run(run func(oldFile string, newFile string)) *Storage_Copy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Storage_Copy_Call) Return(_a0 error) *Storage_Copy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_Copy_Call) RunAndReturn(run func(string, string) error) *Storage_Copy_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: file
func (_m *Storage) Delete(file ...string) error {
	_va := make([]interface{}, len(file))
	for _i := range file {
		_va[_i] = file[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...string) error); ok {
		r0 = rf(file...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Storage_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Storage_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - file ...string
func (_e *Storage_Expecter) Delete(file ...interface{}) *Storage_Delete_Call {
	return &Storage_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{}, file...)...)}
}

func (_c *Storage_Delete_Call) Run(run func(file ...string)) *Storage_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Storage_Delete_Call) Return(_a0 error) *Storage_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_Delete_Call) RunAndReturn(run func(...string) error) *Storage_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDirectory provides a mock function with given fields: directory
func (_m *Storage) DeleteDirectory(directory string) error {
	ret := _m.Called(directory)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDirectory")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(directory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Storage_DeleteDirectory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDirectory'
type Storage_DeleteDirectory_Call struct {
	*mock.Call
}

// DeleteDirectory is a helper method to define mock.On call
//   - directory string
func (_e *Storage_Expecter) DeleteDirectory(directory interface{}) *Storage_DeleteDirectory_Call {
	return &Storage_DeleteDirectory_Call{Call: _e.mock.On("DeleteDirectory", directory)}
}

func (_c *Storage_DeleteDirectory_Call) Run(run func(directory string)) *Storage_DeleteDirectory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_DeleteDirectory_Call) Return(_a0 error) *Storage_DeleteDirectory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_DeleteDirectory_Call) RunAndReturn(run func(string) error) *Storage_DeleteDirectory_Call {
	_c.Call.Return(run)
	return _c
}

// Directories provides a mock function with given fields: path
func (_m *Storage) Directories(path string) ([]string, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for Directories")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_Directories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Directories'
type Storage_Directories_Call struct {
	*mock.Call
}

// Directories is a helper method to define mock.On call
//   - path string
func (_e *Storage_Expecter) Directories(path interface{}) *Storage_Directories_Call {
	return &Storage_Directories_Call{Call: _e.mock.On("Directories", path)}
}

func (_c *Storage_Directories_Call) Run(run func(path string)) *Storage_Directories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_Directories_Call) Return(_a0 []string, _a1 error) *Storage_Directories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_Directories_Call) RunAndReturn(run func(string) ([]string, error)) *Storage_Directories_Call {
	_c.Call.Return(run)
	return _c
}

// Disk provides a mock function with given fields: disk
func (_m *Storage) Disk(disk string) filesystem.Driver {
	ret := _m.Called(disk)

	if len(ret) == 0 {
		panic("no return value specified for Disk")
	}

	var r0 filesystem.Driver
	if rf, ok := ret.Get(0).(func(string) filesystem.Driver); ok {
		r0 = rf(disk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filesystem.Driver)
		}
	}

	return r0
}

// Storage_Disk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Disk'
type Storage_Disk_Call struct {
	*mock.Call
}

// Disk is a helper method to define mock.On call
//   - disk string
func (_e *Storage_Expecter) Disk(disk interface{}) *Storage_Disk_Call {
	return &Storage_Disk_Call{Call: _e.mock.On("Disk", disk)}
}

func (_c *Storage_Disk_Call) Run(run func(disk string)) *Storage_Disk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_Disk_Call) Return(_a0 filesystem.Driver) *Storage_Disk_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_Disk_Call) RunAndReturn(run func(string) filesystem.Driver) *Storage_Disk_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function with given fields: file
func (_m *Storage) Exists(file string) bool {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Storage_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type Storage_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - file string
func (_e *Storage_Expecter) Exists(file interface{}) *Storage_Exists_Call {
	return &Storage_Exists_Call{Call: _e.mock.On("Exists", file)}
}

func (_c *Storage_Exists_Call) Run(run func(file string)) *Storage_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_Exists_Call) Return(_a0 bool) *Storage_Exists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_Exists_Call) RunAndReturn(run func(string) bool) *Storage_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Files provides a mock function with given fields: path
func (_m *Storage) Files(path string) ([]string, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for Files")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_Files_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Files'
type Storage_Files_Call struct {
	*mock.Call
}

// Files is a helper method to define mock.On call
//   - path string
func (_e *Storage_Expecter) Files(path interface{}) *Storage_Files_Call {
	return &Storage_Files_Call{Call: _e.mock.On("Files", path)}
}

func (_c *Storage_Files_Call) Run(run func(path string)) *Storage_Files_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_Files_Call) Return(_a0 []string, _a1 error) *Storage_Files_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_Files_Call) RunAndReturn(run func(string) ([]string, error)) *Storage_Files_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: file
func (_m *Storage) Get(file string) (string, error) {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Storage_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - file string
func (_e *Storage_Expecter) Get(file interface{}) *Storage_Get_Call {
	return &Storage_Get_Call{Call: _e.mock.On("Get", file)}
}

func (_c *Storage_Get_Call) Run(run func(file string)) *Storage_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_Get_Call) Return(_a0 string, _a1 error) *Storage_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_Get_Call) RunAndReturn(run func(string) (string, error)) *Storage_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetBytes provides a mock function with given fields: file
func (_m *Storage) GetBytes(file string) ([]byte, error) {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for GetBytes")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]byte, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = rf(file)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_GetBytes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBytes'
type Storage_GetBytes_Call struct {
	*mock.Call
}

// GetBytes is a helper method to define mock.On call
//   - file string
func (_e *Storage_Expecter) GetBytes(file interface{}) *Storage_GetBytes_Call {
	return &Storage_GetBytes_Call{Call: _e.mock.On("GetBytes", file)}
}

func (_c *Storage_GetBytes_Call) Run(run func(file string)) *Storage_GetBytes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_GetBytes_Call) Return(_a0 []byte, _a1 error) *Storage_GetBytes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_GetBytes_Call) RunAndReturn(run func(string) ([]byte, error)) *Storage_GetBytes_Call {
	_c.Call.Return(run)
	return _c
}

// LastModified provides a mock function with given fields: file
func (_m *Storage) LastModified(file string) (time.Time, error) {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for LastModified")
	}

	var r0 time.Time
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (time.Time, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(string) time.Time); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_LastModified_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LastModified'
type Storage_LastModified_Call struct {
	*mock.Call
}

// LastModified is a helper method to define mock.On call
//   - file string
func (_e *Storage_Expecter) LastModified(file interface{}) *Storage_LastModified_Call {
	return &Storage_LastModified_Call{Call: _e.mock.On("LastModified", file)}
}

func (_c *Storage_LastModified_Call) Run(run func(file string)) *Storage_LastModified_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_LastModified_Call) Return(_a0 time.Time, _a1 error) *Storage_LastModified_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_LastModified_Call) RunAndReturn(run func(string) (time.Time, error)) *Storage_LastModified_Call {
	_c.Call.Return(run)
	return _c
}

// MakeDirectory provides a mock function with given fields: directory
func (_m *Storage) MakeDirectory(directory string) error {
	ret := _m.Called(directory)

	if len(ret) == 0 {
		panic("no return value specified for MakeDirectory")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(directory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Storage_MakeDirectory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MakeDirectory'
type Storage_MakeDirectory_Call struct {
	*mock.Call
}

// MakeDirectory is a helper method to define mock.On call
//   - directory string
func (_e *Storage_Expecter) MakeDirectory(directory interface{}) *Storage_MakeDirectory_Call {
	return &Storage_MakeDirectory_Call{Call: _e.mock.On("MakeDirectory", directory)}
}

func (_c *Storage_MakeDirectory_Call) Run(run func(directory string)) *Storage_MakeDirectory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_MakeDirectory_Call) Return(_a0 error) *Storage_MakeDirectory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_MakeDirectory_Call) RunAndReturn(run func(string) error) *Storage_MakeDirectory_Call {
	_c.Call.Return(run)
	return _c
}

// MimeType provides a mock function with given fields: file
func (_m *Storage) MimeType(file string) (string, error) {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for MimeType")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_MimeType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MimeType'
type Storage_MimeType_Call struct {
	*mock.Call
}

// MimeType is a helper method to define mock.On call
//   - file string
func (_e *Storage_Expecter) MimeType(file interface{}) *Storage_MimeType_Call {
	return &Storage_MimeType_Call{Call: _e.mock.On("MimeType", file)}
}

func (_c *Storage_MimeType_Call) Run(run func(file string)) *Storage_MimeType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_MimeType_Call) Return(_a0 string, _a1 error) *Storage_MimeType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_MimeType_Call) RunAndReturn(run func(string) (string, error)) *Storage_MimeType_Call {
	_c.Call.Return(run)
	return _c
}

// Missing provides a mock function with given fields: file
func (_m *Storage) Missing(file string) bool {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Missing")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Storage_Missing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Missing'
type Storage_Missing_Call struct {
	*mock.Call
}

// Missing is a helper method to define mock.On call
//   - file string
func (_e *Storage_Expecter) Missing(file interface{}) *Storage_Missing_Call {
	return &Storage_Missing_Call{Call: _e.mock.On("Missing", file)}
}

func (_c *Storage_Missing_Call) Run(run func(file string)) *Storage_Missing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_Missing_Call) Return(_a0 bool) *Storage_Missing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_Missing_Call) RunAndReturn(run func(string) bool) *Storage_Missing_Call {
	_c.Call.Return(run)
	return _c
}

// Move provides a mock function with given fields: oldFile, newFile
func (_m *Storage) Move(oldFile string, newFile string) error {
	ret := _m.Called(oldFile, newFile)

	if len(ret) == 0 {
		panic("no return value specified for Move")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(oldFile, newFile)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Storage_Move_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Move'
type Storage_Move_Call struct {
	*mock.Call
}

// Move is a helper method to define mock.On call
//   - oldFile string
//   - newFile string
func (_e *Storage_Expecter) Move(oldFile interface{}, newFile interface{}) *Storage_Move_Call {
	return &Storage_Move_Call{Call: _e.mock.On("Move", oldFile, newFile)}
}

func (_c *Storage_Move_Call) Run(run func(oldFile string, newFile string)) *Storage_Move_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Storage_Move_Call) Return(_a0 error) *Storage_Move_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_Move_Call) RunAndReturn(run func(string, string) error) *Storage_Move_Call {
	_c.Call.Return(run)
	return _c
}

// Path provides a mock function with given fields: file
func (_m *Storage) Path(file string) string {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Path")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Storage_Path_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Path'
type Storage_Path_Call struct {
	*mock.Call
}

// Path is a helper method to define mock.On call
//   - file string
func (_e *Storage_Expecter) Path(file interface{}) *Storage_Path_Call {
	return &Storage_Path_Call{Call: _e.mock.On("Path", file)}
}

func (_c *Storage_Path_Call) Run(run func(file string)) *Storage_Path_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_Path_Call) Return(_a0 string) *Storage_Path_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_Path_Call) RunAndReturn(run func(string) string) *Storage_Path_Call {
	_c.Call.Return(run)
	return _c
}

// Put provides a mock function with given fields: file, content
func (_m *Storage) Put(file string, content string) error {
	ret := _m.Called(file, content)

	if len(ret) == 0 {
		panic("no return value specified for Put")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(file, content)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Storage_Put_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Put'
type Storage_Put_Call struct {
	*mock.Call
}

// Put is a helper method to define mock.On call
//   - file string
//   - content string
func (_e *Storage_Expecter) Put(file interface{}, content interface{}) *Storage_Put_Call {
	return &Storage_Put_Call{Call: _e.mock.On("Put", file, content)}
}

func (_c *Storage_Put_Call) Run(run func(file string, content string)) *Storage_Put_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Storage_Put_Call) Return(_a0 error) *Storage_Put_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_Put_Call) RunAndReturn(run func(string, string) error) *Storage_Put_Call {
	_c.Call.Return(run)
	return _c
}

// PutFile provides a mock function with given fields: path, source
func (_m *Storage) PutFile(path string, source filesystem.File) (string, error) {
	ret := _m.Called(path, source)

	if len(ret) == 0 {
		panic("no return value specified for PutFile")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, filesystem.File) (string, error)); ok {
		return rf(path, source)
	}
	if rf, ok := ret.Get(0).(func(string, filesystem.File) string); ok {
		r0 = rf(path, source)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, filesystem.File) error); ok {
		r1 = rf(path, source)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_PutFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutFile'
type Storage_PutFile_Call struct {
	*mock.Call
}

// PutFile is a helper method to define mock.On call
//   - path string
//   - source filesystem.File
func (_e *Storage_Expecter) PutFile(path interface{}, source interface{}) *Storage_PutFile_Call {
	return &Storage_PutFile_Call{Call: _e.mock.On("PutFile", path, source)}
}

func (_c *Storage_PutFile_Call) Run(run func(path string, source filesystem.File)) *Storage_PutFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(filesystem.File))
	})
	return _c
}

func (_c *Storage_PutFile_Call) Return(_a0 string, _a1 error) *Storage_PutFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_PutFile_Call) RunAndReturn(run func(string, filesystem.File) (string, error)) *Storage_PutFile_Call {
	_c.Call.Return(run)
	return _c
}

// PutFileAs provides a mock function with given fields: path, source, name
func (_m *Storage) PutFileAs(path string, source filesystem.File, name string) (string, error) {
	ret := _m.Called(path, source, name)

	if len(ret) == 0 {
		panic("no return value specified for PutFileAs")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, filesystem.File, string) (string, error)); ok {
		return rf(path, source, name)
	}
	if rf, ok := ret.Get(0).(func(string, filesystem.File, string) string); ok {
		r0 = rf(path, source, name)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, filesystem.File, string) error); ok {
		r1 = rf(path, source, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_PutFileAs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutFileAs'
type Storage_PutFileAs_Call struct {
	*mock.Call
}

// PutFileAs is a helper method to define mock.On call
//   - path string
//   - source filesystem.File
//   - name string
func (_e *Storage_Expecter) PutFileAs(path interface{}, source interface{}, name interface{}) *Storage_PutFileAs_Call {
	return &Storage_PutFileAs_Call{Call: _e.mock.On("PutFileAs", path, source, name)}
}

func (_c *Storage_PutFileAs_Call) Run(run func(path string, source filesystem.File, name string)) *Storage_PutFileAs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(filesystem.File), args[2].(string))
	})
	return _c
}

func (_c *Storage_PutFileAs_Call) Return(_a0 string, _a1 error) *Storage_PutFileAs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_PutFileAs_Call) RunAndReturn(run func(string, filesystem.File, string) (string, error)) *Storage_PutFileAs_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function with given fields: file
func (_m *Storage) Size(file string) (int64, error) {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (int64, error)); ok {
		return rf(file)
	}
	if rf, ok := ret.Get(0).(func(string) int64); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type Storage_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
//   - file string
func (_e *Storage_Expecter) Size(file interface{}) *Storage_Size_Call {
	return &Storage_Size_Call{Call: _e.mock.On("Size", file)}
}

func (_c *Storage_Size_Call) Run(run func(file string)) *Storage_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_Size_Call) Return(_a0 int64, _a1 error) *Storage_Size_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_Size_Call) RunAndReturn(run func(string) (int64, error)) *Storage_Size_Call {
	_c.Call.Return(run)
	return _c
}

// TemporaryUrl provides a mock function with given fields: file, _a1
func (_m *Storage) TemporaryUrl(file string, _a1 time.Time) (string, error) {
	ret := _m.Called(file, _a1)

	if len(ret) == 0 {
		panic("no return value specified for TemporaryUrl")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, time.Time) (string, error)); ok {
		return rf(file, _a1)
	}
	if rf, ok := ret.Get(0).(func(string, time.Time) string); ok {
		r0 = rf(file, _a1)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, time.Time) error); ok {
		r1 = rf(file, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Storage_TemporaryUrl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TemporaryUrl'
type Storage_TemporaryUrl_Call struct {
	*mock.Call
}

// TemporaryUrl is a helper method to define mock.On call
//   - file string
//   - _a1 time.Time
func (_e *Storage_Expecter) TemporaryUrl(file interface{}, _a1 interface{}) *Storage_TemporaryUrl_Call {
	return &Storage_TemporaryUrl_Call{Call: _e.mock.On("TemporaryUrl", file, _a1)}
}

func (_c *Storage_TemporaryUrl_Call) Run(run func(file string, _a1 time.Time)) *Storage_TemporaryUrl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Time))
	})
	return _c
}

func (_c *Storage_TemporaryUrl_Call) Return(_a0 string, _a1 error) *Storage_TemporaryUrl_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Storage_TemporaryUrl_Call) RunAndReturn(run func(string, time.Time) (string, error)) *Storage_TemporaryUrl_Call {
	_c.Call.Return(run)
	return _c
}

// Url provides a mock function with given fields: file
func (_m *Storage) Url(file string) string {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for Url")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Storage_Url_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Url'
type Storage_Url_Call struct {
	*mock.Call
}

// Url is a helper method to define mock.On call
//   - file string
func (_e *Storage_Expecter) Url(file interface{}) *Storage_Url_Call {
	return &Storage_Url_Call{Call: _e.mock.On("Url", file)}
}

func (_c *Storage_Url_Call) Run(run func(file string)) *Storage_Url_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Storage_Url_Call) Return(_a0 string) *Storage_Url_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_Url_Call) RunAndReturn(run func(string) string) *Storage_Url_Call {
	_c.Call.Return(run)
	return _c
}

// WithContext provides a mock function with given fields: ctx
func (_m *Storage) WithContext(ctx context.Context) filesystem.Driver {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WithContext")
	}

	var r0 filesystem.Driver
	if rf, ok := ret.Get(0).(func(context.Context) filesystem.Driver); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filesystem.Driver)
		}
	}

	return r0
}

// Storage_WithContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithContext'
type Storage_WithContext_Call struct {
	*mock.Call
}

// WithContext is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Storage_Expecter) WithContext(ctx interface{}) *Storage_WithContext_Call {
	return &Storage_WithContext_Call{Call: _e.mock.On("WithContext", ctx)}
}

func (_c *Storage_WithContext_Call) Run(run func(ctx context.Context)) *Storage_WithContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Storage_WithContext_Call) Return(_a0 filesystem.Driver) *Storage_WithContext_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Storage_WithContext_Call) RunAndReturn(run func(context.Context) filesystem.Driver) *Storage_WithContext_Call {
	_c.Call.Return(run)
	return _c
}

// NewStorage creates a new instance of Storage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *Storage {
	mock := &Storage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
