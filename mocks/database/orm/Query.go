// Code generated by mockery. DO NOT EDIT.

package orm

import (
	db "github.com/goravel/framework/contracts/database/db"
	mock "github.com/stretchr/testify/mock"

	orm "github.com/goravel/framework/contracts/database/orm"

	sql "database/sql"
)

// Query is an autogenerated mock type for the Query type
type Query struct {
	mock.Mock
}

type Query_Expecter struct {
	mock *mock.Mock
}

func (_m *Query) EXPECT() *Query_Expecter {
	return &Query_Expecter{mock: &_m.Mock}
}

// Association provides a mock function with given fields: association
func (_m *Query) Association(association string) orm.Association {
	ret := _m.Called(association)

	if len(ret) == 0 {
		panic("no return value specified for Association")
	}

	var r0 orm.Association
	if rf, ok := ret.Get(0).(func(string) orm.Association); ok {
		r0 = rf(association)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Association)
		}
	}

	return r0
}

// Query_Association_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Association'
type Query_Association_Call struct {
	*mock.Call
}

// Association is a helper method to define mock.On call
//   - association string
func (_e *Query_Expecter) Association(association interface{}) *Query_Association_Call {
	return &Query_Association_Call{Call: _e.mock.On("Association", association)}
}

func (_c *Query_Association_Call) Run(run func(association string)) *Query_Association_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Query_Association_Call) Return(_a0 orm.Association) *Query_Association_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Association_Call) RunAndReturn(run func(string) orm.Association) *Query_Association_Call {
	_c.Call.Return(run)
	return _c
}

// Avg provides a mock function with given fields: column, dest
func (_m *Query) Avg(column string, dest interface{}) error {
	ret := _m.Called(column, dest)

	if len(ret) == 0 {
		panic("no return value specified for Avg")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(column, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Avg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Avg'
type Query_Avg_Call struct {
	*mock.Call
}

// Avg is a helper method to define mock.On call
//   - column string
//   - dest interface{}
func (_e *Query_Expecter) Avg(column interface{}, dest interface{}) *Query_Avg_Call {
	return &Query_Avg_Call{Call: _e.mock.On("Avg", column, dest)}
}

func (_c *Query_Avg_Call) Run(run func(column string, dest interface{})) *Query_Avg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Query_Avg_Call) Return(_a0 error) *Query_Avg_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Avg_Call) RunAndReturn(run func(string, interface{}) error) *Query_Avg_Call {
	_c.Call.Return(run)
	return _c
}

// Begin provides a mock function with no fields
func (_m *Query) Begin() (orm.Query, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Begin")
	}

	var r0 orm.Query
	var r1 error
	if rf, ok := ret.Get(0).(func() (orm.Query, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query_Begin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Begin'
type Query_Begin_Call struct {
	*mock.Call
}

// Begin is a helper method to define mock.On call
func (_e *Query_Expecter) Begin() *Query_Begin_Call {
	return &Query_Begin_Call{Call: _e.mock.On("Begin")}
}

func (_c *Query_Begin_Call) Run(run func()) *Query_Begin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_Begin_Call) Return(_a0 orm.Query, _a1 error) *Query_Begin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Query_Begin_Call) RunAndReturn(run func() (orm.Query, error)) *Query_Begin_Call {
	_c.Call.Return(run)
	return _c
}

// BeginTransaction provides a mock function with no fields
func (_m *Query) BeginTransaction() (orm.Query, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BeginTransaction")
	}

	var r0 orm.Query
	var r1 error
	if rf, ok := ret.Get(0).(func() (orm.Query, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query_BeginTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BeginTransaction'
type Query_BeginTransaction_Call struct {
	*mock.Call
}

// BeginTransaction is a helper method to define mock.On call
func (_e *Query_Expecter) BeginTransaction() *Query_BeginTransaction_Call {
	return &Query_BeginTransaction_Call{Call: _e.mock.On("BeginTransaction")}
}

func (_c *Query_BeginTransaction_Call) Run(run func()) *Query_BeginTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_BeginTransaction_Call) Return(_a0 orm.Query, _a1 error) *Query_BeginTransaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Query_BeginTransaction_Call) RunAndReturn(run func() (orm.Query, error)) *Query_BeginTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with no fields
func (_m *Query) Commit() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type Query_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
func (_e *Query_Expecter) Commit() *Query_Commit_Call {
	return &Query_Commit_Call{Call: _e.mock.On("Commit")}
}

func (_c *Query_Commit_Call) Run(run func()) *Query_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_Commit_Call) Return(_a0 error) *Query_Commit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Commit_Call) RunAndReturn(run func() error) *Query_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function with no fields
func (_m *Query) Count() (int64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func() (int64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type Query_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
func (_e *Query_Expecter) Count() *Query_Count_Call {
	return &Query_Count_Call{Call: _e.mock.On("Count")}
}

func (_c *Query_Count_Call) Run(run func()) *Query_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_Count_Call) Return(_a0 int64, _a1 error) *Query_Count_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Query_Count_Call) RunAndReturn(run func() (int64, error)) *Query_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: value
func (_m *Query) Create(value interface{}) error {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type Query_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - value interface{}
func (_e *Query_Expecter) Create(value interface{}) *Query_Create_Call {
	return &Query_Create_Call{Call: _e.mock.On("Create", value)}
}

func (_c *Query_Create_Call) Run(run func(value interface{})) *Query_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Query_Create_Call) Return(_a0 error) *Query_Create_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Create_Call) RunAndReturn(run func(interface{}) error) *Query_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Cursor provides a mock function with no fields
func (_m *Query) Cursor() chan db.Row {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Cursor")
	}

	var r0 chan db.Row
	if rf, ok := ret.Get(0).(func() chan db.Row); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan db.Row)
		}
	}

	return r0
}

// Query_Cursor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cursor'
type Query_Cursor_Call struct {
	*mock.Call
}

// Cursor is a helper method to define mock.On call
func (_e *Query_Expecter) Cursor() *Query_Cursor_Call {
	return &Query_Cursor_Call{Call: _e.mock.On("Cursor")}
}

func (_c *Query_Cursor_Call) Run(run func()) *Query_Cursor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_Cursor_Call) Return(_a0 chan db.Row) *Query_Cursor_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Cursor_Call) RunAndReturn(run func() chan db.Row) *Query_Cursor_Call {
	_c.Call.Return(run)
	return _c
}

// DB provides a mock function with no fields
func (_m *Query) DB() (*sql.DB, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DB")
	}

	var r0 *sql.DB
	var r1 error
	if rf, ok := ret.Get(0).(func() (*sql.DB, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *sql.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.DB)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query_DB_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DB'
type Query_DB_Call struct {
	*mock.Call
}

// DB is a helper method to define mock.On call
func (_e *Query_Expecter) DB() *Query_DB_Call {
	return &Query_DB_Call{Call: _e.mock.On("DB")}
}

func (_c *Query_DB_Call) Run(run func()) *Query_DB_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_DB_Call) Return(_a0 *sql.DB, _a1 error) *Query_DB_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Query_DB_Call) RunAndReturn(run func() (*sql.DB, error)) *Query_DB_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: value
func (_m *Query) Delete(value ...interface{}) (*db.Result, error) {
	var _ca []interface{}
	_ca = append(_ca, value...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 *db.Result
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*db.Result, error)); ok {
		return rf(value...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *db.Result); ok {
		r0 = rf(value...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(value...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Query_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - value ...interface{}
func (_e *Query_Expecter) Delete(value ...interface{}) *Query_Delete_Call {
	return &Query_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{}, value...)...)}
}

func (_c *Query_Delete_Call) Run(run func(value ...interface{})) *Query_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Query_Delete_Call) Return(_a0 *db.Result, _a1 error) *Query_Delete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Query_Delete_Call) RunAndReturn(run func(...interface{}) (*db.Result, error)) *Query_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Distinct provides a mock function with given fields: columns
func (_m *Query) Distinct(columns ...string) orm.Query {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Distinct")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(...string) orm.Query); ok {
		r0 = rf(columns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Distinct_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Distinct'
type Query_Distinct_Call struct {
	*mock.Call
}

// Distinct is a helper method to define mock.On call
//   - columns ...string
func (_e *Query_Expecter) Distinct(columns ...interface{}) *Query_Distinct_Call {
	return &Query_Distinct_Call{Call: _e.mock.On("Distinct",
		append([]interface{}{}, columns...)...)}
}

func (_c *Query_Distinct_Call) Run(run func(columns ...string)) *Query_Distinct_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Query_Distinct_Call) Return(_a0 orm.Query) *Query_Distinct_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Distinct_Call) RunAndReturn(run func(...string) orm.Query) *Query_Distinct_Call {
	_c.Call.Return(run)
	return _c
}

// Driver provides a mock function with no fields
func (_m *Query) Driver() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Driver")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Query_Driver_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Driver'
type Query_Driver_Call struct {
	*mock.Call
}

// Driver is a helper method to define mock.On call
func (_e *Query_Expecter) Driver() *Query_Driver_Call {
	return &Query_Driver_Call{Call: _e.mock.On("Driver")}
}

func (_c *Query_Driver_Call) Run(run func()) *Query_Driver_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_Driver_Call) Return(_a0 string) *Query_Driver_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Driver_Call) RunAndReturn(run func() string) *Query_Driver_Call {
	_c.Call.Return(run)
	return _c
}

// Exec provides a mock function with given fields: _a0, values
func (_m *Query) Exec(_a0 string, values ...interface{}) (*db.Result, error) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *db.Result
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (*db.Result, error)); ok {
		return rf(_a0, values...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *db.Result); ok {
		r0 = rf(_a0, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(_a0, values...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type Query_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - _a0 string
//   - values ...interface{}
func (_e *Query_Expecter) Exec(_a0 interface{}, values ...interface{}) *Query_Exec_Call {
	return &Query_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{_a0}, values...)...)}
}

func (_c *Query_Exec_Call) Run(run func(_a0 string, values ...interface{})) *Query_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Query_Exec_Call) Return(_a0 *db.Result, _a1 error) *Query_Exec_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Query_Exec_Call) RunAndReturn(run func(string, ...interface{}) (*db.Result, error)) *Query_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function with no fields
func (_m *Query) Exists() (bool, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func() (bool, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type Query_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
func (_e *Query_Expecter) Exists() *Query_Exists_Call {
	return &Query_Exists_Call{Call: _e.mock.On("Exists")}
}

func (_c *Query_Exists_Call) Run(run func()) *Query_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_Exists_Call) Return(_a0 bool, _a1 error) *Query_Exists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Query_Exists_Call) RunAndReturn(run func() (bool, error)) *Query_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function with given fields: dest, conds
func (_m *Query) Find(dest interface{}, conds ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Find")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) error); ok {
		r0 = rf(dest, conds...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type Query_Find_Call struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *Query_Expecter) Find(dest interface{}, conds ...interface{}) *Query_Find_Call {
	return &Query_Find_Call{Call: _e.mock.On("Find",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *Query_Find_Call) Run(run func(dest interface{}, conds ...interface{})) *Query_Find_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Query_Find_Call) Return(_a0 error) *Query_Find_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Find_Call) RunAndReturn(run func(interface{}, ...interface{}) error) *Query_Find_Call {
	_c.Call.Return(run)
	return _c
}

// FindOrFail provides a mock function with given fields: dest, conds
func (_m *Query) FindOrFail(dest interface{}, conds ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindOrFail")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) error); ok {
		r0 = rf(dest, conds...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_FindOrFail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOrFail'
type Query_FindOrFail_Call struct {
	*mock.Call
}

// FindOrFail is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *Query_Expecter) FindOrFail(dest interface{}, conds ...interface{}) *Query_FindOrFail_Call {
	return &Query_FindOrFail_Call{Call: _e.mock.On("FindOrFail",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *Query_FindOrFail_Call) Run(run func(dest interface{}, conds ...interface{})) *Query_FindOrFail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Query_FindOrFail_Call) Return(_a0 error) *Query_FindOrFail_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_FindOrFail_Call) RunAndReturn(run func(interface{}, ...interface{}) error) *Query_FindOrFail_Call {
	_c.Call.Return(run)
	return _c
}

// First provides a mock function with given fields: dest
func (_m *Query) First(dest interface{}) error {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for First")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_First_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'First'
type Query_First_Call struct {
	*mock.Call
}

// First is a helper method to define mock.On call
//   - dest interface{}
func (_e *Query_Expecter) First(dest interface{}) *Query_First_Call {
	return &Query_First_Call{Call: _e.mock.On("First", dest)}
}

func (_c *Query_First_Call) Run(run func(dest interface{})) *Query_First_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Query_First_Call) Return(_a0 error) *Query_First_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_First_Call) RunAndReturn(run func(interface{}) error) *Query_First_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOr provides a mock function with given fields: dest, callback
func (_m *Query) FirstOr(dest interface{}, callback func() error) error {
	ret := _m.Called(dest, callback)

	if len(ret) == 0 {
		panic("no return value specified for FirstOr")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, func() error) error); ok {
		r0 = rf(dest, callback)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_FirstOr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOr'
type Query_FirstOr_Call struct {
	*mock.Call
}

// FirstOr is a helper method to define mock.On call
//   - dest interface{}
//   - callback func() error
func (_e *Query_Expecter) FirstOr(dest interface{}, callback interface{}) *Query_FirstOr_Call {
	return &Query_FirstOr_Call{Call: _e.mock.On("FirstOr", dest, callback)}
}

func (_c *Query_FirstOr_Call) Run(run func(dest interface{}, callback func() error)) *Query_FirstOr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(func() error))
	})
	return _c
}

func (_c *Query_FirstOr_Call) Return(_a0 error) *Query_FirstOr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_FirstOr_Call) RunAndReturn(run func(interface{}, func() error) error) *Query_FirstOr_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrCreate provides a mock function with given fields: dest, conds
func (_m *Query) FirstOrCreate(dest interface{}, conds ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FirstOrCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) error); ok {
		r0 = rf(dest, conds...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_FirstOrCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrCreate'
type Query_FirstOrCreate_Call struct {
	*mock.Call
}

// FirstOrCreate is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *Query_Expecter) FirstOrCreate(dest interface{}, conds ...interface{}) *Query_FirstOrCreate_Call {
	return &Query_FirstOrCreate_Call{Call: _e.mock.On("FirstOrCreate",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *Query_FirstOrCreate_Call) Run(run func(dest interface{}, conds ...interface{})) *Query_FirstOrCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Query_FirstOrCreate_Call) Return(_a0 error) *Query_FirstOrCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_FirstOrCreate_Call) RunAndReturn(run func(interface{}, ...interface{}) error) *Query_FirstOrCreate_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrFail provides a mock function with given fields: dest
func (_m *Query) FirstOrFail(dest interface{}) error {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for FirstOrFail")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_FirstOrFail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrFail'
type Query_FirstOrFail_Call struct {
	*mock.Call
}

// FirstOrFail is a helper method to define mock.On call
//   - dest interface{}
func (_e *Query_Expecter) FirstOrFail(dest interface{}) *Query_FirstOrFail_Call {
	return &Query_FirstOrFail_Call{Call: _e.mock.On("FirstOrFail", dest)}
}

func (_c *Query_FirstOrFail_Call) Run(run func(dest interface{})) *Query_FirstOrFail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Query_FirstOrFail_Call) Return(_a0 error) *Query_FirstOrFail_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_FirstOrFail_Call) RunAndReturn(run func(interface{}) error) *Query_FirstOrFail_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrNew provides a mock function with given fields: dest, attributes, values
func (_m *Query) FirstOrNew(dest interface{}, attributes interface{}, values ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest, attributes)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FirstOrNew")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...interface{}) error); ok {
		r0 = rf(dest, attributes, values...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_FirstOrNew_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrNew'
type Query_FirstOrNew_Call struct {
	*mock.Call
}

// FirstOrNew is a helper method to define mock.On call
//   - dest interface{}
//   - attributes interface{}
//   - values ...interface{}
func (_e *Query_Expecter) FirstOrNew(dest interface{}, attributes interface{}, values ...interface{}) *Query_FirstOrNew_Call {
	return &Query_FirstOrNew_Call{Call: _e.mock.On("FirstOrNew",
		append([]interface{}{dest, attributes}, values...)...)}
}

func (_c *Query_FirstOrNew_Call) Run(run func(dest interface{}, attributes interface{}, values ...interface{})) *Query_FirstOrNew_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Query_FirstOrNew_Call) Return(_a0 error) *Query_FirstOrNew_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_FirstOrNew_Call) RunAndReturn(run func(interface{}, interface{}, ...interface{}) error) *Query_FirstOrNew_Call {
	_c.Call.Return(run)
	return _c
}

// ForceDelete provides a mock function with given fields: value
func (_m *Query) ForceDelete(value ...interface{}) (*db.Result, error) {
	var _ca []interface{}
	_ca = append(_ca, value...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ForceDelete")
	}

	var r0 *db.Result
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*db.Result, error)); ok {
		return rf(value...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *db.Result); ok {
		r0 = rf(value...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(value...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query_ForceDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForceDelete'
type Query_ForceDelete_Call struct {
	*mock.Call
}

// ForceDelete is a helper method to define mock.On call
//   - value ...interface{}
func (_e *Query_Expecter) ForceDelete(value ...interface{}) *Query_ForceDelete_Call {
	return &Query_ForceDelete_Call{Call: _e.mock.On("ForceDelete",
		append([]interface{}{}, value...)...)}
}

func (_c *Query_ForceDelete_Call) Run(run func(value ...interface{})) *Query_ForceDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Query_ForceDelete_Call) Return(_a0 *db.Result, _a1 error) *Query_ForceDelete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Query_ForceDelete_Call) RunAndReturn(run func(...interface{}) (*db.Result, error)) *Query_ForceDelete_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: dest
func (_m *Query) Get(dest interface{}) error {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Query_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - dest interface{}
func (_e *Query_Expecter) Get(dest interface{}) *Query_Get_Call {
	return &Query_Get_Call{Call: _e.mock.On("Get", dest)}
}

func (_c *Query_Get_Call) Run(run func(dest interface{})) *Query_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Query_Get_Call) Return(_a0 error) *Query_Get_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Get_Call) RunAndReturn(run func(interface{}) error) *Query_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Group provides a mock function with given fields: column
func (_m *Query) Group(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Group")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Group_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Group'
type Query_Group_Call struct {
	*mock.Call
}

// Group is a helper method to define mock.On call
//   - column string
func (_e *Query_Expecter) Group(column interface{}) *Query_Group_Call {
	return &Query_Group_Call{Call: _e.mock.On("Group", column)}
}

func (_c *Query_Group_Call) Run(run func(column string)) *Query_Group_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Query_Group_Call) Return(_a0 orm.Query) *Query_Group_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Group_Call) RunAndReturn(run func(string) orm.Query) *Query_Group_Call {
	_c.Call.Return(run)
	return _c
}

// GroupBy provides a mock function with given fields: column
func (_m *Query) GroupBy(column ...string) orm.Query {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupBy")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(...string) orm.Query); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_GroupBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GroupBy'
type Query_GroupBy_Call struct {
	*mock.Call
}

// GroupBy is a helper method to define mock.On call
//   - column ...string
func (_e *Query_Expecter) GroupBy(column ...interface{}) *Query_GroupBy_Call {
	return &Query_GroupBy_Call{Call: _e.mock.On("GroupBy",
		append([]interface{}{}, column...)...)}
}

func (_c *Query_GroupBy_Call) Run(run func(column ...string)) *Query_GroupBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Query_GroupBy_Call) Return(_a0 orm.Query) *Query_GroupBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_GroupBy_Call) RunAndReturn(run func(...string) orm.Query) *Query_GroupBy_Call {
	_c.Call.Return(run)
	return _c
}

// Having provides a mock function with given fields: query, args
func (_m *Query) Having(query interface{}, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Having")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Having_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Having'
type Query_Having_Call struct {
	*mock.Call
}

// Having is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *Query_Expecter) Having(query interface{}, args ...interface{}) *Query_Having_Call {
	return &Query_Having_Call{Call: _e.mock.On("Having",
		append([]interface{}{query}, args...)...)}
}

func (_c *Query_Having_Call) Run(run func(query interface{}, args ...interface{})) *Query_Having_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Query_Having_Call) Return(_a0 orm.Query) *Query_Having_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Having_Call) RunAndReturn(run func(interface{}, ...interface{}) orm.Query) *Query_Having_Call {
	_c.Call.Return(run)
	return _c
}

// InRandomOrder provides a mock function with no fields
func (_m *Query) InRandomOrder() orm.Query {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for InRandomOrder")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_InRandomOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InRandomOrder'
type Query_InRandomOrder_Call struct {
	*mock.Call
}

// InRandomOrder is a helper method to define mock.On call
func (_e *Query_Expecter) InRandomOrder() *Query_InRandomOrder_Call {
	return &Query_InRandomOrder_Call{Call: _e.mock.On("InRandomOrder")}
}

func (_c *Query_InRandomOrder_Call) Run(run func()) *Query_InRandomOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_InRandomOrder_Call) Return(_a0 orm.Query) *Query_InRandomOrder_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_InRandomOrder_Call) RunAndReturn(run func() orm.Query) *Query_InRandomOrder_Call {
	_c.Call.Return(run)
	return _c
}

// InTransaction provides a mock function with no fields
func (_m *Query) InTransaction() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for InTransaction")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Query_InTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InTransaction'
type Query_InTransaction_Call struct {
	*mock.Call
}

// InTransaction is a helper method to define mock.On call
func (_e *Query_Expecter) InTransaction() *Query_InTransaction_Call {
	return &Query_InTransaction_Call{Call: _e.mock.On("InTransaction")}
}

func (_c *Query_InTransaction_Call) Run(run func()) *Query_InTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_InTransaction_Call) Return(_a0 bool) *Query_InTransaction_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_InTransaction_Call) RunAndReturn(run func() bool) *Query_InTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// Join provides a mock function with given fields: query, args
func (_m *Query) Join(query string, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Join")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Join_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Join'
type Query_Join_Call struct {
	*mock.Call
}

// Join is a helper method to define mock.On call
//   - query string
//   - args ...interface{}
func (_e *Query_Expecter) Join(query interface{}, args ...interface{}) *Query_Join_Call {
	return &Query_Join_Call{Call: _e.mock.On("Join",
		append([]interface{}{query}, args...)...)}
}

func (_c *Query_Join_Call) Run(run func(query string, args ...interface{})) *Query_Join_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Query_Join_Call) Return(_a0 orm.Query) *Query_Join_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Join_Call) RunAndReturn(run func(string, ...interface{}) orm.Query) *Query_Join_Call {
	_c.Call.Return(run)
	return _c
}

// Limit provides a mock function with given fields: limit
func (_m *Query) Limit(limit int) orm.Query {
	ret := _m.Called(limit)

	if len(ret) == 0 {
		panic("no return value specified for Limit")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(int) orm.Query); ok {
		r0 = rf(limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Limit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Limit'
type Query_Limit_Call struct {
	*mock.Call
}

// Limit is a helper method to define mock.On call
//   - limit int
func (_e *Query_Expecter) Limit(limit interface{}) *Query_Limit_Call {
	return &Query_Limit_Call{Call: _e.mock.On("Limit", limit)}
}

func (_c *Query_Limit_Call) Run(run func(limit int)) *Query_Limit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Query_Limit_Call) Return(_a0 orm.Query) *Query_Limit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Limit_Call) RunAndReturn(run func(int) orm.Query) *Query_Limit_Call {
	_c.Call.Return(run)
	return _c
}

// Load provides a mock function with given fields: dest, relation, args
func (_m *Query) Load(dest interface{}, relation string, args ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest, relation)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Load")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, string, ...interface{}) error); ok {
		r0 = rf(dest, relation, args...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Load_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Load'
type Query_Load_Call struct {
	*mock.Call
}

// Load is a helper method to define mock.On call
//   - dest interface{}
//   - relation string
//   - args ...interface{}
func (_e *Query_Expecter) Load(dest interface{}, relation interface{}, args ...interface{}) *Query_Load_Call {
	return &Query_Load_Call{Call: _e.mock.On("Load",
		append([]interface{}{dest, relation}, args...)...)}
}

func (_c *Query_Load_Call) Run(run func(dest interface{}, relation string, args ...interface{})) *Query_Load_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *Query_Load_Call) Return(_a0 error) *Query_Load_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Load_Call) RunAndReturn(run func(interface{}, string, ...interface{}) error) *Query_Load_Call {
	_c.Call.Return(run)
	return _c
}

// LoadMissing provides a mock function with given fields: dest, relation, args
func (_m *Query) LoadMissing(dest interface{}, relation string, args ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest, relation)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoadMissing")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, string, ...interface{}) error); ok {
		r0 = rf(dest, relation, args...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_LoadMissing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadMissing'
type Query_LoadMissing_Call struct {
	*mock.Call
}

// LoadMissing is a helper method to define mock.On call
//   - dest interface{}
//   - relation string
//   - args ...interface{}
func (_e *Query_Expecter) LoadMissing(dest interface{}, relation interface{}, args ...interface{}) *Query_LoadMissing_Call {
	return &Query_LoadMissing_Call{Call: _e.mock.On("LoadMissing",
		append([]interface{}{dest, relation}, args...)...)}
}

func (_c *Query_LoadMissing_Call) Run(run func(dest interface{}, relation string, args ...interface{})) *Query_LoadMissing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *Query_LoadMissing_Call) Return(_a0 error) *Query_LoadMissing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_LoadMissing_Call) RunAndReturn(run func(interface{}, string, ...interface{}) error) *Query_LoadMissing_Call {
	_c.Call.Return(run)
	return _c
}

// LockForUpdate provides a mock function with no fields
func (_m *Query) LockForUpdate() orm.Query {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LockForUpdate")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_LockForUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockForUpdate'
type Query_LockForUpdate_Call struct {
	*mock.Call
}

// LockForUpdate is a helper method to define mock.On call
func (_e *Query_Expecter) LockForUpdate() *Query_LockForUpdate_Call {
	return &Query_LockForUpdate_Call{Call: _e.mock.On("LockForUpdate")}
}

func (_c *Query_LockForUpdate_Call) Run(run func()) *Query_LockForUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_LockForUpdate_Call) Return(_a0 orm.Query) *Query_LockForUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_LockForUpdate_Call) RunAndReturn(run func() orm.Query) *Query_LockForUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// Max provides a mock function with given fields: column, dest
func (_m *Query) Max(column string, dest interface{}) error {
	ret := _m.Called(column, dest)

	if len(ret) == 0 {
		panic("no return value specified for Max")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(column, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Max_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Max'
type Query_Max_Call struct {
	*mock.Call
}

// Max is a helper method to define mock.On call
//   - column string
//   - dest interface{}
func (_e *Query_Expecter) Max(column interface{}, dest interface{}) *Query_Max_Call {
	return &Query_Max_Call{Call: _e.mock.On("Max", column, dest)}
}

func (_c *Query_Max_Call) Run(run func(column string, dest interface{})) *Query_Max_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Query_Max_Call) Return(_a0 error) *Query_Max_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Max_Call) RunAndReturn(run func(string, interface{}) error) *Query_Max_Call {
	_c.Call.Return(run)
	return _c
}

// Min provides a mock function with given fields: column, dest
func (_m *Query) Min(column string, dest interface{}) error {
	ret := _m.Called(column, dest)

	if len(ret) == 0 {
		panic("no return value specified for Min")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(column, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Min_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Min'
type Query_Min_Call struct {
	*mock.Call
}

// Min is a helper method to define mock.On call
//   - column string
//   - dest interface{}
func (_e *Query_Expecter) Min(column interface{}, dest interface{}) *Query_Min_Call {
	return &Query_Min_Call{Call: _e.mock.On("Min", column, dest)}
}

func (_c *Query_Min_Call) Run(run func(column string, dest interface{})) *Query_Min_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Query_Min_Call) Return(_a0 error) *Query_Min_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Min_Call) RunAndReturn(run func(string, interface{}) error) *Query_Min_Call {
	_c.Call.Return(run)
	return _c
}

// Model provides a mock function with given fields: value
func (_m *Query) Model(value interface{}) orm.Query {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for Model")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}) orm.Query); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Model_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Model'
type Query_Model_Call struct {
	*mock.Call
}

// Model is a helper method to define mock.On call
//   - value interface{}
func (_e *Query_Expecter) Model(value interface{}) *Query_Model_Call {
	return &Query_Model_Call{Call: _e.mock.On("Model", value)}
}

func (_c *Query_Model_Call) Run(run func(value interface{})) *Query_Model_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Query_Model_Call) Return(_a0 orm.Query) *Query_Model_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Model_Call) RunAndReturn(run func(interface{}) orm.Query) *Query_Model_Call {
	_c.Call.Return(run)
	return _c
}

// Offset provides a mock function with given fields: offset
func (_m *Query) Offset(offset int) orm.Query {
	ret := _m.Called(offset)

	if len(ret) == 0 {
		panic("no return value specified for Offset")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(int) orm.Query); ok {
		r0 = rf(offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Offset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Offset'
type Query_Offset_Call struct {
	*mock.Call
}

// Offset is a helper method to define mock.On call
//   - offset int
func (_e *Query_Expecter) Offset(offset interface{}) *Query_Offset_Call {
	return &Query_Offset_Call{Call: _e.mock.On("Offset", offset)}
}

func (_c *Query_Offset_Call) Run(run func(offset int)) *Query_Offset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Query_Offset_Call) Return(_a0 orm.Query) *Query_Offset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Offset_Call) RunAndReturn(run func(int) orm.Query) *Query_Offset_Call {
	_c.Call.Return(run)
	return _c
}

// Omit provides a mock function with given fields: columns
func (_m *Query) Omit(columns ...string) orm.Query {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Omit")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(...string) orm.Query); ok {
		r0 = rf(columns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Omit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Omit'
type Query_Omit_Call struct {
	*mock.Call
}

// Omit is a helper method to define mock.On call
//   - columns ...string
func (_e *Query_Expecter) Omit(columns ...interface{}) *Query_Omit_Call {
	return &Query_Omit_Call{Call: _e.mock.On("Omit",
		append([]interface{}{}, columns...)...)}
}

func (_c *Query_Omit_Call) Run(run func(columns ...string)) *Query_Omit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Query_Omit_Call) Return(_a0 orm.Query) *Query_Omit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Omit_Call) RunAndReturn(run func(...string) orm.Query) *Query_Omit_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhere provides a mock function with given fields: query, args
func (_m *Query) OrWhere(query interface{}, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for OrWhere")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrWhere_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhere'
type Query_OrWhere_Call struct {
	*mock.Call
}

// OrWhere is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *Query_Expecter) OrWhere(query interface{}, args ...interface{}) *Query_OrWhere_Call {
	return &Query_OrWhere_Call{Call: _e.mock.On("OrWhere",
		append([]interface{}{query}, args...)...)}
}

func (_c *Query_OrWhere_Call) Run(run func(query interface{}, args ...interface{})) *Query_OrWhere_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Query_OrWhere_Call) Return(_a0 orm.Query) *Query_OrWhere_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrWhere_Call) RunAndReturn(run func(interface{}, ...interface{}) orm.Query) *Query_OrWhere_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereBetween provides a mock function with given fields: column, x, y
func (_m *Query) OrWhereBetween(column string, x interface{}, y interface{}) orm.Query {
	ret := _m.Called(column, x, y)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereBetween")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) orm.Query); ok {
		r0 = rf(column, x, y)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrWhereBetween_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereBetween'
type Query_OrWhereBetween_Call struct {
	*mock.Call
}

// OrWhereBetween is a helper method to define mock.On call
//   - column string
//   - x interface{}
//   - y interface{}
func (_e *Query_Expecter) OrWhereBetween(column interface{}, x interface{}, y interface{}) *Query_OrWhereBetween_Call {
	return &Query_OrWhereBetween_Call{Call: _e.mock.On("OrWhereBetween", column, x, y)}
}

func (_c *Query_OrWhereBetween_Call) Run(run func(column string, x interface{}, y interface{})) *Query_OrWhereBetween_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(interface{}))
	})
	return _c
}

func (_c *Query_OrWhereBetween_Call) Return(_a0 orm.Query) *Query_OrWhereBetween_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrWhereBetween_Call) RunAndReturn(run func(string, interface{}, interface{}) orm.Query) *Query_OrWhereBetween_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereIn provides a mock function with given fields: column, values
func (_m *Query) OrWhereIn(column string, values []interface{}) orm.Query {
	ret := _m.Called(column, values)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereIn")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, []interface{}) orm.Query); ok {
		r0 = rf(column, values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrWhereIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereIn'
type Query_OrWhereIn_Call struct {
	*mock.Call
}

// OrWhereIn is a helper method to define mock.On call
//   - column string
//   - values []interface{}
func (_e *Query_Expecter) OrWhereIn(column interface{}, values interface{}) *Query_OrWhereIn_Call {
	return &Query_OrWhereIn_Call{Call: _e.mock.On("OrWhereIn", column, values)}
}

func (_c *Query_OrWhereIn_Call) Run(run func(column string, values []interface{})) *Query_OrWhereIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]interface{}))
	})
	return _c
}

func (_c *Query_OrWhereIn_Call) Return(_a0 orm.Query) *Query_OrWhereIn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrWhereIn_Call) RunAndReturn(run func(string, []interface{}) orm.Query) *Query_OrWhereIn_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereJsonContains provides a mock function with given fields: column, value
func (_m *Query) OrWhereJsonContains(column string, value interface{}) orm.Query {
	ret := _m.Called(column, value)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereJsonContains")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}) orm.Query); ok {
		r0 = rf(column, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrWhereJsonContains_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereJsonContains'
type Query_OrWhereJsonContains_Call struct {
	*mock.Call
}

// OrWhereJsonContains is a helper method to define mock.On call
//   - column string
//   - value interface{}
func (_e *Query_Expecter) OrWhereJsonContains(column interface{}, value interface{}) *Query_OrWhereJsonContains_Call {
	return &Query_OrWhereJsonContains_Call{Call: _e.mock.On("OrWhereJsonContains", column, value)}
}

func (_c *Query_OrWhereJsonContains_Call) Run(run func(column string, value interface{})) *Query_OrWhereJsonContains_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Query_OrWhereJsonContains_Call) Return(_a0 orm.Query) *Query_OrWhereJsonContains_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrWhereJsonContains_Call) RunAndReturn(run func(string, interface{}) orm.Query) *Query_OrWhereJsonContains_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereJsonContainsKey provides a mock function with given fields: column
func (_m *Query) OrWhereJsonContainsKey(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereJsonContainsKey")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrWhereJsonContainsKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereJsonContainsKey'
type Query_OrWhereJsonContainsKey_Call struct {
	*mock.Call
}

// OrWhereJsonContainsKey is a helper method to define mock.On call
//   - column string
func (_e *Query_Expecter) OrWhereJsonContainsKey(column interface{}) *Query_OrWhereJsonContainsKey_Call {
	return &Query_OrWhereJsonContainsKey_Call{Call: _e.mock.On("OrWhereJsonContainsKey", column)}
}

func (_c *Query_OrWhereJsonContainsKey_Call) Run(run func(column string)) *Query_OrWhereJsonContainsKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Query_OrWhereJsonContainsKey_Call) Return(_a0 orm.Query) *Query_OrWhereJsonContainsKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrWhereJsonContainsKey_Call) RunAndReturn(run func(string) orm.Query) *Query_OrWhereJsonContainsKey_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereJsonDoesntContain provides a mock function with given fields: column, value
func (_m *Query) OrWhereJsonDoesntContain(column string, value interface{}) orm.Query {
	ret := _m.Called(column, value)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereJsonDoesntContain")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}) orm.Query); ok {
		r0 = rf(column, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrWhereJsonDoesntContain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereJsonDoesntContain'
type Query_OrWhereJsonDoesntContain_Call struct {
	*mock.Call
}

// OrWhereJsonDoesntContain is a helper method to define mock.On call
//   - column string
//   - value interface{}
func (_e *Query_Expecter) OrWhereJsonDoesntContain(column interface{}, value interface{}) *Query_OrWhereJsonDoesntContain_Call {
	return &Query_OrWhereJsonDoesntContain_Call{Call: _e.mock.On("OrWhereJsonDoesntContain", column, value)}
}

func (_c *Query_OrWhereJsonDoesntContain_Call) Run(run func(column string, value interface{})) *Query_OrWhereJsonDoesntContain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Query_OrWhereJsonDoesntContain_Call) Return(_a0 orm.Query) *Query_OrWhereJsonDoesntContain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrWhereJsonDoesntContain_Call) RunAndReturn(run func(string, interface{}) orm.Query) *Query_OrWhereJsonDoesntContain_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereJsonDoesntContainKey provides a mock function with given fields: column
func (_m *Query) OrWhereJsonDoesntContainKey(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereJsonDoesntContainKey")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrWhereJsonDoesntContainKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereJsonDoesntContainKey'
type Query_OrWhereJsonDoesntContainKey_Call struct {
	*mock.Call
}

// OrWhereJsonDoesntContainKey is a helper method to define mock.On call
//   - column string
func (_e *Query_Expecter) OrWhereJsonDoesntContainKey(column interface{}) *Query_OrWhereJsonDoesntContainKey_Call {
	return &Query_OrWhereJsonDoesntContainKey_Call{Call: _e.mock.On("OrWhereJsonDoesntContainKey", column)}
}

func (_c *Query_OrWhereJsonDoesntContainKey_Call) Run(run func(column string)) *Query_OrWhereJsonDoesntContainKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Query_OrWhereJsonDoesntContainKey_Call) Return(_a0 orm.Query) *Query_OrWhereJsonDoesntContainKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrWhereJsonDoesntContainKey_Call) RunAndReturn(run func(string) orm.Query) *Query_OrWhereJsonDoesntContainKey_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereJsonLength provides a mock function with given fields: column, length
func (_m *Query) OrWhereJsonLength(column string, length int) orm.Query {
	ret := _m.Called(column, length)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereJsonLength")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, int) orm.Query); ok {
		r0 = rf(column, length)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrWhereJsonLength_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereJsonLength'
type Query_OrWhereJsonLength_Call struct {
	*mock.Call
}

// OrWhereJsonLength is a helper method to define mock.On call
//   - column string
//   - length int
func (_e *Query_Expecter) OrWhereJsonLength(column interface{}, length interface{}) *Query_OrWhereJsonLength_Call {
	return &Query_OrWhereJsonLength_Call{Call: _e.mock.On("OrWhereJsonLength", column, length)}
}

func (_c *Query_OrWhereJsonLength_Call) Run(run func(column string, length int)) *Query_OrWhereJsonLength_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int))
	})
	return _c
}

func (_c *Query_OrWhereJsonLength_Call) Return(_a0 orm.Query) *Query_OrWhereJsonLength_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrWhereJsonLength_Call) RunAndReturn(run func(string, int) orm.Query) *Query_OrWhereJsonLength_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereNotBetween provides a mock function with given fields: column, x, y
func (_m *Query) OrWhereNotBetween(column string, x interface{}, y interface{}) orm.Query {
	ret := _m.Called(column, x, y)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereNotBetween")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) orm.Query); ok {
		r0 = rf(column, x, y)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrWhereNotBetween_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereNotBetween'
type Query_OrWhereNotBetween_Call struct {
	*mock.Call
}

// OrWhereNotBetween is a helper method to define mock.On call
//   - column string
//   - x interface{}
//   - y interface{}
func (_e *Query_Expecter) OrWhereNotBetween(column interface{}, x interface{}, y interface{}) *Query_OrWhereNotBetween_Call {
	return &Query_OrWhereNotBetween_Call{Call: _e.mock.On("OrWhereNotBetween", column, x, y)}
}

func (_c *Query_OrWhereNotBetween_Call) Run(run func(column string, x interface{}, y interface{})) *Query_OrWhereNotBetween_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(interface{}))
	})
	return _c
}

func (_c *Query_OrWhereNotBetween_Call) Return(_a0 orm.Query) *Query_OrWhereNotBetween_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrWhereNotBetween_Call) RunAndReturn(run func(string, interface{}, interface{}) orm.Query) *Query_OrWhereNotBetween_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereNotIn provides a mock function with given fields: column, values
func (_m *Query) OrWhereNotIn(column string, values []interface{}) orm.Query {
	ret := _m.Called(column, values)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereNotIn")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, []interface{}) orm.Query); ok {
		r0 = rf(column, values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrWhereNotIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereNotIn'
type Query_OrWhereNotIn_Call struct {
	*mock.Call
}

// OrWhereNotIn is a helper method to define mock.On call
//   - column string
//   - values []interface{}
func (_e *Query_Expecter) OrWhereNotIn(column interface{}, values interface{}) *Query_OrWhereNotIn_Call {
	return &Query_OrWhereNotIn_Call{Call: _e.mock.On("OrWhereNotIn", column, values)}
}

func (_c *Query_OrWhereNotIn_Call) Run(run func(column string, values []interface{})) *Query_OrWhereNotIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]interface{}))
	})
	return _c
}

func (_c *Query_OrWhereNotIn_Call) Return(_a0 orm.Query) *Query_OrWhereNotIn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrWhereNotIn_Call) RunAndReturn(run func(string, []interface{}) orm.Query) *Query_OrWhereNotIn_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereNull provides a mock function with given fields: column
func (_m *Query) OrWhereNull(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereNull")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrWhereNull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereNull'
type Query_OrWhereNull_Call struct {
	*mock.Call
}

// OrWhereNull is a helper method to define mock.On call
//   - column string
func (_e *Query_Expecter) OrWhereNull(column interface{}) *Query_OrWhereNull_Call {
	return &Query_OrWhereNull_Call{Call: _e.mock.On("OrWhereNull", column)}
}

func (_c *Query_OrWhereNull_Call) Run(run func(column string)) *Query_OrWhereNull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Query_OrWhereNull_Call) Return(_a0 orm.Query) *Query_OrWhereNull_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrWhereNull_Call) RunAndReturn(run func(string) orm.Query) *Query_OrWhereNull_Call {
	_c.Call.Return(run)
	return _c
}

// Order provides a mock function with given fields: value
func (_m *Query) Order(value interface{}) orm.Query {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for Order")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}) orm.Query); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Order_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Order'
type Query_Order_Call struct {
	*mock.Call
}

// Order is a helper method to define mock.On call
//   - value interface{}
func (_e *Query_Expecter) Order(value interface{}) *Query_Order_Call {
	return &Query_Order_Call{Call: _e.mock.On("Order", value)}
}

func (_c *Query_Order_Call) Run(run func(value interface{})) *Query_Order_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Query_Order_Call) Return(_a0 orm.Query) *Query_Order_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Order_Call) RunAndReturn(run func(interface{}) orm.Query) *Query_Order_Call {
	_c.Call.Return(run)
	return _c
}

// OrderBy provides a mock function with given fields: column, direction
func (_m *Query) OrderBy(column string, direction ...string) orm.Query {
	_va := make([]interface{}, len(direction))
	for _i := range direction {
		_va[_i] = direction[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for OrderBy")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, ...string) orm.Query); ok {
		r0 = rf(column, direction...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrderBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrderBy'
type Query_OrderBy_Call struct {
	*mock.Call
}

// OrderBy is a helper method to define mock.On call
//   - column string
//   - direction ...string
func (_e *Query_Expecter) OrderBy(column interface{}, direction ...interface{}) *Query_OrderBy_Call {
	return &Query_OrderBy_Call{Call: _e.mock.On("OrderBy",
		append([]interface{}{column}, direction...)...)}
}

func (_c *Query_OrderBy_Call) Run(run func(column string, direction ...string)) *Query_OrderBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Query_OrderBy_Call) Return(_a0 orm.Query) *Query_OrderBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrderBy_Call) RunAndReturn(run func(string, ...string) orm.Query) *Query_OrderBy_Call {
	_c.Call.Return(run)
	return _c
}

// OrderByDesc provides a mock function with given fields: column
func (_m *Query) OrderByDesc(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for OrderByDesc")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrderByDesc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrderByDesc'
type Query_OrderByDesc_Call struct {
	*mock.Call
}

// OrderByDesc is a helper method to define mock.On call
//   - column string
func (_e *Query_Expecter) OrderByDesc(column interface{}) *Query_OrderByDesc_Call {
	return &Query_OrderByDesc_Call{Call: _e.mock.On("OrderByDesc", column)}
}

func (_c *Query_OrderByDesc_Call) Run(run func(column string)) *Query_OrderByDesc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Query_OrderByDesc_Call) Return(_a0 orm.Query) *Query_OrderByDesc_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrderByDesc_Call) RunAndReturn(run func(string) orm.Query) *Query_OrderByDesc_Call {
	_c.Call.Return(run)
	return _c
}

// OrderByRaw provides a mock function with given fields: raw
func (_m *Query) OrderByRaw(raw string) orm.Query {
	ret := _m.Called(raw)

	if len(ret) == 0 {
		panic("no return value specified for OrderByRaw")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(raw)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_OrderByRaw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrderByRaw'
type Query_OrderByRaw_Call struct {
	*mock.Call
}

// OrderByRaw is a helper method to define mock.On call
//   - raw string
func (_e *Query_Expecter) OrderByRaw(raw interface{}) *Query_OrderByRaw_Call {
	return &Query_OrderByRaw_Call{Call: _e.mock.On("OrderByRaw", raw)}
}

func (_c *Query_OrderByRaw_Call) Run(run func(raw string)) *Query_OrderByRaw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Query_OrderByRaw_Call) Return(_a0 orm.Query) *Query_OrderByRaw_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_OrderByRaw_Call) RunAndReturn(run func(string) orm.Query) *Query_OrderByRaw_Call {
	_c.Call.Return(run)
	return _c
}

// Paginate provides a mock function with given fields: page, limit, dest, total
func (_m *Query) Paginate(page int, limit int, dest interface{}, total *int64) error {
	ret := _m.Called(page, limit, dest, total)

	if len(ret) == 0 {
		panic("no return value specified for Paginate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, int, interface{}, *int64) error); ok {
		r0 = rf(page, limit, dest, total)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Paginate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Paginate'
type Query_Paginate_Call struct {
	*mock.Call
}

// Paginate is a helper method to define mock.On call
//   - page int
//   - limit int
//   - dest interface{}
//   - total *int64
func (_e *Query_Expecter) Paginate(page interface{}, limit interface{}, dest interface{}, total interface{}) *Query_Paginate_Call {
	return &Query_Paginate_Call{Call: _e.mock.On("Paginate", page, limit, dest, total)}
}

func (_c *Query_Paginate_Call) Run(run func(page int, limit int, dest interface{}, total *int64)) *Query_Paginate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int), args[2].(interface{}), args[3].(*int64))
	})
	return _c
}

func (_c *Query_Paginate_Call) Return(_a0 error) *Query_Paginate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Paginate_Call) RunAndReturn(run func(int, int, interface{}, *int64) error) *Query_Paginate_Call {
	_c.Call.Return(run)
	return _c
}

// Pluck provides a mock function with given fields: column, dest
func (_m *Query) Pluck(column string, dest interface{}) error {
	ret := _m.Called(column, dest)

	if len(ret) == 0 {
		panic("no return value specified for Pluck")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(column, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Pluck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pluck'
type Query_Pluck_Call struct {
	*mock.Call
}

// Pluck is a helper method to define mock.On call
//   - column string
//   - dest interface{}
func (_e *Query_Expecter) Pluck(column interface{}, dest interface{}) *Query_Pluck_Call {
	return &Query_Pluck_Call{Call: _e.mock.On("Pluck", column, dest)}
}

func (_c *Query_Pluck_Call) Run(run func(column string, dest interface{})) *Query_Pluck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Query_Pluck_Call) Return(_a0 error) *Query_Pluck_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Pluck_Call) RunAndReturn(run func(string, interface{}) error) *Query_Pluck_Call {
	_c.Call.Return(run)
	return _c
}

// Raw provides a mock function with given fields: _a0, values
func (_m *Query) Raw(_a0 string, values ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Raw")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, ...interface{}) orm.Query); ok {
		r0 = rf(_a0, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Raw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Raw'
type Query_Raw_Call struct {
	*mock.Call
}

// Raw is a helper method to define mock.On call
//   - _a0 string
//   - values ...interface{}
func (_e *Query_Expecter) Raw(_a0 interface{}, values ...interface{}) *Query_Raw_Call {
	return &Query_Raw_Call{Call: _e.mock.On("Raw",
		append([]interface{}{_a0}, values...)...)}
}

func (_c *Query_Raw_Call) Run(run func(_a0 string, values ...interface{})) *Query_Raw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Query_Raw_Call) Return(_a0 orm.Query) *Query_Raw_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Raw_Call) RunAndReturn(run func(string, ...interface{}) orm.Query) *Query_Raw_Call {
	_c.Call.Return(run)
	return _c
}

// Restore provides a mock function with given fields: model
func (_m *Query) Restore(model ...interface{}) (*db.Result, error) {
	var _ca []interface{}
	_ca = append(_ca, model...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Restore")
	}

	var r0 *db.Result
	var r1 error
	if rf, ok := ret.Get(0).(func(...interface{}) (*db.Result, error)); ok {
		return rf(model...)
	}
	if rf, ok := ret.Get(0).(func(...interface{}) *db.Result); ok {
		r0 = rf(model...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(...interface{}) error); ok {
		r1 = rf(model...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query_Restore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Restore'
type Query_Restore_Call struct {
	*mock.Call
}

// Restore is a helper method to define mock.On call
//   - model ...interface{}
func (_e *Query_Expecter) Restore(model ...interface{}) *Query_Restore_Call {
	return &Query_Restore_Call{Call: _e.mock.On("Restore",
		append([]interface{}{}, model...)...)}
}

func (_c *Query_Restore_Call) Run(run func(model ...interface{})) *Query_Restore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Query_Restore_Call) Return(_a0 *db.Result, _a1 error) *Query_Restore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Query_Restore_Call) RunAndReturn(run func(...interface{}) (*db.Result, error)) *Query_Restore_Call {
	_c.Call.Return(run)
	return _c
}

// Rollback provides a mock function with no fields
func (_m *Query) Rollback() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Rollback")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Rollback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rollback'
type Query_Rollback_Call struct {
	*mock.Call
}

// Rollback is a helper method to define mock.On call
func (_e *Query_Expecter) Rollback() *Query_Rollback_Call {
	return &Query_Rollback_Call{Call: _e.mock.On("Rollback")}
}

func (_c *Query_Rollback_Call) Run(run func()) *Query_Rollback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_Rollback_Call) Return(_a0 error) *Query_Rollback_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Rollback_Call) RunAndReturn(run func() error) *Query_Rollback_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: value
func (_m *Query) Save(value interface{}) error {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type Query_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - value interface{}
func (_e *Query_Expecter) Save(value interface{}) *Query_Save_Call {
	return &Query_Save_Call{Call: _e.mock.On("Save", value)}
}

func (_c *Query_Save_Call) Run(run func(value interface{})) *Query_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Query_Save_Call) Return(_a0 error) *Query_Save_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Save_Call) RunAndReturn(run func(interface{}) error) *Query_Save_Call {
	_c.Call.Return(run)
	return _c
}

// SaveQuietly provides a mock function with given fields: value
func (_m *Query) SaveQuietly(value interface{}) error {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for SaveQuietly")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_SaveQuietly_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveQuietly'
type Query_SaveQuietly_Call struct {
	*mock.Call
}

// SaveQuietly is a helper method to define mock.On call
//   - value interface{}
func (_e *Query_Expecter) SaveQuietly(value interface{}) *Query_SaveQuietly_Call {
	return &Query_SaveQuietly_Call{Call: _e.mock.On("SaveQuietly", value)}
}

func (_c *Query_SaveQuietly_Call) Run(run func(value interface{})) *Query_SaveQuietly_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Query_SaveQuietly_Call) Return(_a0 error) *Query_SaveQuietly_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_SaveQuietly_Call) RunAndReturn(run func(interface{}) error) *Query_SaveQuietly_Call {
	_c.Call.Return(run)
	return _c
}

// Scan provides a mock function with given fields: dest
func (_m *Query) Scan(dest interface{}) error {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for Scan")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Scan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scan'
type Query_Scan_Call struct {
	*mock.Call
}

// Scan is a helper method to define mock.On call
//   - dest interface{}
func (_e *Query_Expecter) Scan(dest interface{}) *Query_Scan_Call {
	return &Query_Scan_Call{Call: _e.mock.On("Scan", dest)}
}

func (_c *Query_Scan_Call) Run(run func(dest interface{})) *Query_Scan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Query_Scan_Call) Return(_a0 error) *Query_Scan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Scan_Call) RunAndReturn(run func(interface{}) error) *Query_Scan_Call {
	_c.Call.Return(run)
	return _c
}

// Scopes provides a mock function with given fields: funcs
func (_m *Query) Scopes(funcs ...func(orm.Query) orm.Query) orm.Query {
	_va := make([]interface{}, len(funcs))
	for _i := range funcs {
		_va[_i] = funcs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Scopes")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(...func(orm.Query) orm.Query) orm.Query); ok {
		r0 = rf(funcs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Scopes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scopes'
type Query_Scopes_Call struct {
	*mock.Call
}

// Scopes is a helper method to define mock.On call
//   - funcs ...func(orm.Query) orm.Query
func (_e *Query_Expecter) Scopes(funcs ...interface{}) *Query_Scopes_Call {
	return &Query_Scopes_Call{Call: _e.mock.On("Scopes",
		append([]interface{}{}, funcs...)...)}
}

func (_c *Query_Scopes_Call) Run(run func(funcs ...func(orm.Query) orm.Query)) *Query_Scopes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(orm.Query) orm.Query, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(func(orm.Query) orm.Query)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Query_Scopes_Call) Return(_a0 orm.Query) *Query_Scopes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Scopes_Call) RunAndReturn(run func(...func(orm.Query) orm.Query) orm.Query) *Query_Scopes_Call {
	_c.Call.Return(run)
	return _c
}

// Select provides a mock function with given fields: columns
func (_m *Query) Select(columns ...string) orm.Query {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Select")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(...string) orm.Query); ok {
		r0 = rf(columns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Select_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Select'
type Query_Select_Call struct {
	*mock.Call
}

// Select is a helper method to define mock.On call
//   - columns ...string
func (_e *Query_Expecter) Select(columns ...interface{}) *Query_Select_Call {
	return &Query_Select_Call{Call: _e.mock.On("Select",
		append([]interface{}{}, columns...)...)}
}

func (_c *Query_Select_Call) Run(run func(columns ...string)) *Query_Select_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Query_Select_Call) Return(_a0 orm.Query) *Query_Select_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Select_Call) RunAndReturn(run func(...string) orm.Query) *Query_Select_Call {
	_c.Call.Return(run)
	return _c
}

// SelectRaw provides a mock function with given fields: query, args
func (_m *Query) SelectRaw(query interface{}, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SelectRaw")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_SelectRaw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectRaw'
type Query_SelectRaw_Call struct {
	*mock.Call
}

// SelectRaw is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *Query_Expecter) SelectRaw(query interface{}, args ...interface{}) *Query_SelectRaw_Call {
	return &Query_SelectRaw_Call{Call: _e.mock.On("SelectRaw",
		append([]interface{}{query}, args...)...)}
}

func (_c *Query_SelectRaw_Call) Run(run func(query interface{}, args ...interface{})) *Query_SelectRaw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Query_SelectRaw_Call) Return(_a0 orm.Query) *Query_SelectRaw_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_SelectRaw_Call) RunAndReturn(run func(interface{}, ...interface{}) orm.Query) *Query_SelectRaw_Call {
	_c.Call.Return(run)
	return _c
}

// SharedLock provides a mock function with no fields
func (_m *Query) SharedLock() orm.Query {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SharedLock")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_SharedLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SharedLock'
type Query_SharedLock_Call struct {
	*mock.Call
}

// SharedLock is a helper method to define mock.On call
func (_e *Query_Expecter) SharedLock() *Query_SharedLock_Call {
	return &Query_SharedLock_Call{Call: _e.mock.On("SharedLock")}
}

func (_c *Query_SharedLock_Call) Run(run func()) *Query_SharedLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_SharedLock_Call) Return(_a0 orm.Query) *Query_SharedLock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_SharedLock_Call) RunAndReturn(run func() orm.Query) *Query_SharedLock_Call {
	_c.Call.Return(run)
	return _c
}

// Sum provides a mock function with given fields: column, dest
func (_m *Query) Sum(column string, dest interface{}) error {
	ret := _m.Called(column, dest)

	if len(ret) == 0 {
		panic("no return value specified for Sum")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(column, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_Sum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sum'
type Query_Sum_Call struct {
	*mock.Call
}

// Sum is a helper method to define mock.On call
//   - column string
//   - dest interface{}
func (_e *Query_Expecter) Sum(column interface{}, dest interface{}) *Query_Sum_Call {
	return &Query_Sum_Call{Call: _e.mock.On("Sum", column, dest)}
}

func (_c *Query_Sum_Call) Run(run func(column string, dest interface{})) *Query_Sum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Query_Sum_Call) Return(_a0 error) *Query_Sum_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Sum_Call) RunAndReturn(run func(string, interface{}) error) *Query_Sum_Call {
	_c.Call.Return(run)
	return _c
}

// Table provides a mock function with given fields: name, args
func (_m *Query) Table(name string, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Table")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, ...interface{}) orm.Query); ok {
		r0 = rf(name, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Table_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Table'
type Query_Table_Call struct {
	*mock.Call
}

// Table is a helper method to define mock.On call
//   - name string
//   - args ...interface{}
func (_e *Query_Expecter) Table(name interface{}, args ...interface{}) *Query_Table_Call {
	return &Query_Table_Call{Call: _e.mock.On("Table",
		append([]interface{}{name}, args...)...)}
}

func (_c *Query_Table_Call) Run(run func(name string, args ...interface{})) *Query_Table_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Query_Table_Call) Return(_a0 orm.Query) *Query_Table_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Table_Call) RunAndReturn(run func(string, ...interface{}) orm.Query) *Query_Table_Call {
	_c.Call.Return(run)
	return _c
}

// ToRawSql provides a mock function with no fields
func (_m *Query) ToRawSql() orm.ToSql {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ToRawSql")
	}

	var r0 orm.ToSql
	if rf, ok := ret.Get(0).(func() orm.ToSql); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.ToSql)
		}
	}

	return r0
}

// Query_ToRawSql_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ToRawSql'
type Query_ToRawSql_Call struct {
	*mock.Call
}

// ToRawSql is a helper method to define mock.On call
func (_e *Query_Expecter) ToRawSql() *Query_ToRawSql_Call {
	return &Query_ToRawSql_Call{Call: _e.mock.On("ToRawSql")}
}

func (_c *Query_ToRawSql_Call) Run(run func()) *Query_ToRawSql_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_ToRawSql_Call) Return(_a0 orm.ToSql) *Query_ToRawSql_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_ToRawSql_Call) RunAndReturn(run func() orm.ToSql) *Query_ToRawSql_Call {
	_c.Call.Return(run)
	return _c
}

// ToSql provides a mock function with no fields
func (_m *Query) ToSql() orm.ToSql {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ToSql")
	}

	var r0 orm.ToSql
	if rf, ok := ret.Get(0).(func() orm.ToSql); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.ToSql)
		}
	}

	return r0
}

// Query_ToSql_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ToSql'
type Query_ToSql_Call struct {
	*mock.Call
}

// ToSql is a helper method to define mock.On call
func (_e *Query_Expecter) ToSql() *Query_ToSql_Call {
	return &Query_ToSql_Call{Call: _e.mock.On("ToSql")}
}

func (_c *Query_ToSql_Call) Run(run func()) *Query_ToSql_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_ToSql_Call) Return(_a0 orm.ToSql) *Query_ToSql_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_ToSql_Call) RunAndReturn(run func() orm.ToSql) *Query_ToSql_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: column, value
func (_m *Query) Update(column interface{}, value ...interface{}) (*db.Result, error) {
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, value...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *db.Result
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) (*db.Result, error)); ok {
		return rf(column, value...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *db.Result); ok {
		r0 = rf(column, value...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...interface{}) error); ok {
		r1 = rf(column, value...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Query_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type Query_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - column interface{}
//   - value ...interface{}
func (_e *Query_Expecter) Update(column interface{}, value ...interface{}) *Query_Update_Call {
	return &Query_Update_Call{Call: _e.mock.On("Update",
		append([]interface{}{column}, value...)...)}
}

func (_c *Query_Update_Call) Run(run func(column interface{}, value ...interface{})) *Query_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Query_Update_Call) Return(_a0 *db.Result, _a1 error) *Query_Update_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Query_Update_Call) RunAndReturn(run func(interface{}, ...interface{}) (*db.Result, error)) *Query_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateOrCreate provides a mock function with given fields: dest, attributes, values
func (_m *Query) UpdateOrCreate(dest interface{}, attributes interface{}, values interface{}) error {
	ret := _m.Called(dest, attributes, values)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOrCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}) error); ok {
		r0 = rf(dest, attributes, values)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query_UpdateOrCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateOrCreate'
type Query_UpdateOrCreate_Call struct {
	*mock.Call
}

// UpdateOrCreate is a helper method to define mock.On call
//   - dest interface{}
//   - attributes interface{}
//   - values interface{}
func (_e *Query_Expecter) UpdateOrCreate(dest interface{}, attributes interface{}, values interface{}) *Query_UpdateOrCreate_Call {
	return &Query_UpdateOrCreate_Call{Call: _e.mock.On("UpdateOrCreate", dest, attributes, values)}
}

func (_c *Query_UpdateOrCreate_Call) Run(run func(dest interface{}, attributes interface{}, values interface{})) *Query_UpdateOrCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(interface{}), args[2].(interface{}))
	})
	return _c
}

func (_c *Query_UpdateOrCreate_Call) Return(_a0 error) *Query_UpdateOrCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_UpdateOrCreate_Call) RunAndReturn(run func(interface{}, interface{}, interface{}) error) *Query_UpdateOrCreate_Call {
	_c.Call.Return(run)
	return _c
}

// Where provides a mock function with given fields: query, args
func (_m *Query) Where(query interface{}, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Where")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_Where_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Where'
type Query_Where_Call struct {
	*mock.Call
}

// Where is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *Query_Expecter) Where(query interface{}, args ...interface{}) *Query_Where_Call {
	return &Query_Where_Call{Call: _e.mock.On("Where",
		append([]interface{}{query}, args...)...)}
}

func (_c *Query_Where_Call) Run(run func(query interface{}, args ...interface{})) *Query_Where_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Query_Where_Call) Return(_a0 orm.Query) *Query_Where_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_Where_Call) RunAndReturn(run func(interface{}, ...interface{}) orm.Query) *Query_Where_Call {
	_c.Call.Return(run)
	return _c
}

// WhereBetween provides a mock function with given fields: column, x, y
func (_m *Query) WhereBetween(column string, x interface{}, y interface{}) orm.Query {
	ret := _m.Called(column, x, y)

	if len(ret) == 0 {
		panic("no return value specified for WhereBetween")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) orm.Query); ok {
		r0 = rf(column, x, y)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WhereBetween_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereBetween'
type Query_WhereBetween_Call struct {
	*mock.Call
}

// WhereBetween is a helper method to define mock.On call
//   - column string
//   - x interface{}
//   - y interface{}
func (_e *Query_Expecter) WhereBetween(column interface{}, x interface{}, y interface{}) *Query_WhereBetween_Call {
	return &Query_WhereBetween_Call{Call: _e.mock.On("WhereBetween", column, x, y)}
}

func (_c *Query_WhereBetween_Call) Run(run func(column string, x interface{}, y interface{})) *Query_WhereBetween_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(interface{}))
	})
	return _c
}

func (_c *Query_WhereBetween_Call) Return(_a0 orm.Query) *Query_WhereBetween_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WhereBetween_Call) RunAndReturn(run func(string, interface{}, interface{}) orm.Query) *Query_WhereBetween_Call {
	_c.Call.Return(run)
	return _c
}

// WhereIn provides a mock function with given fields: column, values
func (_m *Query) WhereIn(column string, values []interface{}) orm.Query {
	ret := _m.Called(column, values)

	if len(ret) == 0 {
		panic("no return value specified for WhereIn")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, []interface{}) orm.Query); ok {
		r0 = rf(column, values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WhereIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereIn'
type Query_WhereIn_Call struct {
	*mock.Call
}

// WhereIn is a helper method to define mock.On call
//   - column string
//   - values []interface{}
func (_e *Query_Expecter) WhereIn(column interface{}, values interface{}) *Query_WhereIn_Call {
	return &Query_WhereIn_Call{Call: _e.mock.On("WhereIn", column, values)}
}

func (_c *Query_WhereIn_Call) Run(run func(column string, values []interface{})) *Query_WhereIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]interface{}))
	})
	return _c
}

func (_c *Query_WhereIn_Call) Return(_a0 orm.Query) *Query_WhereIn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WhereIn_Call) RunAndReturn(run func(string, []interface{}) orm.Query) *Query_WhereIn_Call {
	_c.Call.Return(run)
	return _c
}

// WhereJsonContains provides a mock function with given fields: column, value
func (_m *Query) WhereJsonContains(column string, value interface{}) orm.Query {
	ret := _m.Called(column, value)

	if len(ret) == 0 {
		panic("no return value specified for WhereJsonContains")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}) orm.Query); ok {
		r0 = rf(column, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WhereJsonContains_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereJsonContains'
type Query_WhereJsonContains_Call struct {
	*mock.Call
}

// WhereJsonContains is a helper method to define mock.On call
//   - column string
//   - value interface{}
func (_e *Query_Expecter) WhereJsonContains(column interface{}, value interface{}) *Query_WhereJsonContains_Call {
	return &Query_WhereJsonContains_Call{Call: _e.mock.On("WhereJsonContains", column, value)}
}

func (_c *Query_WhereJsonContains_Call) Run(run func(column string, value interface{})) *Query_WhereJsonContains_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Query_WhereJsonContains_Call) Return(_a0 orm.Query) *Query_WhereJsonContains_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WhereJsonContains_Call) RunAndReturn(run func(string, interface{}) orm.Query) *Query_WhereJsonContains_Call {
	_c.Call.Return(run)
	return _c
}

// WhereJsonContainsKey provides a mock function with given fields: column
func (_m *Query) WhereJsonContainsKey(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for WhereJsonContainsKey")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WhereJsonContainsKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereJsonContainsKey'
type Query_WhereJsonContainsKey_Call struct {
	*mock.Call
}

// WhereJsonContainsKey is a helper method to define mock.On call
//   - column string
func (_e *Query_Expecter) WhereJsonContainsKey(column interface{}) *Query_WhereJsonContainsKey_Call {
	return &Query_WhereJsonContainsKey_Call{Call: _e.mock.On("WhereJsonContainsKey", column)}
}

func (_c *Query_WhereJsonContainsKey_Call) Run(run func(column string)) *Query_WhereJsonContainsKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Query_WhereJsonContainsKey_Call) Return(_a0 orm.Query) *Query_WhereJsonContainsKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WhereJsonContainsKey_Call) RunAndReturn(run func(string) orm.Query) *Query_WhereJsonContainsKey_Call {
	_c.Call.Return(run)
	return _c
}

// WhereJsonDoesntContain provides a mock function with given fields: column, value
func (_m *Query) WhereJsonDoesntContain(column string, value interface{}) orm.Query {
	ret := _m.Called(column, value)

	if len(ret) == 0 {
		panic("no return value specified for WhereJsonDoesntContain")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}) orm.Query); ok {
		r0 = rf(column, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WhereJsonDoesntContain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereJsonDoesntContain'
type Query_WhereJsonDoesntContain_Call struct {
	*mock.Call
}

// WhereJsonDoesntContain is a helper method to define mock.On call
//   - column string
//   - value interface{}
func (_e *Query_Expecter) WhereJsonDoesntContain(column interface{}, value interface{}) *Query_WhereJsonDoesntContain_Call {
	return &Query_WhereJsonDoesntContain_Call{Call: _e.mock.On("WhereJsonDoesntContain", column, value)}
}

func (_c *Query_WhereJsonDoesntContain_Call) Run(run func(column string, value interface{})) *Query_WhereJsonDoesntContain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Query_WhereJsonDoesntContain_Call) Return(_a0 orm.Query) *Query_WhereJsonDoesntContain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WhereJsonDoesntContain_Call) RunAndReturn(run func(string, interface{}) orm.Query) *Query_WhereJsonDoesntContain_Call {
	_c.Call.Return(run)
	return _c
}

// WhereJsonDoesntContainKey provides a mock function with given fields: column
func (_m *Query) WhereJsonDoesntContainKey(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for WhereJsonDoesntContainKey")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WhereJsonDoesntContainKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereJsonDoesntContainKey'
type Query_WhereJsonDoesntContainKey_Call struct {
	*mock.Call
}

// WhereJsonDoesntContainKey is a helper method to define mock.On call
//   - column string
func (_e *Query_Expecter) WhereJsonDoesntContainKey(column interface{}) *Query_WhereJsonDoesntContainKey_Call {
	return &Query_WhereJsonDoesntContainKey_Call{Call: _e.mock.On("WhereJsonDoesntContainKey", column)}
}

func (_c *Query_WhereJsonDoesntContainKey_Call) Run(run func(column string)) *Query_WhereJsonDoesntContainKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Query_WhereJsonDoesntContainKey_Call) Return(_a0 orm.Query) *Query_WhereJsonDoesntContainKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WhereJsonDoesntContainKey_Call) RunAndReturn(run func(string) orm.Query) *Query_WhereJsonDoesntContainKey_Call {
	_c.Call.Return(run)
	return _c
}

// WhereJsonLength provides a mock function with given fields: column, length
func (_m *Query) WhereJsonLength(column string, length int) orm.Query {
	ret := _m.Called(column, length)

	if len(ret) == 0 {
		panic("no return value specified for WhereJsonLength")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, int) orm.Query); ok {
		r0 = rf(column, length)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WhereJsonLength_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereJsonLength'
type Query_WhereJsonLength_Call struct {
	*mock.Call
}

// WhereJsonLength is a helper method to define mock.On call
//   - column string
//   - length int
func (_e *Query_Expecter) WhereJsonLength(column interface{}, length interface{}) *Query_WhereJsonLength_Call {
	return &Query_WhereJsonLength_Call{Call: _e.mock.On("WhereJsonLength", column, length)}
}

func (_c *Query_WhereJsonLength_Call) Run(run func(column string, length int)) *Query_WhereJsonLength_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int))
	})
	return _c
}

func (_c *Query_WhereJsonLength_Call) Return(_a0 orm.Query) *Query_WhereJsonLength_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WhereJsonLength_Call) RunAndReturn(run func(string, int) orm.Query) *Query_WhereJsonLength_Call {
	_c.Call.Return(run)
	return _c
}

// WhereNotBetween provides a mock function with given fields: column, x, y
func (_m *Query) WhereNotBetween(column string, x interface{}, y interface{}) orm.Query {
	ret := _m.Called(column, x, y)

	if len(ret) == 0 {
		panic("no return value specified for WhereNotBetween")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) orm.Query); ok {
		r0 = rf(column, x, y)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WhereNotBetween_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereNotBetween'
type Query_WhereNotBetween_Call struct {
	*mock.Call
}

// WhereNotBetween is a helper method to define mock.On call
//   - column string
//   - x interface{}
//   - y interface{}
func (_e *Query_Expecter) WhereNotBetween(column interface{}, x interface{}, y interface{}) *Query_WhereNotBetween_Call {
	return &Query_WhereNotBetween_Call{Call: _e.mock.On("WhereNotBetween", column, x, y)}
}

func (_c *Query_WhereNotBetween_Call) Run(run func(column string, x interface{}, y interface{})) *Query_WhereNotBetween_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(interface{}))
	})
	return _c
}

func (_c *Query_WhereNotBetween_Call) Return(_a0 orm.Query) *Query_WhereNotBetween_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WhereNotBetween_Call) RunAndReturn(run func(string, interface{}, interface{}) orm.Query) *Query_WhereNotBetween_Call {
	_c.Call.Return(run)
	return _c
}

// WhereNotIn provides a mock function with given fields: column, values
func (_m *Query) WhereNotIn(column string, values []interface{}) orm.Query {
	ret := _m.Called(column, values)

	if len(ret) == 0 {
		panic("no return value specified for WhereNotIn")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, []interface{}) orm.Query); ok {
		r0 = rf(column, values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WhereNotIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereNotIn'
type Query_WhereNotIn_Call struct {
	*mock.Call
}

// WhereNotIn is a helper method to define mock.On call
//   - column string
//   - values []interface{}
func (_e *Query_Expecter) WhereNotIn(column interface{}, values interface{}) *Query_WhereNotIn_Call {
	return &Query_WhereNotIn_Call{Call: _e.mock.On("WhereNotIn", column, values)}
}

func (_c *Query_WhereNotIn_Call) Run(run func(column string, values []interface{})) *Query_WhereNotIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]interface{}))
	})
	return _c
}

func (_c *Query_WhereNotIn_Call) Return(_a0 orm.Query) *Query_WhereNotIn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WhereNotIn_Call) RunAndReturn(run func(string, []interface{}) orm.Query) *Query_WhereNotIn_Call {
	_c.Call.Return(run)
	return _c
}

// WhereNotNull provides a mock function with given fields: column
func (_m *Query) WhereNotNull(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for WhereNotNull")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WhereNotNull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereNotNull'
type Query_WhereNotNull_Call struct {
	*mock.Call
}

// WhereNotNull is a helper method to define mock.On call
//   - column string
func (_e *Query_Expecter) WhereNotNull(column interface{}) *Query_WhereNotNull_Call {
	return &Query_WhereNotNull_Call{Call: _e.mock.On("WhereNotNull", column)}
}

func (_c *Query_WhereNotNull_Call) Run(run func(column string)) *Query_WhereNotNull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Query_WhereNotNull_Call) Return(_a0 orm.Query) *Query_WhereNotNull_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WhereNotNull_Call) RunAndReturn(run func(string) orm.Query) *Query_WhereNotNull_Call {
	_c.Call.Return(run)
	return _c
}

// WhereNull provides a mock function with given fields: column
func (_m *Query) WhereNull(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for WhereNull")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WhereNull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereNull'
type Query_WhereNull_Call struct {
	*mock.Call
}

// WhereNull is a helper method to define mock.On call
//   - column string
func (_e *Query_Expecter) WhereNull(column interface{}) *Query_WhereNull_Call {
	return &Query_WhereNull_Call{Call: _e.mock.On("WhereNull", column)}
}

func (_c *Query_WhereNull_Call) Run(run func(column string)) *Query_WhereNull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Query_WhereNull_Call) Return(_a0 orm.Query) *Query_WhereNull_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WhereNull_Call) RunAndReturn(run func(string) orm.Query) *Query_WhereNull_Call {
	_c.Call.Return(run)
	return _c
}

// With provides a mock function with given fields: query, args
func (_m *Query) With(query string, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for With")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_With_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'With'
type Query_With_Call struct {
	*mock.Call
}

// With is a helper method to define mock.On call
//   - query string
//   - args ...interface{}
func (_e *Query_Expecter) With(query interface{}, args ...interface{}) *Query_With_Call {
	return &Query_With_Call{Call: _e.mock.On("With",
		append([]interface{}{query}, args...)...)}
}

func (_c *Query_With_Call) Run(run func(query string, args ...interface{})) *Query_With_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Query_With_Call) Return(_a0 orm.Query) *Query_With_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_With_Call) RunAndReturn(run func(string, ...interface{}) orm.Query) *Query_With_Call {
	_c.Call.Return(run)
	return _c
}

// WithTrashed provides a mock function with no fields
func (_m *Query) WithTrashed() orm.Query {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for WithTrashed")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WithTrashed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTrashed'
type Query_WithTrashed_Call struct {
	*mock.Call
}

// WithTrashed is a helper method to define mock.On call
func (_e *Query_Expecter) WithTrashed() *Query_WithTrashed_Call {
	return &Query_WithTrashed_Call{Call: _e.mock.On("WithTrashed")}
}

func (_c *Query_WithTrashed_Call) Run(run func()) *Query_WithTrashed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_WithTrashed_Call) Return(_a0 orm.Query) *Query_WithTrashed_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WithTrashed_Call) RunAndReturn(run func() orm.Query) *Query_WithTrashed_Call {
	_c.Call.Return(run)
	return _c
}

// WithoutEvents provides a mock function with no fields
func (_m *Query) WithoutEvents() orm.Query {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for WithoutEvents")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Query_WithoutEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithoutEvents'
type Query_WithoutEvents_Call struct {
	*mock.Call
}

// WithoutEvents is a helper method to define mock.On call
func (_e *Query_Expecter) WithoutEvents() *Query_WithoutEvents_Call {
	return &Query_WithoutEvents_Call{Call: _e.mock.On("WithoutEvents")}
}

func (_c *Query_WithoutEvents_Call) Run(run func()) *Query_WithoutEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Query_WithoutEvents_Call) Return(_a0 orm.Query) *Query_WithoutEvents_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Query_WithoutEvents_Call) RunAndReturn(run func() orm.Query) *Query_WithoutEvents_Call {
	_c.Call.Return(run)
	return _c
}

// NewQuery creates a new instance of Query. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewQuery(t interface {
	mock.TestingT
	Cleanup(func())
}) *Query {
	mock := &Query{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
