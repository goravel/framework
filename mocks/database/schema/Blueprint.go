// Code generated by mockery. DO NOT EDIT.

package schema

import (
	driver "github.com/goravel/framework/contracts/database/driver"
	mock "github.com/stretchr/testify/mock"

	orm "github.com/goravel/framework/contracts/database/orm"

	schema "github.com/goravel/framework/contracts/database/schema"
)

// Blueprint is an autogenerated mock type for the Blueprint type
type Blueprint struct {
	mock.Mock
}

type Blueprint_Expecter struct {
	mock *mock.Mock
}

func (_m *Blueprint) EXPECT() *Blueprint_Expecter {
	return &Blueprint_Expecter{mock: &_m.Mock}
}

// BigIncrements provides a mock function with given fields: column
func (_m *Blueprint) BigIncrements(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for BigIncrements")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_BigIncrements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BigIncrements'
type Blueprint_BigIncrements_Call struct {
	*mock.Call
}

// BigIncrements is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) BigIncrements(column interface{}) *Blueprint_BigIncrements_Call {
	return &Blueprint_BigIncrements_Call{Call: _e.mock.On("BigIncrements", column)}
}

func (_c *Blueprint_BigIncrements_Call) Run(run func(column string)) *Blueprint_BigIncrements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_BigIncrements_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_BigIncrements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_BigIncrements_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_BigIncrements_Call {
	_c.Call.Return(run)
	return _c
}

// BigInteger provides a mock function with given fields: column
func (_m *Blueprint) BigInteger(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for BigInteger")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_BigInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BigInteger'
type Blueprint_BigInteger_Call struct {
	*mock.Call
}

// BigInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) BigInteger(column interface{}) *Blueprint_BigInteger_Call {
	return &Blueprint_BigInteger_Call{Call: _e.mock.On("BigInteger", column)}
}

func (_c *Blueprint_BigInteger_Call) Run(run func(column string)) *Blueprint_BigInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_BigInteger_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_BigInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_BigInteger_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_BigInteger_Call {
	_c.Call.Return(run)
	return _c
}

// Boolean provides a mock function with given fields: column
func (_m *Blueprint) Boolean(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Boolean")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Boolean_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Boolean'
type Blueprint_Boolean_Call struct {
	*mock.Call
}

// Boolean is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Boolean(column interface{}) *Blueprint_Boolean_Call {
	return &Blueprint_Boolean_Call{Call: _e.mock.On("Boolean", column)}
}

func (_c *Blueprint_Boolean_Call) Run(run func(column string)) *Blueprint_Boolean_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Boolean_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Boolean_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Boolean_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_Boolean_Call {
	_c.Call.Return(run)
	return _c
}

// Build provides a mock function with given fields: query, grammar
func (_m *Blueprint) Build(query orm.Query, grammar driver.Grammar) error {
	ret := _m.Called(query, grammar)

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(orm.Query, driver.Grammar) error); ok {
		r0 = rf(query, grammar)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Blueprint_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type Blueprint_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
//   - query orm.Query
//   - grammar driver.Grammar
func (_e *Blueprint_Expecter) Build(query interface{}, grammar interface{}) *Blueprint_Build_Call {
	return &Blueprint_Build_Call{Call: _e.mock.On("Build", query, grammar)}
}

func (_c *Blueprint_Build_Call) Run(run func(query orm.Query, grammar driver.Grammar)) *Blueprint_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(orm.Query), args[1].(driver.Grammar))
	})
	return _c
}

func (_c *Blueprint_Build_Call) Return(_a0 error) *Blueprint_Build_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Build_Call) RunAndReturn(run func(orm.Query, driver.Grammar) error) *Blueprint_Build_Call {
	_c.Call.Return(run)
	return _c
}

// Char provides a mock function with given fields: column, length
func (_m *Blueprint) Char(column string, length ...int) driver.ColumnDefinition {
	_va := make([]interface{}, len(length))
	for _i := range length {
		_va[_i] = length[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Char")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) driver.ColumnDefinition); ok {
		r0 = rf(column, length...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Char_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Char'
type Blueprint_Char_Call struct {
	*mock.Call
}

// Char is a helper method to define mock.On call
//   - column string
//   - length ...int
func (_e *Blueprint_Expecter) Char(column interface{}, length ...interface{}) *Blueprint_Char_Call {
	return &Blueprint_Char_Call{Call: _e.mock.On("Char",
		append([]interface{}{column}, length...)...)}
}

func (_c *Blueprint_Char_Call) Run(run func(column string, length ...int)) *Blueprint_Char_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Char_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Char_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Char_Call) RunAndReturn(run func(string, ...int) driver.ColumnDefinition) *Blueprint_Char_Call {
	_c.Call.Return(run)
	return _c
}

// Column provides a mock function with given fields: column, ttype
func (_m *Blueprint) Column(column string, ttype string) driver.ColumnDefinition {
	ret := _m.Called(column, ttype)

	if len(ret) == 0 {
		panic("no return value specified for Column")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, string) driver.ColumnDefinition); ok {
		r0 = rf(column, ttype)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Column_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Column'
type Blueprint_Column_Call struct {
	*mock.Call
}

// Column is a helper method to define mock.On call
//   - column string
//   - ttype string
func (_e *Blueprint_Expecter) Column(column interface{}, ttype interface{}) *Blueprint_Column_Call {
	return &Blueprint_Column_Call{Call: _e.mock.On("Column", column, ttype)}
}

func (_c *Blueprint_Column_Call) Run(run func(column string, ttype string)) *Blueprint_Column_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Blueprint_Column_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Column_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Column_Call) RunAndReturn(run func(string, string) driver.ColumnDefinition) *Blueprint_Column_Call {
	_c.Call.Return(run)
	return _c
}

// Comment provides a mock function with given fields: value
func (_m *Blueprint) Comment(value string) {
	_m.Called(value)
}

// Blueprint_Comment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Comment'
type Blueprint_Comment_Call struct {
	*mock.Call
}

// Comment is a helper method to define mock.On call
//   - value string
func (_e *Blueprint_Expecter) Comment(value interface{}) *Blueprint_Comment_Call {
	return &Blueprint_Comment_Call{Call: _e.mock.On("Comment", value)}
}

func (_c *Blueprint_Comment_Call) Run(run func(value string)) *Blueprint_Comment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Comment_Call) Return() *Blueprint_Comment_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Comment_Call) RunAndReturn(run func(string)) *Blueprint_Comment_Call {
	_c.Run(run)
	return _c
}

// Create provides a mock function with no fields
func (_m *Blueprint) Create() {
	_m.Called()
}

// Blueprint_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type Blueprint_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
func (_e *Blueprint_Expecter) Create() *Blueprint_Create_Call {
	return &Blueprint_Create_Call{Call: _e.mock.On("Create")}
}

func (_c *Blueprint_Create_Call) Run(run func()) *Blueprint_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_Create_Call) Return() *Blueprint_Create_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Create_Call) RunAndReturn(run func()) *Blueprint_Create_Call {
	_c.Run(run)
	return _c
}

// Date provides a mock function with given fields: column
func (_m *Blueprint) Date(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Date")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Date_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Date'
type Blueprint_Date_Call struct {
	*mock.Call
}

// Date is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Date(column interface{}) *Blueprint_Date_Call {
	return &Blueprint_Date_Call{Call: _e.mock.On("Date", column)}
}

func (_c *Blueprint_Date_Call) Run(run func(column string)) *Blueprint_Date_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Date_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Date_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Date_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_Date_Call {
	_c.Call.Return(run)
	return _c
}

// DateTime provides a mock function with given fields: column, precision
func (_m *Blueprint) DateTime(column string, precision ...int) driver.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DateTime")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) driver.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_DateTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DateTime'
type Blueprint_DateTime_Call struct {
	*mock.Call
}

// DateTime is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) DateTime(column interface{}, precision ...interface{}) *Blueprint_DateTime_Call {
	return &Blueprint_DateTime_Call{Call: _e.mock.On("DateTime",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_DateTime_Call) Run(run func(column string, precision ...int)) *Blueprint_DateTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DateTime_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_DateTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_DateTime_Call) RunAndReturn(run func(string, ...int) driver.ColumnDefinition) *Blueprint_DateTime_Call {
	_c.Call.Return(run)
	return _c
}

// DateTimeTz provides a mock function with given fields: column, precision
func (_m *Blueprint) DateTimeTz(column string, precision ...int) driver.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DateTimeTz")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) driver.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_DateTimeTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DateTimeTz'
type Blueprint_DateTimeTz_Call struct {
	*mock.Call
}

// DateTimeTz is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) DateTimeTz(column interface{}, precision ...interface{}) *Blueprint_DateTimeTz_Call {
	return &Blueprint_DateTimeTz_Call{Call: _e.mock.On("DateTimeTz",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_DateTimeTz_Call) Run(run func(column string, precision ...int)) *Blueprint_DateTimeTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DateTimeTz_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_DateTimeTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_DateTimeTz_Call) RunAndReturn(run func(string, ...int) driver.ColumnDefinition) *Blueprint_DateTimeTz_Call {
	_c.Call.Return(run)
	return _c
}

// DateTimes provides a mock function with given fields: precision
func (_m *Blueprint) DateTimes(precision ...int) {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DateTimes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DateTimes'
type Blueprint_DateTimes_Call struct {
	*mock.Call
}

// DateTimes is a helper method to define mock.On call
//   - precision ...int
func (_e *Blueprint_Expecter) DateTimes(precision ...interface{}) *Blueprint_DateTimes_Call {
	return &Blueprint_DateTimes_Call{Call: _e.mock.On("DateTimes",
		append([]interface{}{}, precision...)...)}
}

func (_c *Blueprint_DateTimes_Call) Run(run func(precision ...int)) *Blueprint_DateTimes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DateTimes_Call) Return() *Blueprint_DateTimes_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DateTimes_Call) RunAndReturn(run func(...int)) *Blueprint_DateTimes_Call {
	_c.Run(run)
	return _c
}

// Decimal provides a mock function with given fields: column
func (_m *Blueprint) Decimal(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Decimal")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Decimal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decimal'
type Blueprint_Decimal_Call struct {
	*mock.Call
}

// Decimal is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Decimal(column interface{}) *Blueprint_Decimal_Call {
	return &Blueprint_Decimal_Call{Call: _e.mock.On("Decimal", column)}
}

func (_c *Blueprint_Decimal_Call) Run(run func(column string)) *Blueprint_Decimal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Decimal_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Decimal_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Decimal_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_Decimal_Call {
	_c.Call.Return(run)
	return _c
}

// Double provides a mock function with given fields: column
func (_m *Blueprint) Double(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Double")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Double_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Double'
type Blueprint_Double_Call struct {
	*mock.Call
}

// Double is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Double(column interface{}) *Blueprint_Double_Call {
	return &Blueprint_Double_Call{Call: _e.mock.On("Double", column)}
}

func (_c *Blueprint_Double_Call) Run(run func(column string)) *Blueprint_Double_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Double_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Double_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Double_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_Double_Call {
	_c.Call.Return(run)
	return _c
}

// Drop provides a mock function with no fields
func (_m *Blueprint) Drop() {
	_m.Called()
}

// Blueprint_Drop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Drop'
type Blueprint_Drop_Call struct {
	*mock.Call
}

// Drop is a helper method to define mock.On call
func (_e *Blueprint_Expecter) Drop() *Blueprint_Drop_Call {
	return &Blueprint_Drop_Call{Call: _e.mock.On("Drop")}
}

func (_c *Blueprint_Drop_Call) Run(run func()) *Blueprint_Drop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_Drop_Call) Return() *Blueprint_Drop_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Drop_Call) RunAndReturn(run func()) *Blueprint_Drop_Call {
	_c.Run(run)
	return _c
}

// DropColumn provides a mock function with given fields: column
func (_m *Blueprint) DropColumn(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DropColumn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropColumn'
type Blueprint_DropColumn_Call struct {
	*mock.Call
}

// DropColumn is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) DropColumn(column ...interface{}) *Blueprint_DropColumn_Call {
	return &Blueprint_DropColumn_Call{Call: _e.mock.On("DropColumn",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_DropColumn_Call) Run(run func(column ...string)) *Blueprint_DropColumn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DropColumn_Call) Return() *Blueprint_DropColumn_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropColumn_Call) RunAndReturn(run func(...string)) *Blueprint_DropColumn_Call {
	_c.Run(run)
	return _c
}

// DropForeign provides a mock function with given fields: column
func (_m *Blueprint) DropForeign(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DropForeign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropForeign'
type Blueprint_DropForeign_Call struct {
	*mock.Call
}

// DropForeign is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) DropForeign(column ...interface{}) *Blueprint_DropForeign_Call {
	return &Blueprint_DropForeign_Call{Call: _e.mock.On("DropForeign",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_DropForeign_Call) Run(run func(column ...string)) *Blueprint_DropForeign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DropForeign_Call) Return() *Blueprint_DropForeign_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropForeign_Call) RunAndReturn(run func(...string)) *Blueprint_DropForeign_Call {
	_c.Run(run)
	return _c
}

// DropForeignByName provides a mock function with given fields: name
func (_m *Blueprint) DropForeignByName(name string) {
	_m.Called(name)
}

// Blueprint_DropForeignByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropForeignByName'
type Blueprint_DropForeignByName_Call struct {
	*mock.Call
}

// DropForeignByName is a helper method to define mock.On call
//   - name string
func (_e *Blueprint_Expecter) DropForeignByName(name interface{}) *Blueprint_DropForeignByName_Call {
	return &Blueprint_DropForeignByName_Call{Call: _e.mock.On("DropForeignByName", name)}
}

func (_c *Blueprint_DropForeignByName_Call) Run(run func(name string)) *Blueprint_DropForeignByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_DropForeignByName_Call) Return() *Blueprint_DropForeignByName_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropForeignByName_Call) RunAndReturn(run func(string)) *Blueprint_DropForeignByName_Call {
	_c.Run(run)
	return _c
}

// DropFullText provides a mock function with given fields: column
func (_m *Blueprint) DropFullText(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DropFullText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropFullText'
type Blueprint_DropFullText_Call struct {
	*mock.Call
}

// DropFullText is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) DropFullText(column ...interface{}) *Blueprint_DropFullText_Call {
	return &Blueprint_DropFullText_Call{Call: _e.mock.On("DropFullText",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_DropFullText_Call) Run(run func(column ...string)) *Blueprint_DropFullText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DropFullText_Call) Return() *Blueprint_DropFullText_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropFullText_Call) RunAndReturn(run func(...string)) *Blueprint_DropFullText_Call {
	_c.Run(run)
	return _c
}

// DropFullTextByName provides a mock function with given fields: name
func (_m *Blueprint) DropFullTextByName(name string) {
	_m.Called(name)
}

// Blueprint_DropFullTextByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropFullTextByName'
type Blueprint_DropFullTextByName_Call struct {
	*mock.Call
}

// DropFullTextByName is a helper method to define mock.On call
//   - name string
func (_e *Blueprint_Expecter) DropFullTextByName(name interface{}) *Blueprint_DropFullTextByName_Call {
	return &Blueprint_DropFullTextByName_Call{Call: _e.mock.On("DropFullTextByName", name)}
}

func (_c *Blueprint_DropFullTextByName_Call) Run(run func(name string)) *Blueprint_DropFullTextByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_DropFullTextByName_Call) Return() *Blueprint_DropFullTextByName_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropFullTextByName_Call) RunAndReturn(run func(string)) *Blueprint_DropFullTextByName_Call {
	_c.Run(run)
	return _c
}

// DropIfExists provides a mock function with no fields
func (_m *Blueprint) DropIfExists() {
	_m.Called()
}

// Blueprint_DropIfExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropIfExists'
type Blueprint_DropIfExists_Call struct {
	*mock.Call
}

// DropIfExists is a helper method to define mock.On call
func (_e *Blueprint_Expecter) DropIfExists() *Blueprint_DropIfExists_Call {
	return &Blueprint_DropIfExists_Call{Call: _e.mock.On("DropIfExists")}
}

func (_c *Blueprint_DropIfExists_Call) Run(run func()) *Blueprint_DropIfExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_DropIfExists_Call) Return() *Blueprint_DropIfExists_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropIfExists_Call) RunAndReturn(run func()) *Blueprint_DropIfExists_Call {
	_c.Run(run)
	return _c
}

// DropIndex provides a mock function with given fields: column
func (_m *Blueprint) DropIndex(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DropIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropIndex'
type Blueprint_DropIndex_Call struct {
	*mock.Call
}

// DropIndex is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) DropIndex(column ...interface{}) *Blueprint_DropIndex_Call {
	return &Blueprint_DropIndex_Call{Call: _e.mock.On("DropIndex",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_DropIndex_Call) Run(run func(column ...string)) *Blueprint_DropIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DropIndex_Call) Return() *Blueprint_DropIndex_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropIndex_Call) RunAndReturn(run func(...string)) *Blueprint_DropIndex_Call {
	_c.Run(run)
	return _c
}

// DropIndexByName provides a mock function with given fields: name
func (_m *Blueprint) DropIndexByName(name string) {
	_m.Called(name)
}

// Blueprint_DropIndexByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropIndexByName'
type Blueprint_DropIndexByName_Call struct {
	*mock.Call
}

// DropIndexByName is a helper method to define mock.On call
//   - name string
func (_e *Blueprint_Expecter) DropIndexByName(name interface{}) *Blueprint_DropIndexByName_Call {
	return &Blueprint_DropIndexByName_Call{Call: _e.mock.On("DropIndexByName", name)}
}

func (_c *Blueprint_DropIndexByName_Call) Run(run func(name string)) *Blueprint_DropIndexByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_DropIndexByName_Call) Return() *Blueprint_DropIndexByName_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropIndexByName_Call) RunAndReturn(run func(string)) *Blueprint_DropIndexByName_Call {
	_c.Run(run)
	return _c
}

// DropPrimary provides a mock function with given fields: column
func (_m *Blueprint) DropPrimary(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DropPrimary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropPrimary'
type Blueprint_DropPrimary_Call struct {
	*mock.Call
}

// DropPrimary is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) DropPrimary(column ...interface{}) *Blueprint_DropPrimary_Call {
	return &Blueprint_DropPrimary_Call{Call: _e.mock.On("DropPrimary",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_DropPrimary_Call) Run(run func(column ...string)) *Blueprint_DropPrimary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DropPrimary_Call) Return() *Blueprint_DropPrimary_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropPrimary_Call) RunAndReturn(run func(...string)) *Blueprint_DropPrimary_Call {
	_c.Run(run)
	return _c
}

// DropSoftDeletes provides a mock function with given fields: column
func (_m *Blueprint) DropSoftDeletes(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DropSoftDeletes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropSoftDeletes'
type Blueprint_DropSoftDeletes_Call struct {
	*mock.Call
}

// DropSoftDeletes is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) DropSoftDeletes(column ...interface{}) *Blueprint_DropSoftDeletes_Call {
	return &Blueprint_DropSoftDeletes_Call{Call: _e.mock.On("DropSoftDeletes",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_DropSoftDeletes_Call) Run(run func(column ...string)) *Blueprint_DropSoftDeletes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DropSoftDeletes_Call) Return() *Blueprint_DropSoftDeletes_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropSoftDeletes_Call) RunAndReturn(run func(...string)) *Blueprint_DropSoftDeletes_Call {
	_c.Run(run)
	return _c
}

// DropSoftDeletesTz provides a mock function with given fields: column
func (_m *Blueprint) DropSoftDeletesTz(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DropSoftDeletesTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropSoftDeletesTz'
type Blueprint_DropSoftDeletesTz_Call struct {
	*mock.Call
}

// DropSoftDeletesTz is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) DropSoftDeletesTz(column ...interface{}) *Blueprint_DropSoftDeletesTz_Call {
	return &Blueprint_DropSoftDeletesTz_Call{Call: _e.mock.On("DropSoftDeletesTz",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_DropSoftDeletesTz_Call) Run(run func(column ...string)) *Blueprint_DropSoftDeletesTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DropSoftDeletesTz_Call) Return() *Blueprint_DropSoftDeletesTz_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropSoftDeletesTz_Call) RunAndReturn(run func(...string)) *Blueprint_DropSoftDeletesTz_Call {
	_c.Run(run)
	return _c
}

// DropTimestamps provides a mock function with no fields
func (_m *Blueprint) DropTimestamps() {
	_m.Called()
}

// Blueprint_DropTimestamps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropTimestamps'
type Blueprint_DropTimestamps_Call struct {
	*mock.Call
}

// DropTimestamps is a helper method to define mock.On call
func (_e *Blueprint_Expecter) DropTimestamps() *Blueprint_DropTimestamps_Call {
	return &Blueprint_DropTimestamps_Call{Call: _e.mock.On("DropTimestamps")}
}

func (_c *Blueprint_DropTimestamps_Call) Run(run func()) *Blueprint_DropTimestamps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_DropTimestamps_Call) Return() *Blueprint_DropTimestamps_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropTimestamps_Call) RunAndReturn(run func()) *Blueprint_DropTimestamps_Call {
	_c.Run(run)
	return _c
}

// DropTimestampsTz provides a mock function with no fields
func (_m *Blueprint) DropTimestampsTz() {
	_m.Called()
}

// Blueprint_DropTimestampsTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropTimestampsTz'
type Blueprint_DropTimestampsTz_Call struct {
	*mock.Call
}

// DropTimestampsTz is a helper method to define mock.On call
func (_e *Blueprint_Expecter) DropTimestampsTz() *Blueprint_DropTimestampsTz_Call {
	return &Blueprint_DropTimestampsTz_Call{Call: _e.mock.On("DropTimestampsTz")}
}

func (_c *Blueprint_DropTimestampsTz_Call) Run(run func()) *Blueprint_DropTimestampsTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_DropTimestampsTz_Call) Return() *Blueprint_DropTimestampsTz_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropTimestampsTz_Call) RunAndReturn(run func()) *Blueprint_DropTimestampsTz_Call {
	_c.Run(run)
	return _c
}

// DropUnique provides a mock function with given fields: column
func (_m *Blueprint) DropUnique(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DropUnique_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropUnique'
type Blueprint_DropUnique_Call struct {
	*mock.Call
}

// DropUnique is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) DropUnique(column ...interface{}) *Blueprint_DropUnique_Call {
	return &Blueprint_DropUnique_Call{Call: _e.mock.On("DropUnique",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_DropUnique_Call) Run(run func(column ...string)) *Blueprint_DropUnique_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DropUnique_Call) Return() *Blueprint_DropUnique_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropUnique_Call) RunAndReturn(run func(...string)) *Blueprint_DropUnique_Call {
	_c.Run(run)
	return _c
}

// DropUniqueByName provides a mock function with given fields: name
func (_m *Blueprint) DropUniqueByName(name string) {
	_m.Called(name)
}

// Blueprint_DropUniqueByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropUniqueByName'
type Blueprint_DropUniqueByName_Call struct {
	*mock.Call
}

// DropUniqueByName is a helper method to define mock.On call
//   - name string
func (_e *Blueprint_Expecter) DropUniqueByName(name interface{}) *Blueprint_DropUniqueByName_Call {
	return &Blueprint_DropUniqueByName_Call{Call: _e.mock.On("DropUniqueByName", name)}
}

func (_c *Blueprint_DropUniqueByName_Call) Run(run func(name string)) *Blueprint_DropUniqueByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_DropUniqueByName_Call) Return() *Blueprint_DropUniqueByName_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropUniqueByName_Call) RunAndReturn(run func(string)) *Blueprint_DropUniqueByName_Call {
	_c.Run(run)
	return _c
}

// Enum provides a mock function with given fields: column, array
func (_m *Blueprint) Enum(column string, array []interface{}) driver.ColumnDefinition {
	ret := _m.Called(column, array)

	if len(ret) == 0 {
		panic("no return value specified for Enum")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, []interface{}) driver.ColumnDefinition); ok {
		r0 = rf(column, array)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Enum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enum'
type Blueprint_Enum_Call struct {
	*mock.Call
}

// Enum is a helper method to define mock.On call
//   - column string
//   - array []interface{}
func (_e *Blueprint_Expecter) Enum(column interface{}, array interface{}) *Blueprint_Enum_Call {
	return &Blueprint_Enum_Call{Call: _e.mock.On("Enum", column, array)}
}

func (_c *Blueprint_Enum_Call) Run(run func(column string, array []interface{})) *Blueprint_Enum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]interface{}))
	})
	return _c
}

func (_c *Blueprint_Enum_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Enum_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Enum_Call) RunAndReturn(run func(string, []interface{}) driver.ColumnDefinition) *Blueprint_Enum_Call {
	_c.Call.Return(run)
	return _c
}

// Float provides a mock function with given fields: column, precision
func (_m *Blueprint) Float(column string, precision ...int) driver.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Float")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) driver.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Float_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Float'
type Blueprint_Float_Call struct {
	*mock.Call
}

// Float is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) Float(column interface{}, precision ...interface{}) *Blueprint_Float_Call {
	return &Blueprint_Float_Call{Call: _e.mock.On("Float",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_Float_Call) Run(run func(column string, precision ...int)) *Blueprint_Float_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Float_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Float_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Float_Call) RunAndReturn(run func(string, ...int) driver.ColumnDefinition) *Blueprint_Float_Call {
	_c.Call.Return(run)
	return _c
}

// Foreign provides a mock function with given fields: column
func (_m *Blueprint) Foreign(column ...string) schema.ForeignKeyDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Foreign")
	}

	var r0 schema.ForeignKeyDefinition
	if rf, ok := ret.Get(0).(func(...string) schema.ForeignKeyDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ForeignKeyDefinition)
		}
	}

	return r0
}

// Blueprint_Foreign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Foreign'
type Blueprint_Foreign_Call struct {
	*mock.Call
}

// Foreign is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) Foreign(column ...interface{}) *Blueprint_Foreign_Call {
	return &Blueprint_Foreign_Call{Call: _e.mock.On("Foreign",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_Foreign_Call) Run(run func(column ...string)) *Blueprint_Foreign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Foreign_Call) Return(_a0 schema.ForeignKeyDefinition) *Blueprint_Foreign_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Foreign_Call) RunAndReturn(run func(...string) schema.ForeignKeyDefinition) *Blueprint_Foreign_Call {
	_c.Call.Return(run)
	return _c
}

// ForeignID provides a mock function with given fields: column
func (_m *Blueprint) ForeignID(column string) schema.ForeignIDColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for ForeignID")
	}

	var r0 schema.ForeignIDColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ForeignIDColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ForeignIDColumnDefinition)
		}
	}

	return r0
}

// Blueprint_ForeignID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForeignID'
type Blueprint_ForeignID_Call struct {
	*mock.Call
}

// ForeignID is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) ForeignID(column interface{}) *Blueprint_ForeignID_Call {
	return &Blueprint_ForeignID_Call{Call: _e.mock.On("ForeignID", column)}
}

func (_c *Blueprint_ForeignID_Call) Run(run func(column string)) *Blueprint_ForeignID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_ForeignID_Call) Return(_a0 schema.ForeignIDColumnDefinition) *Blueprint_ForeignID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_ForeignID_Call) RunAndReturn(run func(string) schema.ForeignIDColumnDefinition) *Blueprint_ForeignID_Call {
	_c.Call.Return(run)
	return _c
}

// ForeignUlid provides a mock function with given fields: column, length
func (_m *Blueprint) ForeignUlid(column string, length ...int) schema.ForeignIDColumnDefinition {
	_va := make([]interface{}, len(length))
	for _i := range length {
		_va[_i] = length[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ForeignUlid")
	}

	var r0 schema.ForeignIDColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ForeignIDColumnDefinition); ok {
		r0 = rf(column, length...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ForeignIDColumnDefinition)
		}
	}

	return r0
}

// Blueprint_ForeignUlid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForeignUlid'
type Blueprint_ForeignUlid_Call struct {
	*mock.Call
}

// ForeignUlid is a helper method to define mock.On call
//   - column string
//   - length ...int
func (_e *Blueprint_Expecter) ForeignUlid(column interface{}, length ...interface{}) *Blueprint_ForeignUlid_Call {
	return &Blueprint_ForeignUlid_Call{Call: _e.mock.On("ForeignUlid",
		append([]interface{}{column}, length...)...)}
}

func (_c *Blueprint_ForeignUlid_Call) Run(run func(column string, length ...int)) *Blueprint_ForeignUlid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_ForeignUlid_Call) Return(_a0 schema.ForeignIDColumnDefinition) *Blueprint_ForeignUlid_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_ForeignUlid_Call) RunAndReturn(run func(string, ...int) schema.ForeignIDColumnDefinition) *Blueprint_ForeignUlid_Call {
	_c.Call.Return(run)
	return _c
}

// ForeignUuid provides a mock function with given fields: column
func (_m *Blueprint) ForeignUuid(column string) schema.ForeignIDColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for ForeignUuid")
	}

	var r0 schema.ForeignIDColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ForeignIDColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ForeignIDColumnDefinition)
		}
	}

	return r0
}

// Blueprint_ForeignUuid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForeignUuid'
type Blueprint_ForeignUuid_Call struct {
	*mock.Call
}

// ForeignUuid is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) ForeignUuid(column interface{}) *Blueprint_ForeignUuid_Call {
	return &Blueprint_ForeignUuid_Call{Call: _e.mock.On("ForeignUuid", column)}
}

func (_c *Blueprint_ForeignUuid_Call) Run(run func(column string)) *Blueprint_ForeignUuid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_ForeignUuid_Call) Return(_a0 schema.ForeignIDColumnDefinition) *Blueprint_ForeignUuid_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_ForeignUuid_Call) RunAndReturn(run func(string) schema.ForeignIDColumnDefinition) *Blueprint_ForeignUuid_Call {
	_c.Call.Return(run)
	return _c
}

// FullText provides a mock function with given fields: column
func (_m *Blueprint) FullText(column ...string) schema.IndexDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FullText")
	}

	var r0 schema.IndexDefinition
	if rf, ok := ret.Get(0).(func(...string) schema.IndexDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.IndexDefinition)
		}
	}

	return r0
}

// Blueprint_FullText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FullText'
type Blueprint_FullText_Call struct {
	*mock.Call
}

// FullText is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) FullText(column ...interface{}) *Blueprint_FullText_Call {
	return &Blueprint_FullText_Call{Call: _e.mock.On("FullText",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_FullText_Call) Run(run func(column ...string)) *Blueprint_FullText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_FullText_Call) Return(_a0 schema.IndexDefinition) *Blueprint_FullText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_FullText_Call) RunAndReturn(run func(...string) schema.IndexDefinition) *Blueprint_FullText_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddedColumns provides a mock function with no fields
func (_m *Blueprint) GetAddedColumns() []driver.ColumnDefinition {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAddedColumns")
	}

	var r0 []driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func() []driver.ColumnDefinition); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_GetAddedColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddedColumns'
type Blueprint_GetAddedColumns_Call struct {
	*mock.Call
}

// GetAddedColumns is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetAddedColumns() *Blueprint_GetAddedColumns_Call {
	return &Blueprint_GetAddedColumns_Call{Call: _e.mock.On("GetAddedColumns")}
}

func (_c *Blueprint_GetAddedColumns_Call) Run(run func()) *Blueprint_GetAddedColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetAddedColumns_Call) Return(_a0 []driver.ColumnDefinition) *Blueprint_GetAddedColumns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetAddedColumns_Call) RunAndReturn(run func() []driver.ColumnDefinition) *Blueprint_GetAddedColumns_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommands provides a mock function with no fields
func (_m *Blueprint) GetCommands() []*driver.Command {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCommands")
	}

	var r0 []*driver.Command
	if rf, ok := ret.Get(0).(func() []*driver.Command); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*driver.Command)
		}
	}

	return r0
}

// Blueprint_GetCommands_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommands'
type Blueprint_GetCommands_Call struct {
	*mock.Call
}

// GetCommands is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetCommands() *Blueprint_GetCommands_Call {
	return &Blueprint_GetCommands_Call{Call: _e.mock.On("GetCommands")}
}

func (_c *Blueprint_GetCommands_Call) Run(run func()) *Blueprint_GetCommands_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetCommands_Call) Return(_a0 []*driver.Command) *Blueprint_GetCommands_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetCommands_Call) RunAndReturn(run func() []*driver.Command) *Blueprint_GetCommands_Call {
	_c.Call.Return(run)
	return _c
}

// GetTableName provides a mock function with no fields
func (_m *Blueprint) GetTableName() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetTableName")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Blueprint_GetTableName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTableName'
type Blueprint_GetTableName_Call struct {
	*mock.Call
}

// GetTableName is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetTableName() *Blueprint_GetTableName_Call {
	return &Blueprint_GetTableName_Call{Call: _e.mock.On("GetTableName")}
}

func (_c *Blueprint_GetTableName_Call) Run(run func()) *Blueprint_GetTableName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetTableName_Call) Return(_a0 string) *Blueprint_GetTableName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetTableName_Call) RunAndReturn(run func() string) *Blueprint_GetTableName_Call {
	_c.Call.Return(run)
	return _c
}

// HasCommand provides a mock function with given fields: command
func (_m *Blueprint) HasCommand(command string) bool {
	ret := _m.Called(command)

	if len(ret) == 0 {
		panic("no return value specified for HasCommand")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(command)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Blueprint_HasCommand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasCommand'
type Blueprint_HasCommand_Call struct {
	*mock.Call
}

// HasCommand is a helper method to define mock.On call
//   - command string
func (_e *Blueprint_Expecter) HasCommand(command interface{}) *Blueprint_HasCommand_Call {
	return &Blueprint_HasCommand_Call{Call: _e.mock.On("HasCommand", command)}
}

func (_c *Blueprint_HasCommand_Call) Run(run func(command string)) *Blueprint_HasCommand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_HasCommand_Call) Return(_a0 bool) *Blueprint_HasCommand_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_HasCommand_Call) RunAndReturn(run func(string) bool) *Blueprint_HasCommand_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function with given fields: column
func (_m *Blueprint) ID(column ...string) driver.ColumnDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(...string) driver.ColumnDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type Blueprint_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) ID(column ...interface{}) *Blueprint_ID_Call {
	return &Blueprint_ID_Call{Call: _e.mock.On("ID",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_ID_Call) Run(run func(column ...string)) *Blueprint_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_ID_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_ID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_ID_Call) RunAndReturn(run func(...string) driver.ColumnDefinition) *Blueprint_ID_Call {
	_c.Call.Return(run)
	return _c
}

// Increments provides a mock function with given fields: column
func (_m *Blueprint) Increments(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Increments")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Increments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Increments'
type Blueprint_Increments_Call struct {
	*mock.Call
}

// Increments is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Increments(column interface{}) *Blueprint_Increments_Call {
	return &Blueprint_Increments_Call{Call: _e.mock.On("Increments", column)}
}

func (_c *Blueprint_Increments_Call) Run(run func(column string)) *Blueprint_Increments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Increments_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Increments_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Increments_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_Increments_Call {
	_c.Call.Return(run)
	return _c
}

// Index provides a mock function with given fields: column
func (_m *Blueprint) Index(column ...string) schema.IndexDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Index")
	}

	var r0 schema.IndexDefinition
	if rf, ok := ret.Get(0).(func(...string) schema.IndexDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.IndexDefinition)
		}
	}

	return r0
}

// Blueprint_Index_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Index'
type Blueprint_Index_Call struct {
	*mock.Call
}

// Index is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) Index(column ...interface{}) *Blueprint_Index_Call {
	return &Blueprint_Index_Call{Call: _e.mock.On("Index",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_Index_Call) Run(run func(column ...string)) *Blueprint_Index_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Index_Call) Return(_a0 schema.IndexDefinition) *Blueprint_Index_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Index_Call) RunAndReturn(run func(...string) schema.IndexDefinition) *Blueprint_Index_Call {
	_c.Call.Return(run)
	return _c
}

// Integer provides a mock function with given fields: column
func (_m *Blueprint) Integer(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Integer")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Integer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Integer'
type Blueprint_Integer_Call struct {
	*mock.Call
}

// Integer is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Integer(column interface{}) *Blueprint_Integer_Call {
	return &Blueprint_Integer_Call{Call: _e.mock.On("Integer", column)}
}

func (_c *Blueprint_Integer_Call) Run(run func(column string)) *Blueprint_Integer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Integer_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Integer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Integer_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_Integer_Call {
	_c.Call.Return(run)
	return _c
}

// IntegerIncrements provides a mock function with given fields: column
func (_m *Blueprint) IntegerIncrements(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for IntegerIncrements")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_IntegerIncrements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IntegerIncrements'
type Blueprint_IntegerIncrements_Call struct {
	*mock.Call
}

// IntegerIncrements is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) IntegerIncrements(column interface{}) *Blueprint_IntegerIncrements_Call {
	return &Blueprint_IntegerIncrements_Call{Call: _e.mock.On("IntegerIncrements", column)}
}

func (_c *Blueprint_IntegerIncrements_Call) Run(run func(column string)) *Blueprint_IntegerIncrements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_IntegerIncrements_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_IntegerIncrements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_IntegerIncrements_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_IntegerIncrements_Call {
	_c.Call.Return(run)
	return _c
}

// Json provides a mock function with given fields: column
func (_m *Blueprint) Json(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Json")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Json_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Json'
type Blueprint_Json_Call struct {
	*mock.Call
}

// Json is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Json(column interface{}) *Blueprint_Json_Call {
	return &Blueprint_Json_Call{Call: _e.mock.On("Json", column)}
}

func (_c *Blueprint_Json_Call) Run(run func(column string)) *Blueprint_Json_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Json_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Json_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Json_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_Json_Call {
	_c.Call.Return(run)
	return _c
}

// Jsonb provides a mock function with given fields: column
func (_m *Blueprint) Jsonb(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Jsonb")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Jsonb_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Jsonb'
type Blueprint_Jsonb_Call struct {
	*mock.Call
}

// Jsonb is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Jsonb(column interface{}) *Blueprint_Jsonb_Call {
	return &Blueprint_Jsonb_Call{Call: _e.mock.On("Jsonb", column)}
}

func (_c *Blueprint_Jsonb_Call) Run(run func(column string)) *Blueprint_Jsonb_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Jsonb_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Jsonb_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Jsonb_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_Jsonb_Call {
	_c.Call.Return(run)
	return _c
}

// LongText provides a mock function with given fields: column
func (_m *Blueprint) LongText(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for LongText")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_LongText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LongText'
type Blueprint_LongText_Call struct {
	*mock.Call
}

// LongText is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) LongText(column interface{}) *Blueprint_LongText_Call {
	return &Blueprint_LongText_Call{Call: _e.mock.On("LongText", column)}
}

func (_c *Blueprint_LongText_Call) Run(run func(column string)) *Blueprint_LongText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_LongText_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_LongText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_LongText_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_LongText_Call {
	_c.Call.Return(run)
	return _c
}

// MediumIncrements provides a mock function with given fields: column
func (_m *Blueprint) MediumIncrements(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for MediumIncrements")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_MediumIncrements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MediumIncrements'
type Blueprint_MediumIncrements_Call struct {
	*mock.Call
}

// MediumIncrements is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) MediumIncrements(column interface{}) *Blueprint_MediumIncrements_Call {
	return &Blueprint_MediumIncrements_Call{Call: _e.mock.On("MediumIncrements", column)}
}

func (_c *Blueprint_MediumIncrements_Call) Run(run func(column string)) *Blueprint_MediumIncrements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_MediumIncrements_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_MediumIncrements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_MediumIncrements_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_MediumIncrements_Call {
	_c.Call.Return(run)
	return _c
}

// MediumInteger provides a mock function with given fields: column
func (_m *Blueprint) MediumInteger(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for MediumInteger")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_MediumInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MediumInteger'
type Blueprint_MediumInteger_Call struct {
	*mock.Call
}

// MediumInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) MediumInteger(column interface{}) *Blueprint_MediumInteger_Call {
	return &Blueprint_MediumInteger_Call{Call: _e.mock.On("MediumInteger", column)}
}

func (_c *Blueprint_MediumInteger_Call) Run(run func(column string)) *Blueprint_MediumInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_MediumInteger_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_MediumInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_MediumInteger_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_MediumInteger_Call {
	_c.Call.Return(run)
	return _c
}

// MediumText provides a mock function with given fields: column
func (_m *Blueprint) MediumText(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for MediumText")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_MediumText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MediumText'
type Blueprint_MediumText_Call struct {
	*mock.Call
}

// MediumText is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) MediumText(column interface{}) *Blueprint_MediumText_Call {
	return &Blueprint_MediumText_Call{Call: _e.mock.On("MediumText", column)}
}

func (_c *Blueprint_MediumText_Call) Run(run func(column string)) *Blueprint_MediumText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_MediumText_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_MediumText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_MediumText_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_MediumText_Call {
	_c.Call.Return(run)
	return _c
}

// Morphs provides a mock function with given fields: name, indexName
func (_m *Blueprint) Morphs(name string, indexName ...string) {
	_va := make([]interface{}, len(indexName))
	for _i := range indexName {
		_va[_i] = indexName[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_Morphs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Morphs'
type Blueprint_Morphs_Call struct {
	*mock.Call
}

// Morphs is a helper method to define mock.On call
//   - name string
//   - indexName ...string
func (_e *Blueprint_Expecter) Morphs(name interface{}, indexName ...interface{}) *Blueprint_Morphs_Call {
	return &Blueprint_Morphs_Call{Call: _e.mock.On("Morphs",
		append([]interface{}{name}, indexName...)...)}
}

func (_c *Blueprint_Morphs_Call) Run(run func(name string, indexName ...string)) *Blueprint_Morphs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Morphs_Call) Return() *Blueprint_Morphs_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Morphs_Call) RunAndReturn(run func(string, ...string)) *Blueprint_Morphs_Call {
	_c.Run(run)
	return _c
}

// NullableMorphs provides a mock function with given fields: name, indexName
func (_m *Blueprint) NullableMorphs(name string, indexName ...string) {
	_va := make([]interface{}, len(indexName))
	for _i := range indexName {
		_va[_i] = indexName[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_NullableMorphs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NullableMorphs'
type Blueprint_NullableMorphs_Call struct {
	*mock.Call
}

// NullableMorphs is a helper method to define mock.On call
//   - name string
//   - indexName ...string
func (_e *Blueprint_Expecter) NullableMorphs(name interface{}, indexName ...interface{}) *Blueprint_NullableMorphs_Call {
	return &Blueprint_NullableMorphs_Call{Call: _e.mock.On("NullableMorphs",
		append([]interface{}{name}, indexName...)...)}
}

func (_c *Blueprint_NullableMorphs_Call) Run(run func(name string, indexName ...string)) *Blueprint_NullableMorphs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_NullableMorphs_Call) Return() *Blueprint_NullableMorphs_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_NullableMorphs_Call) RunAndReturn(run func(string, ...string)) *Blueprint_NullableMorphs_Call {
	_c.Run(run)
	return _c
}

// NumericMorphs provides a mock function with given fields: name, indexName
func (_m *Blueprint) NumericMorphs(name string, indexName ...string) {
	_va := make([]interface{}, len(indexName))
	for _i := range indexName {
		_va[_i] = indexName[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_NumericMorphs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NumericMorphs'
type Blueprint_NumericMorphs_Call struct {
	*mock.Call
}

// NumericMorphs is a helper method to define mock.On call
//   - name string
//   - indexName ...string
func (_e *Blueprint_Expecter) NumericMorphs(name interface{}, indexName ...interface{}) *Blueprint_NumericMorphs_Call {
	return &Blueprint_NumericMorphs_Call{Call: _e.mock.On("NumericMorphs",
		append([]interface{}{name}, indexName...)...)}
}

func (_c *Blueprint_NumericMorphs_Call) Run(run func(name string, indexName ...string)) *Blueprint_NumericMorphs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_NumericMorphs_Call) Return() *Blueprint_NumericMorphs_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_NumericMorphs_Call) RunAndReturn(run func(string, ...string)) *Blueprint_NumericMorphs_Call {
	_c.Run(run)
	return _c
}

// Primary provides a mock function with given fields: column
func (_m *Blueprint) Primary(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_Primary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Primary'
type Blueprint_Primary_Call struct {
	*mock.Call
}

// Primary is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) Primary(column ...interface{}) *Blueprint_Primary_Call {
	return &Blueprint_Primary_Call{Call: _e.mock.On("Primary",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_Primary_Call) Run(run func(column ...string)) *Blueprint_Primary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Primary_Call) Return() *Blueprint_Primary_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Primary_Call) RunAndReturn(run func(...string)) *Blueprint_Primary_Call {
	_c.Run(run)
	return _c
}

// Rename provides a mock function with given fields: to
func (_m *Blueprint) Rename(to string) {
	_m.Called(to)
}

// Blueprint_Rename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rename'
type Blueprint_Rename_Call struct {
	*mock.Call
}

// Rename is a helper method to define mock.On call
//   - to string
func (_e *Blueprint_Expecter) Rename(to interface{}) *Blueprint_Rename_Call {
	return &Blueprint_Rename_Call{Call: _e.mock.On("Rename", to)}
}

func (_c *Blueprint_Rename_Call) Run(run func(to string)) *Blueprint_Rename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Rename_Call) Return() *Blueprint_Rename_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Rename_Call) RunAndReturn(run func(string)) *Blueprint_Rename_Call {
	_c.Run(run)
	return _c
}

// RenameColumn provides a mock function with given fields: from, to
func (_m *Blueprint) RenameColumn(from string, to string) {
	_m.Called(from, to)
}

// Blueprint_RenameColumn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenameColumn'
type Blueprint_RenameColumn_Call struct {
	*mock.Call
}

// RenameColumn is a helper method to define mock.On call
//   - from string
//   - to string
func (_e *Blueprint_Expecter) RenameColumn(from interface{}, to interface{}) *Blueprint_RenameColumn_Call {
	return &Blueprint_RenameColumn_Call{Call: _e.mock.On("RenameColumn", from, to)}
}

func (_c *Blueprint_RenameColumn_Call) Run(run func(from string, to string)) *Blueprint_RenameColumn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Blueprint_RenameColumn_Call) Return() *Blueprint_RenameColumn_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_RenameColumn_Call) RunAndReturn(run func(string, string)) *Blueprint_RenameColumn_Call {
	_c.Run(run)
	return _c
}

// RenameIndex provides a mock function with given fields: from, to
func (_m *Blueprint) RenameIndex(from string, to string) {
	_m.Called(from, to)
}

// Blueprint_RenameIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenameIndex'
type Blueprint_RenameIndex_Call struct {
	*mock.Call
}

// RenameIndex is a helper method to define mock.On call
//   - from string
//   - to string
func (_e *Blueprint_Expecter) RenameIndex(from interface{}, to interface{}) *Blueprint_RenameIndex_Call {
	return &Blueprint_RenameIndex_Call{Call: _e.mock.On("RenameIndex", from, to)}
}

func (_c *Blueprint_RenameIndex_Call) Run(run func(from string, to string)) *Blueprint_RenameIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Blueprint_RenameIndex_Call) Return() *Blueprint_RenameIndex_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_RenameIndex_Call) RunAndReturn(run func(string, string)) *Blueprint_RenameIndex_Call {
	_c.Run(run)
	return _c
}

// SetTable provides a mock function with given fields: name
func (_m *Blueprint) SetTable(name string) {
	_m.Called(name)
}

// Blueprint_SetTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTable'
type Blueprint_SetTable_Call struct {
	*mock.Call
}

// SetTable is a helper method to define mock.On call
//   - name string
func (_e *Blueprint_Expecter) SetTable(name interface{}) *Blueprint_SetTable_Call {
	return &Blueprint_SetTable_Call{Call: _e.mock.On("SetTable", name)}
}

func (_c *Blueprint_SetTable_Call) Run(run func(name string)) *Blueprint_SetTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_SetTable_Call) Return() *Blueprint_SetTable_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_SetTable_Call) RunAndReturn(run func(string)) *Blueprint_SetTable_Call {
	_c.Run(run)
	return _c
}

// SmallIncrements provides a mock function with given fields: column
func (_m *Blueprint) SmallIncrements(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for SmallIncrements")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_SmallIncrements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SmallIncrements'
type Blueprint_SmallIncrements_Call struct {
	*mock.Call
}

// SmallIncrements is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) SmallIncrements(column interface{}) *Blueprint_SmallIncrements_Call {
	return &Blueprint_SmallIncrements_Call{Call: _e.mock.On("SmallIncrements", column)}
}

func (_c *Blueprint_SmallIncrements_Call) Run(run func(column string)) *Blueprint_SmallIncrements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_SmallIncrements_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_SmallIncrements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_SmallIncrements_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_SmallIncrements_Call {
	_c.Call.Return(run)
	return _c
}

// SmallInteger provides a mock function with given fields: column
func (_m *Blueprint) SmallInteger(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for SmallInteger")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_SmallInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SmallInteger'
type Blueprint_SmallInteger_Call struct {
	*mock.Call
}

// SmallInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) SmallInteger(column interface{}) *Blueprint_SmallInteger_Call {
	return &Blueprint_SmallInteger_Call{Call: _e.mock.On("SmallInteger", column)}
}

func (_c *Blueprint_SmallInteger_Call) Run(run func(column string)) *Blueprint_SmallInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_SmallInteger_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_SmallInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_SmallInteger_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_SmallInteger_Call {
	_c.Call.Return(run)
	return _c
}

// SoftDeletes provides a mock function with given fields: column
func (_m *Blueprint) SoftDeletes(column ...string) driver.ColumnDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftDeletes")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(...string) driver.ColumnDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_SoftDeletes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SoftDeletes'
type Blueprint_SoftDeletes_Call struct {
	*mock.Call
}

// SoftDeletes is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) SoftDeletes(column ...interface{}) *Blueprint_SoftDeletes_Call {
	return &Blueprint_SoftDeletes_Call{Call: _e.mock.On("SoftDeletes",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_SoftDeletes_Call) Run(run func(column ...string)) *Blueprint_SoftDeletes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_SoftDeletes_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_SoftDeletes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_SoftDeletes_Call) RunAndReturn(run func(...string) driver.ColumnDefinition) *Blueprint_SoftDeletes_Call {
	_c.Call.Return(run)
	return _c
}

// SoftDeletesTz provides a mock function with given fields: column
func (_m *Blueprint) SoftDeletesTz(column ...string) driver.ColumnDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftDeletesTz")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(...string) driver.ColumnDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_SoftDeletesTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SoftDeletesTz'
type Blueprint_SoftDeletesTz_Call struct {
	*mock.Call
}

// SoftDeletesTz is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) SoftDeletesTz(column ...interface{}) *Blueprint_SoftDeletesTz_Call {
	return &Blueprint_SoftDeletesTz_Call{Call: _e.mock.On("SoftDeletesTz",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_SoftDeletesTz_Call) Run(run func(column ...string)) *Blueprint_SoftDeletesTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_SoftDeletesTz_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_SoftDeletesTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_SoftDeletesTz_Call) RunAndReturn(run func(...string) driver.ColumnDefinition) *Blueprint_SoftDeletesTz_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function with given fields: column, length
func (_m *Blueprint) String(column string, length ...int) driver.ColumnDefinition {
	_va := make([]interface{}, len(length))
	for _i := range length {
		_va[_i] = length[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) driver.ColumnDefinition); ok {
		r0 = rf(column, length...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type Blueprint_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
//   - column string
//   - length ...int
func (_e *Blueprint_Expecter) String(column interface{}, length ...interface{}) *Blueprint_String_Call {
	return &Blueprint_String_Call{Call: _e.mock.On("String",
		append([]interface{}{column}, length...)...)}
}

func (_c *Blueprint_String_Call) Run(run func(column string, length ...int)) *Blueprint_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_String_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_String_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_String_Call) RunAndReturn(run func(string, ...int) driver.ColumnDefinition) *Blueprint_String_Call {
	_c.Call.Return(run)
	return _c
}

// Text provides a mock function with given fields: column
func (_m *Blueprint) Text(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Text")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Text_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Text'
type Blueprint_Text_Call struct {
	*mock.Call
}

// Text is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Text(column interface{}) *Blueprint_Text_Call {
	return &Blueprint_Text_Call{Call: _e.mock.On("Text", column)}
}

func (_c *Blueprint_Text_Call) Run(run func(column string)) *Blueprint_Text_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Text_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Text_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Text_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_Text_Call {
	_c.Call.Return(run)
	return _c
}

// Time provides a mock function with given fields: column, precision
func (_m *Blueprint) Time(column string, precision ...int) driver.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Time")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) driver.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Time_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Time'
type Blueprint_Time_Call struct {
	*mock.Call
}

// Time is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) Time(column interface{}, precision ...interface{}) *Blueprint_Time_Call {
	return &Blueprint_Time_Call{Call: _e.mock.On("Time",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_Time_Call) Run(run func(column string, precision ...int)) *Blueprint_Time_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Time_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Time_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Time_Call) RunAndReturn(run func(string, ...int) driver.ColumnDefinition) *Blueprint_Time_Call {
	_c.Call.Return(run)
	return _c
}

// TimeTz provides a mock function with given fields: column, precision
func (_m *Blueprint) TimeTz(column string, precision ...int) driver.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimeTz")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) driver.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_TimeTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimeTz'
type Blueprint_TimeTz_Call struct {
	*mock.Call
}

// TimeTz is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) TimeTz(column interface{}, precision ...interface{}) *Blueprint_TimeTz_Call {
	return &Blueprint_TimeTz_Call{Call: _e.mock.On("TimeTz",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_TimeTz_Call) Run(run func(column string, precision ...int)) *Blueprint_TimeTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_TimeTz_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_TimeTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_TimeTz_Call) RunAndReturn(run func(string, ...int) driver.ColumnDefinition) *Blueprint_TimeTz_Call {
	_c.Call.Return(run)
	return _c
}

// Timestamp provides a mock function with given fields: column, precision
func (_m *Blueprint) Timestamp(column string, precision ...int) driver.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Timestamp")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) driver.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Timestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Timestamp'
type Blueprint_Timestamp_Call struct {
	*mock.Call
}

// Timestamp is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) Timestamp(column interface{}, precision ...interface{}) *Blueprint_Timestamp_Call {
	return &Blueprint_Timestamp_Call{Call: _e.mock.On("Timestamp",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_Timestamp_Call) Run(run func(column string, precision ...int)) *Blueprint_Timestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Timestamp_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Timestamp_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Timestamp_Call) RunAndReturn(run func(string, ...int) driver.ColumnDefinition) *Blueprint_Timestamp_Call {
	_c.Call.Return(run)
	return _c
}

// TimestampTz provides a mock function with given fields: column, precision
func (_m *Blueprint) TimestampTz(column string, precision ...int) driver.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimestampTz")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) driver.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_TimestampTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimestampTz'
type Blueprint_TimestampTz_Call struct {
	*mock.Call
}

// TimestampTz is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) TimestampTz(column interface{}, precision ...interface{}) *Blueprint_TimestampTz_Call {
	return &Blueprint_TimestampTz_Call{Call: _e.mock.On("TimestampTz",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_TimestampTz_Call) Run(run func(column string, precision ...int)) *Blueprint_TimestampTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_TimestampTz_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_TimestampTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_TimestampTz_Call) RunAndReturn(run func(string, ...int) driver.ColumnDefinition) *Blueprint_TimestampTz_Call {
	_c.Call.Return(run)
	return _c
}

// Timestamps provides a mock function with given fields: precision
func (_m *Blueprint) Timestamps(precision ...int) {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_Timestamps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Timestamps'
type Blueprint_Timestamps_Call struct {
	*mock.Call
}

// Timestamps is a helper method to define mock.On call
//   - precision ...int
func (_e *Blueprint_Expecter) Timestamps(precision ...interface{}) *Blueprint_Timestamps_Call {
	return &Blueprint_Timestamps_Call{Call: _e.mock.On("Timestamps",
		append([]interface{}{}, precision...)...)}
}

func (_c *Blueprint_Timestamps_Call) Run(run func(precision ...int)) *Blueprint_Timestamps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Timestamps_Call) Return() *Blueprint_Timestamps_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Timestamps_Call) RunAndReturn(run func(...int)) *Blueprint_Timestamps_Call {
	_c.Run(run)
	return _c
}

// TimestampsTz provides a mock function with given fields: precision
func (_m *Blueprint) TimestampsTz(precision ...int) {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_TimestampsTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimestampsTz'
type Blueprint_TimestampsTz_Call struct {
	*mock.Call
}

// TimestampsTz is a helper method to define mock.On call
//   - precision ...int
func (_e *Blueprint_Expecter) TimestampsTz(precision ...interface{}) *Blueprint_TimestampsTz_Call {
	return &Blueprint_TimestampsTz_Call{Call: _e.mock.On("TimestampsTz",
		append([]interface{}{}, precision...)...)}
}

func (_c *Blueprint_TimestampsTz_Call) Run(run func(precision ...int)) *Blueprint_TimestampsTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_TimestampsTz_Call) Return() *Blueprint_TimestampsTz_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_TimestampsTz_Call) RunAndReturn(run func(...int)) *Blueprint_TimestampsTz_Call {
	_c.Run(run)
	return _c
}

// TinyIncrements provides a mock function with given fields: column
func (_m *Blueprint) TinyIncrements(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TinyIncrements")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_TinyIncrements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TinyIncrements'
type Blueprint_TinyIncrements_Call struct {
	*mock.Call
}

// TinyIncrements is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) TinyIncrements(column interface{}) *Blueprint_TinyIncrements_Call {
	return &Blueprint_TinyIncrements_Call{Call: _e.mock.On("TinyIncrements", column)}
}

func (_c *Blueprint_TinyIncrements_Call) Run(run func(column string)) *Blueprint_TinyIncrements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_TinyIncrements_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_TinyIncrements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_TinyIncrements_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_TinyIncrements_Call {
	_c.Call.Return(run)
	return _c
}

// TinyInteger provides a mock function with given fields: column
func (_m *Blueprint) TinyInteger(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TinyInteger")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_TinyInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TinyInteger'
type Blueprint_TinyInteger_Call struct {
	*mock.Call
}

// TinyInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) TinyInteger(column interface{}) *Blueprint_TinyInteger_Call {
	return &Blueprint_TinyInteger_Call{Call: _e.mock.On("TinyInteger", column)}
}

func (_c *Blueprint_TinyInteger_Call) Run(run func(column string)) *Blueprint_TinyInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_TinyInteger_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_TinyInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_TinyInteger_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_TinyInteger_Call {
	_c.Call.Return(run)
	return _c
}

// TinyText provides a mock function with given fields: column
func (_m *Blueprint) TinyText(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TinyText")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_TinyText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TinyText'
type Blueprint_TinyText_Call struct {
	*mock.Call
}

// TinyText is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) TinyText(column interface{}) *Blueprint_TinyText_Call {
	return &Blueprint_TinyText_Call{Call: _e.mock.On("TinyText", column)}
}

func (_c *Blueprint_TinyText_Call) Run(run func(column string)) *Blueprint_TinyText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_TinyText_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_TinyText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_TinyText_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_TinyText_Call {
	_c.Call.Return(run)
	return _c
}

// ToSql provides a mock function with given fields: grammar
func (_m *Blueprint) ToSql(grammar driver.Grammar) ([]string, error) {
	ret := _m.Called(grammar)

	if len(ret) == 0 {
		panic("no return value specified for ToSql")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(driver.Grammar) ([]string, error)); ok {
		return rf(grammar)
	}
	if rf, ok := ret.Get(0).(func(driver.Grammar) []string); ok {
		r0 = rf(grammar)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(driver.Grammar) error); ok {
		r1 = rf(grammar)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Blueprint_ToSql_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ToSql'
type Blueprint_ToSql_Call struct {
	*mock.Call
}

// ToSql is a helper method to define mock.On call
//   - grammar driver.Grammar
func (_e *Blueprint_Expecter) ToSql(grammar interface{}) *Blueprint_ToSql_Call {
	return &Blueprint_ToSql_Call{Call: _e.mock.On("ToSql", grammar)}
}

func (_c *Blueprint_ToSql_Call) Run(run func(grammar driver.Grammar)) *Blueprint_ToSql_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Grammar))
	})
	return _c
}

func (_c *Blueprint_ToSql_Call) Return(_a0 []string, _a1 error) *Blueprint_ToSql_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Blueprint_ToSql_Call) RunAndReturn(run func(driver.Grammar) ([]string, error)) *Blueprint_ToSql_Call {
	_c.Call.Return(run)
	return _c
}

// Ulid provides a mock function with given fields: column, length
func (_m *Blueprint) Ulid(column string, length ...int) driver.ColumnDefinition {
	_va := make([]interface{}, len(length))
	for _i := range length {
		_va[_i] = length[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Ulid")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) driver.ColumnDefinition); ok {
		r0 = rf(column, length...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Ulid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ulid'
type Blueprint_Ulid_Call struct {
	*mock.Call
}

// Ulid is a helper method to define mock.On call
//   - column string
//   - length ...int
func (_e *Blueprint_Expecter) Ulid(column interface{}, length ...interface{}) *Blueprint_Ulid_Call {
	return &Blueprint_Ulid_Call{Call: _e.mock.On("Ulid",
		append([]interface{}{column}, length...)...)}
}

func (_c *Blueprint_Ulid_Call) Run(run func(column string, length ...int)) *Blueprint_Ulid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Ulid_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Ulid_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Ulid_Call) RunAndReturn(run func(string, ...int) driver.ColumnDefinition) *Blueprint_Ulid_Call {
	_c.Call.Return(run)
	return _c
}

// UlidMorphs provides a mock function with given fields: name, indexName
func (_m *Blueprint) UlidMorphs(name string, indexName ...string) {
	_va := make([]interface{}, len(indexName))
	for _i := range indexName {
		_va[_i] = indexName[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_UlidMorphs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UlidMorphs'
type Blueprint_UlidMorphs_Call struct {
	*mock.Call
}

// UlidMorphs is a helper method to define mock.On call
//   - name string
//   - indexName ...string
func (_e *Blueprint_Expecter) UlidMorphs(name interface{}, indexName ...interface{}) *Blueprint_UlidMorphs_Call {
	return &Blueprint_UlidMorphs_Call{Call: _e.mock.On("UlidMorphs",
		append([]interface{}{name}, indexName...)...)}
}

func (_c *Blueprint_UlidMorphs_Call) Run(run func(name string, indexName ...string)) *Blueprint_UlidMorphs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_UlidMorphs_Call) Return() *Blueprint_UlidMorphs_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_UlidMorphs_Call) RunAndReturn(run func(string, ...string)) *Blueprint_UlidMorphs_Call {
	_c.Run(run)
	return _c
}

// Unique provides a mock function with given fields: column
func (_m *Blueprint) Unique(column ...string) schema.IndexDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Unique")
	}

	var r0 schema.IndexDefinition
	if rf, ok := ret.Get(0).(func(...string) schema.IndexDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.IndexDefinition)
		}
	}

	return r0
}

// Blueprint_Unique_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unique'
type Blueprint_Unique_Call struct {
	*mock.Call
}

// Unique is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) Unique(column ...interface{}) *Blueprint_Unique_Call {
	return &Blueprint_Unique_Call{Call: _e.mock.On("Unique",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_Unique_Call) Run(run func(column ...string)) *Blueprint_Unique_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Unique_Call) Return(_a0 schema.IndexDefinition) *Blueprint_Unique_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Unique_Call) RunAndReturn(run func(...string) schema.IndexDefinition) *Blueprint_Unique_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedBigInteger provides a mock function with given fields: column
func (_m *Blueprint) UnsignedBigInteger(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedBigInteger")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedBigInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedBigInteger'
type Blueprint_UnsignedBigInteger_Call struct {
	*mock.Call
}

// UnsignedBigInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) UnsignedBigInteger(column interface{}) *Blueprint_UnsignedBigInteger_Call {
	return &Blueprint_UnsignedBigInteger_Call{Call: _e.mock.On("UnsignedBigInteger", column)}
}

func (_c *Blueprint_UnsignedBigInteger_Call) Run(run func(column string)) *Blueprint_UnsignedBigInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_UnsignedBigInteger_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_UnsignedBigInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedBigInteger_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_UnsignedBigInteger_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedInteger provides a mock function with given fields: column
func (_m *Blueprint) UnsignedInteger(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedInteger")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedInteger'
type Blueprint_UnsignedInteger_Call struct {
	*mock.Call
}

// UnsignedInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) UnsignedInteger(column interface{}) *Blueprint_UnsignedInteger_Call {
	return &Blueprint_UnsignedInteger_Call{Call: _e.mock.On("UnsignedInteger", column)}
}

func (_c *Blueprint_UnsignedInteger_Call) Run(run func(column string)) *Blueprint_UnsignedInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_UnsignedInteger_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_UnsignedInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedInteger_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_UnsignedInteger_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedMediumInteger provides a mock function with given fields: column
func (_m *Blueprint) UnsignedMediumInteger(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedMediumInteger")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedMediumInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedMediumInteger'
type Blueprint_UnsignedMediumInteger_Call struct {
	*mock.Call
}

// UnsignedMediumInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) UnsignedMediumInteger(column interface{}) *Blueprint_UnsignedMediumInteger_Call {
	return &Blueprint_UnsignedMediumInteger_Call{Call: _e.mock.On("UnsignedMediumInteger", column)}
}

func (_c *Blueprint_UnsignedMediumInteger_Call) Run(run func(column string)) *Blueprint_UnsignedMediumInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_UnsignedMediumInteger_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_UnsignedMediumInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedMediumInteger_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_UnsignedMediumInteger_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedSmallInteger provides a mock function with given fields: column
func (_m *Blueprint) UnsignedSmallInteger(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedSmallInteger")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedSmallInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedSmallInteger'
type Blueprint_UnsignedSmallInteger_Call struct {
	*mock.Call
}

// UnsignedSmallInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) UnsignedSmallInteger(column interface{}) *Blueprint_UnsignedSmallInteger_Call {
	return &Blueprint_UnsignedSmallInteger_Call{Call: _e.mock.On("UnsignedSmallInteger", column)}
}

func (_c *Blueprint_UnsignedSmallInteger_Call) Run(run func(column string)) *Blueprint_UnsignedSmallInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_UnsignedSmallInteger_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_UnsignedSmallInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedSmallInteger_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_UnsignedSmallInteger_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedTinyInteger provides a mock function with given fields: column
func (_m *Blueprint) UnsignedTinyInteger(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedTinyInteger")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedTinyInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedTinyInteger'
type Blueprint_UnsignedTinyInteger_Call struct {
	*mock.Call
}

// UnsignedTinyInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) UnsignedTinyInteger(column interface{}) *Blueprint_UnsignedTinyInteger_Call {
	return &Blueprint_UnsignedTinyInteger_Call{Call: _e.mock.On("UnsignedTinyInteger", column)}
}

func (_c *Blueprint_UnsignedTinyInteger_Call) Run(run func(column string)) *Blueprint_UnsignedTinyInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_UnsignedTinyInteger_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_UnsignedTinyInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedTinyInteger_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_UnsignedTinyInteger_Call {
	_c.Call.Return(run)
	return _c
}

// Uuid provides a mock function with given fields: column
func (_m *Blueprint) Uuid(column string) driver.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Uuid")
	}

	var r0 driver.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) driver.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Uuid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Uuid'
type Blueprint_Uuid_Call struct {
	*mock.Call
}

// Uuid is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Uuid(column interface{}) *Blueprint_Uuid_Call {
	return &Blueprint_Uuid_Call{Call: _e.mock.On("Uuid", column)}
}

func (_c *Blueprint_Uuid_Call) Run(run func(column string)) *Blueprint_Uuid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Uuid_Call) Return(_a0 driver.ColumnDefinition) *Blueprint_Uuid_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Uuid_Call) RunAndReturn(run func(string) driver.ColumnDefinition) *Blueprint_Uuid_Call {
	_c.Call.Return(run)
	return _c
}

// UuidMorphs provides a mock function with given fields: name, indexName
func (_m *Blueprint) UuidMorphs(name string, indexName ...string) {
	_va := make([]interface{}, len(indexName))
	for _i := range indexName {
		_va[_i] = indexName[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_UuidMorphs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UuidMorphs'
type Blueprint_UuidMorphs_Call struct {
	*mock.Call
}

// UuidMorphs is a helper method to define mock.On call
//   - name string
//   - indexName ...string
func (_e *Blueprint_Expecter) UuidMorphs(name interface{}, indexName ...interface{}) *Blueprint_UuidMorphs_Call {
	return &Blueprint_UuidMorphs_Call{Call: _e.mock.On("UuidMorphs",
		append([]interface{}{name}, indexName...)...)}
}

func (_c *Blueprint_UuidMorphs_Call) Run(run func(name string, indexName ...string)) *Blueprint_UuidMorphs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_UuidMorphs_Call) Return() *Blueprint_UuidMorphs_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_UuidMorphs_Call) RunAndReturn(run func(string, ...string)) *Blueprint_UuidMorphs_Call {
	_c.Run(run)
	return _c
}

// NewBlueprint creates a new instance of Blueprint. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlueprint(t interface {
	mock.TestingT
	Cleanup(func())
}) *Blueprint {
	mock := &Blueprint{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
