// Code generated by mockery. DO NOT EDIT.

package driver

import (
	driver "github.com/goravel/framework/contracts/database/driver"
	mock "github.com/stretchr/testify/mock"
	clause "gorm.io/gorm/clause"

	squirrel "github.com/Masterminds/squirrel"
)

// Grammar is an autogenerated mock type for the Grammar type
type Grammar struct {
	mock.Mock
}

type Grammar_Expecter struct {
	mock *mock.Mock
}

func (_m *Grammar) EXPECT() *Grammar_Expecter {
	return &Grammar_Expecter{mock: &_m.Mock}
}

// CompileAdd provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileAdd(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileAdd")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileAdd'
type Grammar_CompileAdd_Call struct {
	*mock.Call
}

// CompileAdd is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileAdd(blueprint interface{}, command interface{}) *Grammar_CompileAdd_Call {
	return &Grammar_CompileAdd_Call{Call: _e.mock.On("CompileAdd", blueprint, command)}
}

func (_c *Grammar_CompileAdd_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileAdd_Call) Return(_a0 string) *Grammar_CompileAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileAdd_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileAdd_Call {
	_c.Call.Return(run)
	return _c
}

// CompileChange provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileChange(blueprint driver.Blueprint, command *driver.Command) []string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileChange")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) []string); ok {
		r0 = rf(blueprint, command)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Grammar_CompileChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileChange'
type Grammar_CompileChange_Call struct {
	*mock.Call
}

// CompileChange is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileChange(blueprint interface{}, command interface{}) *Grammar_CompileChange_Call {
	return &Grammar_CompileChange_Call{Call: _e.mock.On("CompileChange", blueprint, command)}
}

func (_c *Grammar_CompileChange_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileChange_Call) Return(_a0 []string) *Grammar_CompileChange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileChange_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) []string) *Grammar_CompileChange_Call {
	_c.Call.Return(run)
	return _c
}

// CompileColumns provides a mock function with given fields: schema, table
func (_m *Grammar) CompileColumns(schema string, table string) (string, error) {
	ret := _m.Called(schema, table)

	if len(ret) == 0 {
		panic("no return value specified for CompileColumns")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (string, error)); ok {
		return rf(schema, table)
	}
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(schema, table)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(schema, table)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Grammar_CompileColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileColumns'
type Grammar_CompileColumns_Call struct {
	*mock.Call
}

// CompileColumns is a helper method to define mock.On call
//   - schema string
//   - table string
func (_e *Grammar_Expecter) CompileColumns(schema interface{}, table interface{}) *Grammar_CompileColumns_Call {
	return &Grammar_CompileColumns_Call{Call: _e.mock.On("CompileColumns", schema, table)}
}

func (_c *Grammar_CompileColumns_Call) Run(run func(schema string, table string)) *Grammar_CompileColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileColumns_Call) Return(_a0 string, _a1 error) *Grammar_CompileColumns_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Grammar_CompileColumns_Call) RunAndReturn(run func(string, string) (string, error)) *Grammar_CompileColumns_Call {
	_c.Call.Return(run)
	return _c
}

// CompileComment provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileComment(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileComment")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileComment'
type Grammar_CompileComment_Call struct {
	*mock.Call
}

// CompileComment is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileComment(blueprint interface{}, command interface{}) *Grammar_CompileComment_Call {
	return &Grammar_CompileComment_Call{Call: _e.mock.On("CompileComment", blueprint, command)}
}

func (_c *Grammar_CompileComment_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileComment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileComment_Call) Return(_a0 string) *Grammar_CompileComment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileComment_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileComment_Call {
	_c.Call.Return(run)
	return _c
}

// CompileCreate provides a mock function with given fields: blueprint
func (_m *Grammar) CompileCreate(blueprint driver.Blueprint) string {
	ret := _m.Called(blueprint)

	if len(ret) == 0 {
		panic("no return value specified for CompileCreate")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint) string); ok {
		r0 = rf(blueprint)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileCreate'
type Grammar_CompileCreate_Call struct {
	*mock.Call
}

// CompileCreate is a helper method to define mock.On call
//   - blueprint driver.Blueprint
func (_e *Grammar_Expecter) CompileCreate(blueprint interface{}) *Grammar_CompileCreate_Call {
	return &Grammar_CompileCreate_Call{Call: _e.mock.On("CompileCreate", blueprint)}
}

func (_c *Grammar_CompileCreate_Call) Run(run func(blueprint driver.Blueprint)) *Grammar_CompileCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint))
	})
	return _c
}

func (_c *Grammar_CompileCreate_Call) Return(_a0 string) *Grammar_CompileCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileCreate_Call) RunAndReturn(run func(driver.Blueprint) string) *Grammar_CompileCreate_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDefault provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileDefault(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileDefault")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDefault_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDefault'
type Grammar_CompileDefault_Call struct {
	*mock.Call
}

// CompileDefault is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileDefault(blueprint interface{}, command interface{}) *Grammar_CompileDefault_Call {
	return &Grammar_CompileDefault_Call{Call: _e.mock.On("CompileDefault", blueprint, command)}
}

func (_c *Grammar_CompileDefault_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileDefault_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileDefault_Call) Return(_a0 string) *Grammar_CompileDefault_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDefault_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileDefault_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDrop provides a mock function with given fields: blueprint
func (_m *Grammar) CompileDrop(blueprint driver.Blueprint) string {
	ret := _m.Called(blueprint)

	if len(ret) == 0 {
		panic("no return value specified for CompileDrop")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint) string); ok {
		r0 = rf(blueprint)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDrop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDrop'
type Grammar_CompileDrop_Call struct {
	*mock.Call
}

// CompileDrop is a helper method to define mock.On call
//   - blueprint driver.Blueprint
func (_e *Grammar_Expecter) CompileDrop(blueprint interface{}) *Grammar_CompileDrop_Call {
	return &Grammar_CompileDrop_Call{Call: _e.mock.On("CompileDrop", blueprint)}
}

func (_c *Grammar_CompileDrop_Call) Run(run func(blueprint driver.Blueprint)) *Grammar_CompileDrop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint))
	})
	return _c
}

func (_c *Grammar_CompileDrop_Call) Return(_a0 string) *Grammar_CompileDrop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDrop_Call) RunAndReturn(run func(driver.Blueprint) string) *Grammar_CompileDrop_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropAllTables provides a mock function with given fields: schema, tables
func (_m *Grammar) CompileDropAllTables(schema string, tables []driver.Table) []string {
	ret := _m.Called(schema, tables)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropAllTables")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, []driver.Table) []string); ok {
		r0 = rf(schema, tables)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Grammar_CompileDropAllTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropAllTables'
type Grammar_CompileDropAllTables_Call struct {
	*mock.Call
}

// CompileDropAllTables is a helper method to define mock.On call
//   - schema string
//   - tables []driver.Table
func (_e *Grammar_Expecter) CompileDropAllTables(schema interface{}, tables interface{}) *Grammar_CompileDropAllTables_Call {
	return &Grammar_CompileDropAllTables_Call{Call: _e.mock.On("CompileDropAllTables", schema, tables)}
}

func (_c *Grammar_CompileDropAllTables_Call) Run(run func(schema string, tables []driver.Table)) *Grammar_CompileDropAllTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]driver.Table))
	})
	return _c
}

func (_c *Grammar_CompileDropAllTables_Call) Return(_a0 []string) *Grammar_CompileDropAllTables_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropAllTables_Call) RunAndReturn(run func(string, []driver.Table) []string) *Grammar_CompileDropAllTables_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropAllTypes provides a mock function with given fields: schema, types
func (_m *Grammar) CompileDropAllTypes(schema string, types []driver.Type) []string {
	ret := _m.Called(schema, types)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropAllTypes")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, []driver.Type) []string); ok {
		r0 = rf(schema, types)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Grammar_CompileDropAllTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropAllTypes'
type Grammar_CompileDropAllTypes_Call struct {
	*mock.Call
}

// CompileDropAllTypes is a helper method to define mock.On call
//   - schema string
//   - types []driver.Type
func (_e *Grammar_Expecter) CompileDropAllTypes(schema interface{}, types interface{}) *Grammar_CompileDropAllTypes_Call {
	return &Grammar_CompileDropAllTypes_Call{Call: _e.mock.On("CompileDropAllTypes", schema, types)}
}

func (_c *Grammar_CompileDropAllTypes_Call) Run(run func(schema string, types []driver.Type)) *Grammar_CompileDropAllTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]driver.Type))
	})
	return _c
}

func (_c *Grammar_CompileDropAllTypes_Call) Return(_a0 []string) *Grammar_CompileDropAllTypes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropAllTypes_Call) RunAndReturn(run func(string, []driver.Type) []string) *Grammar_CompileDropAllTypes_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropAllViews provides a mock function with given fields: schema, views
func (_m *Grammar) CompileDropAllViews(schema string, views []driver.View) []string {
	ret := _m.Called(schema, views)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropAllViews")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, []driver.View) []string); ok {
		r0 = rf(schema, views)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Grammar_CompileDropAllViews_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropAllViews'
type Grammar_CompileDropAllViews_Call struct {
	*mock.Call
}

// CompileDropAllViews is a helper method to define mock.On call
//   - schema string
//   - views []driver.View
func (_e *Grammar_Expecter) CompileDropAllViews(schema interface{}, views interface{}) *Grammar_CompileDropAllViews_Call {
	return &Grammar_CompileDropAllViews_Call{Call: _e.mock.On("CompileDropAllViews", schema, views)}
}

func (_c *Grammar_CompileDropAllViews_Call) Run(run func(schema string, views []driver.View)) *Grammar_CompileDropAllViews_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]driver.View))
	})
	return _c
}

func (_c *Grammar_CompileDropAllViews_Call) Return(_a0 []string) *Grammar_CompileDropAllViews_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropAllViews_Call) RunAndReturn(run func(string, []driver.View) []string) *Grammar_CompileDropAllViews_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropColumn provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileDropColumn(blueprint driver.Blueprint, command *driver.Command) []string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropColumn")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) []string); ok {
		r0 = rf(blueprint, command)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Grammar_CompileDropColumn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropColumn'
type Grammar_CompileDropColumn_Call struct {
	*mock.Call
}

// CompileDropColumn is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileDropColumn(blueprint interface{}, command interface{}) *Grammar_CompileDropColumn_Call {
	return &Grammar_CompileDropColumn_Call{Call: _e.mock.On("CompileDropColumn", blueprint, command)}
}

func (_c *Grammar_CompileDropColumn_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileDropColumn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileDropColumn_Call) Return(_a0 []string) *Grammar_CompileDropColumn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropColumn_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) []string) *Grammar_CompileDropColumn_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropForeign provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileDropForeign(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropForeign")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropForeign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropForeign'
type Grammar_CompileDropForeign_Call struct {
	*mock.Call
}

// CompileDropForeign is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileDropForeign(blueprint interface{}, command interface{}) *Grammar_CompileDropForeign_Call {
	return &Grammar_CompileDropForeign_Call{Call: _e.mock.On("CompileDropForeign", blueprint, command)}
}

func (_c *Grammar_CompileDropForeign_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileDropForeign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileDropForeign_Call) Return(_a0 string) *Grammar_CompileDropForeign_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropForeign_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileDropForeign_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropFullText provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileDropFullText(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropFullText")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropFullText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropFullText'
type Grammar_CompileDropFullText_Call struct {
	*mock.Call
}

// CompileDropFullText is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileDropFullText(blueprint interface{}, command interface{}) *Grammar_CompileDropFullText_Call {
	return &Grammar_CompileDropFullText_Call{Call: _e.mock.On("CompileDropFullText", blueprint, command)}
}

func (_c *Grammar_CompileDropFullText_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileDropFullText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileDropFullText_Call) Return(_a0 string) *Grammar_CompileDropFullText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropFullText_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileDropFullText_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropIfExists provides a mock function with given fields: blueprint
func (_m *Grammar) CompileDropIfExists(blueprint driver.Blueprint) string {
	ret := _m.Called(blueprint)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropIfExists")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint) string); ok {
		r0 = rf(blueprint)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropIfExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropIfExists'
type Grammar_CompileDropIfExists_Call struct {
	*mock.Call
}

// CompileDropIfExists is a helper method to define mock.On call
//   - blueprint driver.Blueprint
func (_e *Grammar_Expecter) CompileDropIfExists(blueprint interface{}) *Grammar_CompileDropIfExists_Call {
	return &Grammar_CompileDropIfExists_Call{Call: _e.mock.On("CompileDropIfExists", blueprint)}
}

func (_c *Grammar_CompileDropIfExists_Call) Run(run func(blueprint driver.Blueprint)) *Grammar_CompileDropIfExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint))
	})
	return _c
}

func (_c *Grammar_CompileDropIfExists_Call) Return(_a0 string) *Grammar_CompileDropIfExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropIfExists_Call) RunAndReturn(run func(driver.Blueprint) string) *Grammar_CompileDropIfExists_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropIndex provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileDropIndex(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropIndex")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropIndex'
type Grammar_CompileDropIndex_Call struct {
	*mock.Call
}

// CompileDropIndex is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileDropIndex(blueprint interface{}, command interface{}) *Grammar_CompileDropIndex_Call {
	return &Grammar_CompileDropIndex_Call{Call: _e.mock.On("CompileDropIndex", blueprint, command)}
}

func (_c *Grammar_CompileDropIndex_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileDropIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileDropIndex_Call) Return(_a0 string) *Grammar_CompileDropIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropIndex_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileDropIndex_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropPrimary provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileDropPrimary(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropPrimary")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropPrimary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropPrimary'
type Grammar_CompileDropPrimary_Call struct {
	*mock.Call
}

// CompileDropPrimary is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileDropPrimary(blueprint interface{}, command interface{}) *Grammar_CompileDropPrimary_Call {
	return &Grammar_CompileDropPrimary_Call{Call: _e.mock.On("CompileDropPrimary", blueprint, command)}
}

func (_c *Grammar_CompileDropPrimary_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileDropPrimary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileDropPrimary_Call) Return(_a0 string) *Grammar_CompileDropPrimary_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropPrimary_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileDropPrimary_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropUnique provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileDropUnique(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropUnique")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropUnique_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropUnique'
type Grammar_CompileDropUnique_Call struct {
	*mock.Call
}

// CompileDropUnique is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileDropUnique(blueprint interface{}, command interface{}) *Grammar_CompileDropUnique_Call {
	return &Grammar_CompileDropUnique_Call{Call: _e.mock.On("CompileDropUnique", blueprint, command)}
}

func (_c *Grammar_CompileDropUnique_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileDropUnique_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileDropUnique_Call) Return(_a0 string) *Grammar_CompileDropUnique_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropUnique_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileDropUnique_Call {
	_c.Call.Return(run)
	return _c
}

// CompileForeign provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileForeign(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileForeign")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileForeign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileForeign'
type Grammar_CompileForeign_Call struct {
	*mock.Call
}

// CompileForeign is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileForeign(blueprint interface{}, command interface{}) *Grammar_CompileForeign_Call {
	return &Grammar_CompileForeign_Call{Call: _e.mock.On("CompileForeign", blueprint, command)}
}

func (_c *Grammar_CompileForeign_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileForeign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileForeign_Call) Return(_a0 string) *Grammar_CompileForeign_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileForeign_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileForeign_Call {
	_c.Call.Return(run)
	return _c
}

// CompileForeignKeys provides a mock function with given fields: schema, table
func (_m *Grammar) CompileForeignKeys(schema string, table string) string {
	ret := _m.Called(schema, table)

	if len(ret) == 0 {
		panic("no return value specified for CompileForeignKeys")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(schema, table)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileForeignKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileForeignKeys'
type Grammar_CompileForeignKeys_Call struct {
	*mock.Call
}

// CompileForeignKeys is a helper method to define mock.On call
//   - schema string
//   - table string
func (_e *Grammar_Expecter) CompileForeignKeys(schema interface{}, table interface{}) *Grammar_CompileForeignKeys_Call {
	return &Grammar_CompileForeignKeys_Call{Call: _e.mock.On("CompileForeignKeys", schema, table)}
}

func (_c *Grammar_CompileForeignKeys_Call) Run(run func(schema string, table string)) *Grammar_CompileForeignKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileForeignKeys_Call) Return(_a0 string) *Grammar_CompileForeignKeys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileForeignKeys_Call) RunAndReturn(run func(string, string) string) *Grammar_CompileForeignKeys_Call {
	_c.Call.Return(run)
	return _c
}

// CompileFullText provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileFullText(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileFullText")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileFullText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileFullText'
type Grammar_CompileFullText_Call struct {
	*mock.Call
}

// CompileFullText is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileFullText(blueprint interface{}, command interface{}) *Grammar_CompileFullText_Call {
	return &Grammar_CompileFullText_Call{Call: _e.mock.On("CompileFullText", blueprint, command)}
}

func (_c *Grammar_CompileFullText_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileFullText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileFullText_Call) Return(_a0 string) *Grammar_CompileFullText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileFullText_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileFullText_Call {
	_c.Call.Return(run)
	return _c
}

// CompileInRandomOrder provides a mock function with given fields: builder, conditions
func (_m *Grammar) CompileInRandomOrder(builder squirrel.SelectBuilder, conditions *driver.Conditions) squirrel.SelectBuilder {
	ret := _m.Called(builder, conditions)

	if len(ret) == 0 {
		panic("no return value specified for CompileInRandomOrder")
	}

	var r0 squirrel.SelectBuilder
	if rf, ok := ret.Get(0).(func(squirrel.SelectBuilder, *driver.Conditions) squirrel.SelectBuilder); ok {
		r0 = rf(builder, conditions)
	} else {
		r0 = ret.Get(0).(squirrel.SelectBuilder)
	}

	return r0
}

// Grammar_CompileInRandomOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileInRandomOrder'
type Grammar_CompileInRandomOrder_Call struct {
	*mock.Call
}

// CompileInRandomOrder is a helper method to define mock.On call
//   - builder squirrel.SelectBuilder
//   - conditions *driver.Conditions
func (_e *Grammar_Expecter) CompileInRandomOrder(builder interface{}, conditions interface{}) *Grammar_CompileInRandomOrder_Call {
	return &Grammar_CompileInRandomOrder_Call{Call: _e.mock.On("CompileInRandomOrder", builder, conditions)}
}

func (_c *Grammar_CompileInRandomOrder_Call) Run(run func(builder squirrel.SelectBuilder, conditions *driver.Conditions)) *Grammar_CompileInRandomOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(squirrel.SelectBuilder), args[1].(*driver.Conditions))
	})
	return _c
}

func (_c *Grammar_CompileInRandomOrder_Call) Return(_a0 squirrel.SelectBuilder) *Grammar_CompileInRandomOrder_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileInRandomOrder_Call) RunAndReturn(run func(squirrel.SelectBuilder, *driver.Conditions) squirrel.SelectBuilder) *Grammar_CompileInRandomOrder_Call {
	_c.Call.Return(run)
	return _c
}

// CompileIndex provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileIndex(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileIndex")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileIndex'
type Grammar_CompileIndex_Call struct {
	*mock.Call
}

// CompileIndex is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileIndex(blueprint interface{}, command interface{}) *Grammar_CompileIndex_Call {
	return &Grammar_CompileIndex_Call{Call: _e.mock.On("CompileIndex", blueprint, command)}
}

func (_c *Grammar_CompileIndex_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileIndex_Call) Return(_a0 string) *Grammar_CompileIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileIndex_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileIndex_Call {
	_c.Call.Return(run)
	return _c
}

// CompileIndexes provides a mock function with given fields: schema, table
func (_m *Grammar) CompileIndexes(schema string, table string) (string, error) {
	ret := _m.Called(schema, table)

	if len(ret) == 0 {
		panic("no return value specified for CompileIndexes")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (string, error)); ok {
		return rf(schema, table)
	}
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(schema, table)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(schema, table)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Grammar_CompileIndexes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileIndexes'
type Grammar_CompileIndexes_Call struct {
	*mock.Call
}

// CompileIndexes is a helper method to define mock.On call
//   - schema string
//   - table string
func (_e *Grammar_Expecter) CompileIndexes(schema interface{}, table interface{}) *Grammar_CompileIndexes_Call {
	return &Grammar_CompileIndexes_Call{Call: _e.mock.On("CompileIndexes", schema, table)}
}

func (_c *Grammar_CompileIndexes_Call) Run(run func(schema string, table string)) *Grammar_CompileIndexes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileIndexes_Call) Return(_a0 string, _a1 error) *Grammar_CompileIndexes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Grammar_CompileIndexes_Call) RunAndReturn(run func(string, string) (string, error)) *Grammar_CompileIndexes_Call {
	_c.Call.Return(run)
	return _c
}

// CompileJsonContains provides a mock function with given fields: column, value, isNot
func (_m *Grammar) CompileJsonContains(column string, value interface{}, isNot bool) (string, []interface{}, error) {
	ret := _m.Called(column, value, isNot)

	if len(ret) == 0 {
		panic("no return value specified for CompileJsonContains")
	}

	var r0 string
	var r1 []interface{}
	var r2 error
	if rf, ok := ret.Get(0).(func(string, interface{}, bool) (string, []interface{}, error)); ok {
		return rf(column, value, isNot)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, bool) string); ok {
		r0 = rf(column, value, isNot)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, bool) []interface{}); ok {
		r1 = rf(column, value, isNot)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]interface{})
		}
	}

	if rf, ok := ret.Get(2).(func(string, interface{}, bool) error); ok {
		r2 = rf(column, value, isNot)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Grammar_CompileJsonContains_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileJsonContains'
type Grammar_CompileJsonContains_Call struct {
	*mock.Call
}

// CompileJsonContains is a helper method to define mock.On call
//   - column string
//   - value interface{}
//   - isNot bool
func (_e *Grammar_Expecter) CompileJsonContains(column interface{}, value interface{}, isNot interface{}) *Grammar_CompileJsonContains_Call {
	return &Grammar_CompileJsonContains_Call{Call: _e.mock.On("CompileJsonContains", column, value, isNot)}
}

func (_c *Grammar_CompileJsonContains_Call) Run(run func(column string, value interface{}, isNot bool)) *Grammar_CompileJsonContains_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(bool))
	})
	return _c
}

func (_c *Grammar_CompileJsonContains_Call) Return(_a0 string, _a1 []interface{}, _a2 error) *Grammar_CompileJsonContains_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Grammar_CompileJsonContains_Call) RunAndReturn(run func(string, interface{}, bool) (string, []interface{}, error)) *Grammar_CompileJsonContains_Call {
	_c.Call.Return(run)
	return _c
}

// CompileJsonContainsKey provides a mock function with given fields: column, isNot
func (_m *Grammar) CompileJsonContainsKey(column string, isNot bool) string {
	ret := _m.Called(column, isNot)

	if len(ret) == 0 {
		panic("no return value specified for CompileJsonContainsKey")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string, bool) string); ok {
		r0 = rf(column, isNot)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileJsonContainsKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileJsonContainsKey'
type Grammar_CompileJsonContainsKey_Call struct {
	*mock.Call
}

// CompileJsonContainsKey is a helper method to define mock.On call
//   - column string
//   - isNot bool
func (_e *Grammar_Expecter) CompileJsonContainsKey(column interface{}, isNot interface{}) *Grammar_CompileJsonContainsKey_Call {
	return &Grammar_CompileJsonContainsKey_Call{Call: _e.mock.On("CompileJsonContainsKey", column, isNot)}
}

func (_c *Grammar_CompileJsonContainsKey_Call) Run(run func(column string, isNot bool)) *Grammar_CompileJsonContainsKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(bool))
	})
	return _c
}

func (_c *Grammar_CompileJsonContainsKey_Call) Return(_a0 string) *Grammar_CompileJsonContainsKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileJsonContainsKey_Call) RunAndReturn(run func(string, bool) string) *Grammar_CompileJsonContainsKey_Call {
	_c.Call.Return(run)
	return _c
}

// CompileJsonLength provides a mock function with given fields: column
func (_m *Grammar) CompileJsonLength(column string) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for CompileJsonLength")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileJsonLength_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileJsonLength'
type Grammar_CompileJsonLength_Call struct {
	*mock.Call
}

// CompileJsonLength is a helper method to define mock.On call
//   - column string
func (_e *Grammar_Expecter) CompileJsonLength(column interface{}) *Grammar_CompileJsonLength_Call {
	return &Grammar_CompileJsonLength_Call{Call: _e.mock.On("CompileJsonLength", column)}
}

func (_c *Grammar_CompileJsonLength_Call) Run(run func(column string)) *Grammar_CompileJsonLength_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Grammar_CompileJsonLength_Call) Return(_a0 string) *Grammar_CompileJsonLength_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileJsonLength_Call) RunAndReturn(run func(string) string) *Grammar_CompileJsonLength_Call {
	_c.Call.Return(run)
	return _c
}

// CompileJsonSelector provides a mock function with given fields: column
func (_m *Grammar) CompileJsonSelector(column string) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for CompileJsonSelector")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileJsonSelector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileJsonSelector'
type Grammar_CompileJsonSelector_Call struct {
	*mock.Call
}

// CompileJsonSelector is a helper method to define mock.On call
//   - column string
func (_e *Grammar_Expecter) CompileJsonSelector(column interface{}) *Grammar_CompileJsonSelector_Call {
	return &Grammar_CompileJsonSelector_Call{Call: _e.mock.On("CompileJsonSelector", column)}
}

func (_c *Grammar_CompileJsonSelector_Call) Run(run func(column string)) *Grammar_CompileJsonSelector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Grammar_CompileJsonSelector_Call) Return(_a0 string) *Grammar_CompileJsonSelector_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileJsonSelector_Call) RunAndReturn(run func(string) string) *Grammar_CompileJsonSelector_Call {
	_c.Call.Return(run)
	return _c
}

// CompileJsonValues provides a mock function with given fields: args
func (_m *Grammar) CompileJsonValues(args ...interface{}) []interface{} {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CompileJsonValues")
	}

	var r0 []interface{}
	if rf, ok := ret.Get(0).(func(...interface{}) []interface{}); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	return r0
}

// Grammar_CompileJsonValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileJsonValues'
type Grammar_CompileJsonValues_Call struct {
	*mock.Call
}

// CompileJsonValues is a helper method to define mock.On call
//   - args ...interface{}
func (_e *Grammar_Expecter) CompileJsonValues(args ...interface{}) *Grammar_CompileJsonValues_Call {
	return &Grammar_CompileJsonValues_Call{Call: _e.mock.On("CompileJsonValues",
		append([]interface{}{}, args...)...)}
}

func (_c *Grammar_CompileJsonValues_Call) Run(run func(args ...interface{})) *Grammar_CompileJsonValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Grammar_CompileJsonValues_Call) Return(_a0 []interface{}) *Grammar_CompileJsonValues_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileJsonValues_Call) RunAndReturn(run func(...interface{}) []interface{}) *Grammar_CompileJsonValues_Call {
	_c.Call.Return(run)
	return _c
}

// CompileLockForUpdate provides a mock function with given fields: builder, conditions
func (_m *Grammar) CompileLockForUpdate(builder squirrel.SelectBuilder, conditions *driver.Conditions) squirrel.SelectBuilder {
	ret := _m.Called(builder, conditions)

	if len(ret) == 0 {
		panic("no return value specified for CompileLockForUpdate")
	}

	var r0 squirrel.SelectBuilder
	if rf, ok := ret.Get(0).(func(squirrel.SelectBuilder, *driver.Conditions) squirrel.SelectBuilder); ok {
		r0 = rf(builder, conditions)
	} else {
		r0 = ret.Get(0).(squirrel.SelectBuilder)
	}

	return r0
}

// Grammar_CompileLockForUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileLockForUpdate'
type Grammar_CompileLockForUpdate_Call struct {
	*mock.Call
}

// CompileLockForUpdate is a helper method to define mock.On call
//   - builder squirrel.SelectBuilder
//   - conditions *driver.Conditions
func (_e *Grammar_Expecter) CompileLockForUpdate(builder interface{}, conditions interface{}) *Grammar_CompileLockForUpdate_Call {
	return &Grammar_CompileLockForUpdate_Call{Call: _e.mock.On("CompileLockForUpdate", builder, conditions)}
}

func (_c *Grammar_CompileLockForUpdate_Call) Run(run func(builder squirrel.SelectBuilder, conditions *driver.Conditions)) *Grammar_CompileLockForUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(squirrel.SelectBuilder), args[1].(*driver.Conditions))
	})
	return _c
}

func (_c *Grammar_CompileLockForUpdate_Call) Return(_a0 squirrel.SelectBuilder) *Grammar_CompileLockForUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileLockForUpdate_Call) RunAndReturn(run func(squirrel.SelectBuilder, *driver.Conditions) squirrel.SelectBuilder) *Grammar_CompileLockForUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// CompileLockForUpdateForGorm provides a mock function with no fields
func (_m *Grammar) CompileLockForUpdateForGorm() clause.Expression {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CompileLockForUpdateForGorm")
	}

	var r0 clause.Expression
	if rf, ok := ret.Get(0).(func() clause.Expression); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(clause.Expression)
		}
	}

	return r0
}

// Grammar_CompileLockForUpdateForGorm_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileLockForUpdateForGorm'
type Grammar_CompileLockForUpdateForGorm_Call struct {
	*mock.Call
}

// CompileLockForUpdateForGorm is a helper method to define mock.On call
func (_e *Grammar_Expecter) CompileLockForUpdateForGorm() *Grammar_CompileLockForUpdateForGorm_Call {
	return &Grammar_CompileLockForUpdateForGorm_Call{Call: _e.mock.On("CompileLockForUpdateForGorm")}
}

func (_c *Grammar_CompileLockForUpdateForGorm_Call) Run(run func()) *Grammar_CompileLockForUpdateForGorm_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Grammar_CompileLockForUpdateForGorm_Call) Return(_a0 clause.Expression) *Grammar_CompileLockForUpdateForGorm_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileLockForUpdateForGorm_Call) RunAndReturn(run func() clause.Expression) *Grammar_CompileLockForUpdateForGorm_Call {
	_c.Call.Return(run)
	return _c
}

// CompilePlaceholderFormat provides a mock function with no fields
func (_m *Grammar) CompilePlaceholderFormat() driver.PlaceholderFormat {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CompilePlaceholderFormat")
	}

	var r0 driver.PlaceholderFormat
	if rf, ok := ret.Get(0).(func() driver.PlaceholderFormat); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.PlaceholderFormat)
		}
	}

	return r0
}

// Grammar_CompilePlaceholderFormat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompilePlaceholderFormat'
type Grammar_CompilePlaceholderFormat_Call struct {
	*mock.Call
}

// CompilePlaceholderFormat is a helper method to define mock.On call
func (_e *Grammar_Expecter) CompilePlaceholderFormat() *Grammar_CompilePlaceholderFormat_Call {
	return &Grammar_CompilePlaceholderFormat_Call{Call: _e.mock.On("CompilePlaceholderFormat")}
}

func (_c *Grammar_CompilePlaceholderFormat_Call) Run(run func()) *Grammar_CompilePlaceholderFormat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Grammar_CompilePlaceholderFormat_Call) Return(_a0 driver.PlaceholderFormat) *Grammar_CompilePlaceholderFormat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompilePlaceholderFormat_Call) RunAndReturn(run func() driver.PlaceholderFormat) *Grammar_CompilePlaceholderFormat_Call {
	_c.Call.Return(run)
	return _c
}

// CompilePrimary provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompilePrimary(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompilePrimary")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompilePrimary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompilePrimary'
type Grammar_CompilePrimary_Call struct {
	*mock.Call
}

// CompilePrimary is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompilePrimary(blueprint interface{}, command interface{}) *Grammar_CompilePrimary_Call {
	return &Grammar_CompilePrimary_Call{Call: _e.mock.On("CompilePrimary", blueprint, command)}
}

func (_c *Grammar_CompilePrimary_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompilePrimary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompilePrimary_Call) Return(_a0 string) *Grammar_CompilePrimary_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompilePrimary_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompilePrimary_Call {
	_c.Call.Return(run)
	return _c
}

// CompileRandomOrderForGorm provides a mock function with no fields
func (_m *Grammar) CompileRandomOrderForGorm() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CompileRandomOrderForGorm")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileRandomOrderForGorm_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileRandomOrderForGorm'
type Grammar_CompileRandomOrderForGorm_Call struct {
	*mock.Call
}

// CompileRandomOrderForGorm is a helper method to define mock.On call
func (_e *Grammar_Expecter) CompileRandomOrderForGorm() *Grammar_CompileRandomOrderForGorm_Call {
	return &Grammar_CompileRandomOrderForGorm_Call{Call: _e.mock.On("CompileRandomOrderForGorm")}
}

func (_c *Grammar_CompileRandomOrderForGorm_Call) Run(run func()) *Grammar_CompileRandomOrderForGorm_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Grammar_CompileRandomOrderForGorm_Call) Return(_a0 string) *Grammar_CompileRandomOrderForGorm_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileRandomOrderForGorm_Call) RunAndReturn(run func() string) *Grammar_CompileRandomOrderForGorm_Call {
	_c.Call.Return(run)
	return _c
}

// CompileRename provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileRename(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileRename")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileRename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileRename'
type Grammar_CompileRename_Call struct {
	*mock.Call
}

// CompileRename is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileRename(blueprint interface{}, command interface{}) *Grammar_CompileRename_Call {
	return &Grammar_CompileRename_Call{Call: _e.mock.On("CompileRename", blueprint, command)}
}

func (_c *Grammar_CompileRename_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileRename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileRename_Call) Return(_a0 string) *Grammar_CompileRename_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileRename_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileRename_Call {
	_c.Call.Return(run)
	return _c
}

// CompileRenameColumn provides a mock function with given fields: blueprint, command, columns
func (_m *Grammar) CompileRenameColumn(blueprint driver.Blueprint, command *driver.Command, columns []driver.Column) (string, error) {
	ret := _m.Called(blueprint, command, columns)

	if len(ret) == 0 {
		panic("no return value specified for CompileRenameColumn")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command, []driver.Column) (string, error)); ok {
		return rf(blueprint, command, columns)
	}
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command, []driver.Column) string); ok {
		r0 = rf(blueprint, command, columns)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(driver.Blueprint, *driver.Command, []driver.Column) error); ok {
		r1 = rf(blueprint, command, columns)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Grammar_CompileRenameColumn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileRenameColumn'
type Grammar_CompileRenameColumn_Call struct {
	*mock.Call
}

// CompileRenameColumn is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
//   - columns []driver.Column
func (_e *Grammar_Expecter) CompileRenameColumn(blueprint interface{}, command interface{}, columns interface{}) *Grammar_CompileRenameColumn_Call {
	return &Grammar_CompileRenameColumn_Call{Call: _e.mock.On("CompileRenameColumn", blueprint, command, columns)}
}

func (_c *Grammar_CompileRenameColumn_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command, columns []driver.Column)) *Grammar_CompileRenameColumn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command), args[2].([]driver.Column))
	})
	return _c
}

func (_c *Grammar_CompileRenameColumn_Call) Return(_a0 string, _a1 error) *Grammar_CompileRenameColumn_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Grammar_CompileRenameColumn_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command, []driver.Column) (string, error)) *Grammar_CompileRenameColumn_Call {
	_c.Call.Return(run)
	return _c
}

// CompileRenameIndex provides a mock function with given fields: blueprint, command, indexes
func (_m *Grammar) CompileRenameIndex(blueprint driver.Blueprint, command *driver.Command, indexes []driver.Index) []string {
	ret := _m.Called(blueprint, command, indexes)

	if len(ret) == 0 {
		panic("no return value specified for CompileRenameIndex")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command, []driver.Index) []string); ok {
		r0 = rf(blueprint, command, indexes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Grammar_CompileRenameIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileRenameIndex'
type Grammar_CompileRenameIndex_Call struct {
	*mock.Call
}

// CompileRenameIndex is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
//   - indexes []driver.Index
func (_e *Grammar_Expecter) CompileRenameIndex(blueprint interface{}, command interface{}, indexes interface{}) *Grammar_CompileRenameIndex_Call {
	return &Grammar_CompileRenameIndex_Call{Call: _e.mock.On("CompileRenameIndex", blueprint, command, indexes)}
}

func (_c *Grammar_CompileRenameIndex_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command, indexes []driver.Index)) *Grammar_CompileRenameIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command), args[2].([]driver.Index))
	})
	return _c
}

func (_c *Grammar_CompileRenameIndex_Call) Return(_a0 []string) *Grammar_CompileRenameIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileRenameIndex_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command, []driver.Index) []string) *Grammar_CompileRenameIndex_Call {
	_c.Call.Return(run)
	return _c
}

// CompileSharedLock provides a mock function with given fields: builder, conditions
func (_m *Grammar) CompileSharedLock(builder squirrel.SelectBuilder, conditions *driver.Conditions) squirrel.SelectBuilder {
	ret := _m.Called(builder, conditions)

	if len(ret) == 0 {
		panic("no return value specified for CompileSharedLock")
	}

	var r0 squirrel.SelectBuilder
	if rf, ok := ret.Get(0).(func(squirrel.SelectBuilder, *driver.Conditions) squirrel.SelectBuilder); ok {
		r0 = rf(builder, conditions)
	} else {
		r0 = ret.Get(0).(squirrel.SelectBuilder)
	}

	return r0
}

// Grammar_CompileSharedLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileSharedLock'
type Grammar_CompileSharedLock_Call struct {
	*mock.Call
}

// CompileSharedLock is a helper method to define mock.On call
//   - builder squirrel.SelectBuilder
//   - conditions *driver.Conditions
func (_e *Grammar_Expecter) CompileSharedLock(builder interface{}, conditions interface{}) *Grammar_CompileSharedLock_Call {
	return &Grammar_CompileSharedLock_Call{Call: _e.mock.On("CompileSharedLock", builder, conditions)}
}

func (_c *Grammar_CompileSharedLock_Call) Run(run func(builder squirrel.SelectBuilder, conditions *driver.Conditions)) *Grammar_CompileSharedLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(squirrel.SelectBuilder), args[1].(*driver.Conditions))
	})
	return _c
}

func (_c *Grammar_CompileSharedLock_Call) Return(_a0 squirrel.SelectBuilder) *Grammar_CompileSharedLock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileSharedLock_Call) RunAndReturn(run func(squirrel.SelectBuilder, *driver.Conditions) squirrel.SelectBuilder) *Grammar_CompileSharedLock_Call {
	_c.Call.Return(run)
	return _c
}

// CompileSharedLockForGorm provides a mock function with no fields
func (_m *Grammar) CompileSharedLockForGorm() clause.Expression {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CompileSharedLockForGorm")
	}

	var r0 clause.Expression
	if rf, ok := ret.Get(0).(func() clause.Expression); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(clause.Expression)
		}
	}

	return r0
}

// Grammar_CompileSharedLockForGorm_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileSharedLockForGorm'
type Grammar_CompileSharedLockForGorm_Call struct {
	*mock.Call
}

// CompileSharedLockForGorm is a helper method to define mock.On call
func (_e *Grammar_Expecter) CompileSharedLockForGorm() *Grammar_CompileSharedLockForGorm_Call {
	return &Grammar_CompileSharedLockForGorm_Call{Call: _e.mock.On("CompileSharedLockForGorm")}
}

func (_c *Grammar_CompileSharedLockForGorm_Call) Run(run func()) *Grammar_CompileSharedLockForGorm_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Grammar_CompileSharedLockForGorm_Call) Return(_a0 clause.Expression) *Grammar_CompileSharedLockForGorm_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileSharedLockForGorm_Call) RunAndReturn(run func() clause.Expression) *Grammar_CompileSharedLockForGorm_Call {
	_c.Call.Return(run)
	return _c
}

// CompileTableComment provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileTableComment(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileTableComment")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileTableComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileTableComment'
type Grammar_CompileTableComment_Call struct {
	*mock.Call
}

// CompileTableComment is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileTableComment(blueprint interface{}, command interface{}) *Grammar_CompileTableComment_Call {
	return &Grammar_CompileTableComment_Call{Call: _e.mock.On("CompileTableComment", blueprint, command)}
}

func (_c *Grammar_CompileTableComment_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileTableComment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileTableComment_Call) Return(_a0 string) *Grammar_CompileTableComment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileTableComment_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileTableComment_Call {
	_c.Call.Return(run)
	return _c
}

// CompileTables provides a mock function with given fields: database
func (_m *Grammar) CompileTables(database string) string {
	ret := _m.Called(database)

	if len(ret) == 0 {
		panic("no return value specified for CompileTables")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(database)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileTables'
type Grammar_CompileTables_Call struct {
	*mock.Call
}

// CompileTables is a helper method to define mock.On call
//   - database string
func (_e *Grammar_Expecter) CompileTables(database interface{}) *Grammar_CompileTables_Call {
	return &Grammar_CompileTables_Call{Call: _e.mock.On("CompileTables", database)}
}

func (_c *Grammar_CompileTables_Call) Run(run func(database string)) *Grammar_CompileTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Grammar_CompileTables_Call) Return(_a0 string) *Grammar_CompileTables_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileTables_Call) RunAndReturn(run func(string) string) *Grammar_CompileTables_Call {
	_c.Call.Return(run)
	return _c
}

// CompileTypes provides a mock function with no fields
func (_m *Grammar) CompileTypes() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CompileTypes")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileTypes'
type Grammar_CompileTypes_Call struct {
	*mock.Call
}

// CompileTypes is a helper method to define mock.On call
func (_e *Grammar_Expecter) CompileTypes() *Grammar_CompileTypes_Call {
	return &Grammar_CompileTypes_Call{Call: _e.mock.On("CompileTypes")}
}

func (_c *Grammar_CompileTypes_Call) Run(run func()) *Grammar_CompileTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Grammar_CompileTypes_Call) Return(_a0 string) *Grammar_CompileTypes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileTypes_Call) RunAndReturn(run func() string) *Grammar_CompileTypes_Call {
	_c.Call.Return(run)
	return _c
}

// CompileUnique provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileUnique(blueprint driver.Blueprint, command *driver.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileUnique")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.Blueprint, *driver.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileUnique_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileUnique'
type Grammar_CompileUnique_Call struct {
	*mock.Call
}

// CompileUnique is a helper method to define mock.On call
//   - blueprint driver.Blueprint
//   - command *driver.Command
func (_e *Grammar_Expecter) CompileUnique(blueprint interface{}, command interface{}) *Grammar_CompileUnique_Call {
	return &Grammar_CompileUnique_Call{Call: _e.mock.On("CompileUnique", blueprint, command)}
}

func (_c *Grammar_CompileUnique_Call) Run(run func(blueprint driver.Blueprint, command *driver.Command)) *Grammar_CompileUnique_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.Blueprint), args[1].(*driver.Command))
	})
	return _c
}

func (_c *Grammar_CompileUnique_Call) Return(_a0 string) *Grammar_CompileUnique_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileUnique_Call) RunAndReturn(run func(driver.Blueprint, *driver.Command) string) *Grammar_CompileUnique_Call {
	_c.Call.Return(run)
	return _c
}

// CompileVersion provides a mock function with no fields
func (_m *Grammar) CompileVersion() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CompileVersion")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileVersion'
type Grammar_CompileVersion_Call struct {
	*mock.Call
}

// CompileVersion is a helper method to define mock.On call
func (_e *Grammar_Expecter) CompileVersion() *Grammar_CompileVersion_Call {
	return &Grammar_CompileVersion_Call{Call: _e.mock.On("CompileVersion")}
}

func (_c *Grammar_CompileVersion_Call) Run(run func()) *Grammar_CompileVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Grammar_CompileVersion_Call) Return(_a0 string) *Grammar_CompileVersion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileVersion_Call) RunAndReturn(run func() string) *Grammar_CompileVersion_Call {
	_c.Call.Return(run)
	return _c
}

// CompileViews provides a mock function with given fields: database
func (_m *Grammar) CompileViews(database string) string {
	ret := _m.Called(database)

	if len(ret) == 0 {
		panic("no return value specified for CompileViews")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(database)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileViews_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileViews'
type Grammar_CompileViews_Call struct {
	*mock.Call
}

// CompileViews is a helper method to define mock.On call
//   - database string
func (_e *Grammar_Expecter) CompileViews(database interface{}) *Grammar_CompileViews_Call {
	return &Grammar_CompileViews_Call{Call: _e.mock.On("CompileViews", database)}
}

func (_c *Grammar_CompileViews_Call) Run(run func(database string)) *Grammar_CompileViews_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Grammar_CompileViews_Call) Return(_a0 string) *Grammar_CompileViews_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileViews_Call) RunAndReturn(run func(string) string) *Grammar_CompileViews_Call {
	_c.Call.Return(run)
	return _c
}

// GetAttributeCommands provides a mock function with no fields
func (_m *Grammar) GetAttributeCommands() []string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAttributeCommands")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Grammar_GetAttributeCommands_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAttributeCommands'
type Grammar_GetAttributeCommands_Call struct {
	*mock.Call
}

// GetAttributeCommands is a helper method to define mock.On call
func (_e *Grammar_Expecter) GetAttributeCommands() *Grammar_GetAttributeCommands_Call {
	return &Grammar_GetAttributeCommands_Call{Call: _e.mock.On("GetAttributeCommands")}
}

func (_c *Grammar_GetAttributeCommands_Call) Run(run func()) *Grammar_GetAttributeCommands_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Grammar_GetAttributeCommands_Call) Return(_a0 []string) *Grammar_GetAttributeCommands_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_GetAttributeCommands_Call) RunAndReturn(run func() []string) *Grammar_GetAttributeCommands_Call {
	_c.Call.Return(run)
	return _c
}

// TypeBigInteger provides a mock function with given fields: column
func (_m *Grammar) TypeBigInteger(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeBigInteger")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeBigInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeBigInteger'
type Grammar_TypeBigInteger_Call struct {
	*mock.Call
}

// TypeBigInteger is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeBigInteger(column interface{}) *Grammar_TypeBigInteger_Call {
	return &Grammar_TypeBigInteger_Call{Call: _e.mock.On("TypeBigInteger", column)}
}

func (_c *Grammar_TypeBigInteger_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeBigInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeBigInteger_Call) Return(_a0 string) *Grammar_TypeBigInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeBigInteger_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeBigInteger_Call {
	_c.Call.Return(run)
	return _c
}

// TypeBoolean provides a mock function with given fields: column
func (_m *Grammar) TypeBoolean(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeBoolean")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeBoolean_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeBoolean'
type Grammar_TypeBoolean_Call struct {
	*mock.Call
}

// TypeBoolean is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeBoolean(column interface{}) *Grammar_TypeBoolean_Call {
	return &Grammar_TypeBoolean_Call{Call: _e.mock.On("TypeBoolean", column)}
}

func (_c *Grammar_TypeBoolean_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeBoolean_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeBoolean_Call) Return(_a0 string) *Grammar_TypeBoolean_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeBoolean_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeBoolean_Call {
	_c.Call.Return(run)
	return _c
}

// TypeChar provides a mock function with given fields: column
func (_m *Grammar) TypeChar(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeChar")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeChar_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeChar'
type Grammar_TypeChar_Call struct {
	*mock.Call
}

// TypeChar is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeChar(column interface{}) *Grammar_TypeChar_Call {
	return &Grammar_TypeChar_Call{Call: _e.mock.On("TypeChar", column)}
}

func (_c *Grammar_TypeChar_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeChar_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeChar_Call) Return(_a0 string) *Grammar_TypeChar_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeChar_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeChar_Call {
	_c.Call.Return(run)
	return _c
}

// TypeDate provides a mock function with given fields: column
func (_m *Grammar) TypeDate(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeDate")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeDate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeDate'
type Grammar_TypeDate_Call struct {
	*mock.Call
}

// TypeDate is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeDate(column interface{}) *Grammar_TypeDate_Call {
	return &Grammar_TypeDate_Call{Call: _e.mock.On("TypeDate", column)}
}

func (_c *Grammar_TypeDate_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeDate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeDate_Call) Return(_a0 string) *Grammar_TypeDate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeDate_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeDate_Call {
	_c.Call.Return(run)
	return _c
}

// TypeDateTime provides a mock function with given fields: column
func (_m *Grammar) TypeDateTime(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeDateTime")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeDateTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeDateTime'
type Grammar_TypeDateTime_Call struct {
	*mock.Call
}

// TypeDateTime is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeDateTime(column interface{}) *Grammar_TypeDateTime_Call {
	return &Grammar_TypeDateTime_Call{Call: _e.mock.On("TypeDateTime", column)}
}

func (_c *Grammar_TypeDateTime_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeDateTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeDateTime_Call) Return(_a0 string) *Grammar_TypeDateTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeDateTime_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeDateTime_Call {
	_c.Call.Return(run)
	return _c
}

// TypeDateTimeTz provides a mock function with given fields: column
func (_m *Grammar) TypeDateTimeTz(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeDateTimeTz")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeDateTimeTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeDateTimeTz'
type Grammar_TypeDateTimeTz_Call struct {
	*mock.Call
}

// TypeDateTimeTz is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeDateTimeTz(column interface{}) *Grammar_TypeDateTimeTz_Call {
	return &Grammar_TypeDateTimeTz_Call{Call: _e.mock.On("TypeDateTimeTz", column)}
}

func (_c *Grammar_TypeDateTimeTz_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeDateTimeTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeDateTimeTz_Call) Return(_a0 string) *Grammar_TypeDateTimeTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeDateTimeTz_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeDateTimeTz_Call {
	_c.Call.Return(run)
	return _c
}

// TypeDecimal provides a mock function with given fields: column
func (_m *Grammar) TypeDecimal(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeDecimal")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeDecimal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeDecimal'
type Grammar_TypeDecimal_Call struct {
	*mock.Call
}

// TypeDecimal is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeDecimal(column interface{}) *Grammar_TypeDecimal_Call {
	return &Grammar_TypeDecimal_Call{Call: _e.mock.On("TypeDecimal", column)}
}

func (_c *Grammar_TypeDecimal_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeDecimal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeDecimal_Call) Return(_a0 string) *Grammar_TypeDecimal_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeDecimal_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeDecimal_Call {
	_c.Call.Return(run)
	return _c
}

// TypeDouble provides a mock function with given fields: column
func (_m *Grammar) TypeDouble(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeDouble")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeDouble_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeDouble'
type Grammar_TypeDouble_Call struct {
	*mock.Call
}

// TypeDouble is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeDouble(column interface{}) *Grammar_TypeDouble_Call {
	return &Grammar_TypeDouble_Call{Call: _e.mock.On("TypeDouble", column)}
}

func (_c *Grammar_TypeDouble_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeDouble_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeDouble_Call) Return(_a0 string) *Grammar_TypeDouble_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeDouble_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeDouble_Call {
	_c.Call.Return(run)
	return _c
}

// TypeEnum provides a mock function with given fields: column
func (_m *Grammar) TypeEnum(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeEnum")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeEnum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeEnum'
type Grammar_TypeEnum_Call struct {
	*mock.Call
}

// TypeEnum is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeEnum(column interface{}) *Grammar_TypeEnum_Call {
	return &Grammar_TypeEnum_Call{Call: _e.mock.On("TypeEnum", column)}
}

func (_c *Grammar_TypeEnum_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeEnum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeEnum_Call) Return(_a0 string) *Grammar_TypeEnum_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeEnum_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeEnum_Call {
	_c.Call.Return(run)
	return _c
}

// TypeFloat provides a mock function with given fields: column
func (_m *Grammar) TypeFloat(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeFloat")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeFloat'
type Grammar_TypeFloat_Call struct {
	*mock.Call
}

// TypeFloat is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeFloat(column interface{}) *Grammar_TypeFloat_Call {
	return &Grammar_TypeFloat_Call{Call: _e.mock.On("TypeFloat", column)}
}

func (_c *Grammar_TypeFloat_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeFloat_Call) Return(_a0 string) *Grammar_TypeFloat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeFloat_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeFloat_Call {
	_c.Call.Return(run)
	return _c
}

// TypeInteger provides a mock function with given fields: column
func (_m *Grammar) TypeInteger(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeInteger")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeInteger'
type Grammar_TypeInteger_Call struct {
	*mock.Call
}

// TypeInteger is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeInteger(column interface{}) *Grammar_TypeInteger_Call {
	return &Grammar_TypeInteger_Call{Call: _e.mock.On("TypeInteger", column)}
}

func (_c *Grammar_TypeInteger_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeInteger_Call) Return(_a0 string) *Grammar_TypeInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeInteger_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeInteger_Call {
	_c.Call.Return(run)
	return _c
}

// TypeJson provides a mock function with given fields: column
func (_m *Grammar) TypeJson(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeJson")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeJson_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeJson'
type Grammar_TypeJson_Call struct {
	*mock.Call
}

// TypeJson is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeJson(column interface{}) *Grammar_TypeJson_Call {
	return &Grammar_TypeJson_Call{Call: _e.mock.On("TypeJson", column)}
}

func (_c *Grammar_TypeJson_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeJson_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeJson_Call) Return(_a0 string) *Grammar_TypeJson_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeJson_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeJson_Call {
	_c.Call.Return(run)
	return _c
}

// TypeJsonb provides a mock function with given fields: column
func (_m *Grammar) TypeJsonb(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeJsonb")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeJsonb_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeJsonb'
type Grammar_TypeJsonb_Call struct {
	*mock.Call
}

// TypeJsonb is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeJsonb(column interface{}) *Grammar_TypeJsonb_Call {
	return &Grammar_TypeJsonb_Call{Call: _e.mock.On("TypeJsonb", column)}
}

func (_c *Grammar_TypeJsonb_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeJsonb_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeJsonb_Call) Return(_a0 string) *Grammar_TypeJsonb_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeJsonb_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeJsonb_Call {
	_c.Call.Return(run)
	return _c
}

// TypeLongText provides a mock function with given fields: column
func (_m *Grammar) TypeLongText(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeLongText")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeLongText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeLongText'
type Grammar_TypeLongText_Call struct {
	*mock.Call
}

// TypeLongText is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeLongText(column interface{}) *Grammar_TypeLongText_Call {
	return &Grammar_TypeLongText_Call{Call: _e.mock.On("TypeLongText", column)}
}

func (_c *Grammar_TypeLongText_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeLongText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeLongText_Call) Return(_a0 string) *Grammar_TypeLongText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeLongText_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeLongText_Call {
	_c.Call.Return(run)
	return _c
}

// TypeMediumInteger provides a mock function with given fields: column
func (_m *Grammar) TypeMediumInteger(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeMediumInteger")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeMediumInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeMediumInteger'
type Grammar_TypeMediumInteger_Call struct {
	*mock.Call
}

// TypeMediumInteger is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeMediumInteger(column interface{}) *Grammar_TypeMediumInteger_Call {
	return &Grammar_TypeMediumInteger_Call{Call: _e.mock.On("TypeMediumInteger", column)}
}

func (_c *Grammar_TypeMediumInteger_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeMediumInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeMediumInteger_Call) Return(_a0 string) *Grammar_TypeMediumInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeMediumInteger_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeMediumInteger_Call {
	_c.Call.Return(run)
	return _c
}

// TypeMediumText provides a mock function with given fields: column
func (_m *Grammar) TypeMediumText(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeMediumText")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeMediumText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeMediumText'
type Grammar_TypeMediumText_Call struct {
	*mock.Call
}

// TypeMediumText is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeMediumText(column interface{}) *Grammar_TypeMediumText_Call {
	return &Grammar_TypeMediumText_Call{Call: _e.mock.On("TypeMediumText", column)}
}

func (_c *Grammar_TypeMediumText_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeMediumText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeMediumText_Call) Return(_a0 string) *Grammar_TypeMediumText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeMediumText_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeMediumText_Call {
	_c.Call.Return(run)
	return _c
}

// TypeSmallInteger provides a mock function with given fields: column
func (_m *Grammar) TypeSmallInteger(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeSmallInteger")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeSmallInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeSmallInteger'
type Grammar_TypeSmallInteger_Call struct {
	*mock.Call
}

// TypeSmallInteger is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeSmallInteger(column interface{}) *Grammar_TypeSmallInteger_Call {
	return &Grammar_TypeSmallInteger_Call{Call: _e.mock.On("TypeSmallInteger", column)}
}

func (_c *Grammar_TypeSmallInteger_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeSmallInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeSmallInteger_Call) Return(_a0 string) *Grammar_TypeSmallInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeSmallInteger_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeSmallInteger_Call {
	_c.Call.Return(run)
	return _c
}

// TypeString provides a mock function with given fields: column
func (_m *Grammar) TypeString(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeString")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeString'
type Grammar_TypeString_Call struct {
	*mock.Call
}

// TypeString is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeString(column interface{}) *Grammar_TypeString_Call {
	return &Grammar_TypeString_Call{Call: _e.mock.On("TypeString", column)}
}

func (_c *Grammar_TypeString_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeString_Call) Return(_a0 string) *Grammar_TypeString_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeString_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeString_Call {
	_c.Call.Return(run)
	return _c
}

// TypeText provides a mock function with given fields: column
func (_m *Grammar) TypeText(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeText")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeText'
type Grammar_TypeText_Call struct {
	*mock.Call
}

// TypeText is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeText(column interface{}) *Grammar_TypeText_Call {
	return &Grammar_TypeText_Call{Call: _e.mock.On("TypeText", column)}
}

func (_c *Grammar_TypeText_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeText_Call) Return(_a0 string) *Grammar_TypeText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeText_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeText_Call {
	_c.Call.Return(run)
	return _c
}

// TypeTime provides a mock function with given fields: column
func (_m *Grammar) TypeTime(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeTime")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeTime'
type Grammar_TypeTime_Call struct {
	*mock.Call
}

// TypeTime is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeTime(column interface{}) *Grammar_TypeTime_Call {
	return &Grammar_TypeTime_Call{Call: _e.mock.On("TypeTime", column)}
}

func (_c *Grammar_TypeTime_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeTime_Call) Return(_a0 string) *Grammar_TypeTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeTime_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeTime_Call {
	_c.Call.Return(run)
	return _c
}

// TypeTimeTz provides a mock function with given fields: column
func (_m *Grammar) TypeTimeTz(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeTimeTz")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeTimeTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeTimeTz'
type Grammar_TypeTimeTz_Call struct {
	*mock.Call
}

// TypeTimeTz is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeTimeTz(column interface{}) *Grammar_TypeTimeTz_Call {
	return &Grammar_TypeTimeTz_Call{Call: _e.mock.On("TypeTimeTz", column)}
}

func (_c *Grammar_TypeTimeTz_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeTimeTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeTimeTz_Call) Return(_a0 string) *Grammar_TypeTimeTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeTimeTz_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeTimeTz_Call {
	_c.Call.Return(run)
	return _c
}

// TypeTimestamp provides a mock function with given fields: column
func (_m *Grammar) TypeTimestamp(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeTimestamp")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeTimestamp'
type Grammar_TypeTimestamp_Call struct {
	*mock.Call
}

// TypeTimestamp is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeTimestamp(column interface{}) *Grammar_TypeTimestamp_Call {
	return &Grammar_TypeTimestamp_Call{Call: _e.mock.On("TypeTimestamp", column)}
}

func (_c *Grammar_TypeTimestamp_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeTimestamp_Call) Return(_a0 string) *Grammar_TypeTimestamp_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeTimestamp_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// TypeTimestampTz provides a mock function with given fields: column
func (_m *Grammar) TypeTimestampTz(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeTimestampTz")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeTimestampTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeTimestampTz'
type Grammar_TypeTimestampTz_Call struct {
	*mock.Call
}

// TypeTimestampTz is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeTimestampTz(column interface{}) *Grammar_TypeTimestampTz_Call {
	return &Grammar_TypeTimestampTz_Call{Call: _e.mock.On("TypeTimestampTz", column)}
}

func (_c *Grammar_TypeTimestampTz_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeTimestampTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeTimestampTz_Call) Return(_a0 string) *Grammar_TypeTimestampTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeTimestampTz_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeTimestampTz_Call {
	_c.Call.Return(run)
	return _c
}

// TypeTinyInteger provides a mock function with given fields: column
func (_m *Grammar) TypeTinyInteger(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeTinyInteger")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeTinyInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeTinyInteger'
type Grammar_TypeTinyInteger_Call struct {
	*mock.Call
}

// TypeTinyInteger is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeTinyInteger(column interface{}) *Grammar_TypeTinyInteger_Call {
	return &Grammar_TypeTinyInteger_Call{Call: _e.mock.On("TypeTinyInteger", column)}
}

func (_c *Grammar_TypeTinyInteger_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeTinyInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeTinyInteger_Call) Return(_a0 string) *Grammar_TypeTinyInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeTinyInteger_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeTinyInteger_Call {
	_c.Call.Return(run)
	return _c
}

// TypeTinyText provides a mock function with given fields: column
func (_m *Grammar) TypeTinyText(column driver.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeTinyText")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(driver.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeTinyText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeTinyText'
type Grammar_TypeTinyText_Call struct {
	*mock.Call
}

// TypeTinyText is a helper method to define mock.On call
//   - column driver.ColumnDefinition
func (_e *Grammar_Expecter) TypeTinyText(column interface{}) *Grammar_TypeTinyText_Call {
	return &Grammar_TypeTinyText_Call{Call: _e.mock.On("TypeTinyText", column)}
}

func (_c *Grammar_TypeTinyText_Call) Run(run func(column driver.ColumnDefinition)) *Grammar_TypeTinyText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(driver.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeTinyText_Call) Return(_a0 string) *Grammar_TypeTinyText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeTinyText_Call) RunAndReturn(run func(driver.ColumnDefinition) string) *Grammar_TypeTinyText_Call {
	_c.Call.Return(run)
	return _c
}

// NewGrammar creates a new instance of Grammar. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGrammar(t interface {
	mock.TestingT
	Cleanup(func())
}) *Grammar {
	mock := &Grammar{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
