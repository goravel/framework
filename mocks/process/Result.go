// Code generated by mockery. DO NOT EDIT.

package process

import mock "github.com/stretchr/testify/mock"

// Result is an autogenerated mock type for the Result type
type Result struct {
	mock.Mock
}

type Result_Expecter struct {
	mock *mock.Mock
}

func (_m *Result) EXPECT() *Result_Expecter {
	return &Result_Expecter{mock: &_m.Mock}
}

// Command provides a mock function with no fields
func (_m *Result) Command() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Command")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Result_Command_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Command'
type Result_Command_Call struct {
	*mock.Call
}

// Command is a helper method to define mock.On call
func (_e *Result_Expecter) Command() *Result_Command_Call {
	return &Result_Command_Call{Call: _e.mock.On("Command")}
}

func (_c *Result_Command_Call) Run(run func()) *Result_Command_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Result_Command_Call) Return(_a0 string) *Result_Command_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Result_Command_Call) RunAndReturn(run func() string) *Result_Command_Call {
	_c.Call.Return(run)
	return _c
}

// Error provides a mock function with no fields
func (_m *Result) Error() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Error")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Result_Error_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Error'
type Result_Error_Call struct {
	*mock.Call
}

// Error is a helper method to define mock.On call
func (_e *Result_Expecter) Error() *Result_Error_Call {
	return &Result_Error_Call{Call: _e.mock.On("Error")}
}

func (_c *Result_Error_Call) Run(run func()) *Result_Error_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Result_Error_Call) Return(_a0 error) *Result_Error_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Result_Error_Call) RunAndReturn(run func() error) *Result_Error_Call {
	_c.Call.Return(run)
	return _c
}

// ErrorOutput provides a mock function with no fields
func (_m *Result) ErrorOutput() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ErrorOutput")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Result_ErrorOutput_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ErrorOutput'
type Result_ErrorOutput_Call struct {
	*mock.Call
}

// ErrorOutput is a helper method to define mock.On call
func (_e *Result_Expecter) ErrorOutput() *Result_ErrorOutput_Call {
	return &Result_ErrorOutput_Call{Call: _e.mock.On("ErrorOutput")}
}

func (_c *Result_ErrorOutput_Call) Run(run func()) *Result_ErrorOutput_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Result_ErrorOutput_Call) Return(_a0 string) *Result_ErrorOutput_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Result_ErrorOutput_Call) RunAndReturn(run func() string) *Result_ErrorOutput_Call {
	_c.Call.Return(run)
	return _c
}

// ExitCode provides a mock function with no fields
func (_m *Result) ExitCode() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ExitCode")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Result_ExitCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExitCode'
type Result_ExitCode_Call struct {
	*mock.Call
}

// ExitCode is a helper method to define mock.On call
func (_e *Result_Expecter) ExitCode() *Result_ExitCode_Call {
	return &Result_ExitCode_Call{Call: _e.mock.On("ExitCode")}
}

func (_c *Result_ExitCode_Call) Run(run func()) *Result_ExitCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Result_ExitCode_Call) Return(_a0 int) *Result_ExitCode_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Result_ExitCode_Call) RunAndReturn(run func() int) *Result_ExitCode_Call {
	_c.Call.Return(run)
	return _c
}

// Failed provides a mock function with no fields
func (_m *Result) Failed() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Failed")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Result_Failed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Failed'
type Result_Failed_Call struct {
	*mock.Call
}

// Failed is a helper method to define mock.On call
func (_e *Result_Expecter) Failed() *Result_Failed_Call {
	return &Result_Failed_Call{Call: _e.mock.On("Failed")}
}

func (_c *Result_Failed_Call) Run(run func()) *Result_Failed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Result_Failed_Call) Return(_a0 bool) *Result_Failed_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Result_Failed_Call) RunAndReturn(run func() bool) *Result_Failed_Call {
	_c.Call.Return(run)
	return _c
}

// Output provides a mock function with no fields
func (_m *Result) Output() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Output")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Result_Output_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Output'
type Result_Output_Call struct {
	*mock.Call
}

// Output is a helper method to define mock.On call
func (_e *Result_Expecter) Output() *Result_Output_Call {
	return &Result_Output_Call{Call: _e.mock.On("Output")}
}

func (_c *Result_Output_Call) Run(run func()) *Result_Output_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Result_Output_Call) Return(_a0 string) *Result_Output_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Result_Output_Call) RunAndReturn(run func() string) *Result_Output_Call {
	_c.Call.Return(run)
	return _c
}

// SeeInErrorOutput provides a mock function with given fields: needle
func (_m *Result) SeeInErrorOutput(needle string) bool {
	ret := _m.Called(needle)

	if len(ret) == 0 {
		panic("no return value specified for SeeInErrorOutput")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(needle)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Result_SeeInErrorOutput_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SeeInErrorOutput'
type Result_SeeInErrorOutput_Call struct {
	*mock.Call
}

// SeeInErrorOutput is a helper method to define mock.On call
//   - needle string
func (_e *Result_Expecter) SeeInErrorOutput(needle interface{}) *Result_SeeInErrorOutput_Call {
	return &Result_SeeInErrorOutput_Call{Call: _e.mock.On("SeeInErrorOutput", needle)}
}

func (_c *Result_SeeInErrorOutput_Call) Run(run func(needle string)) *Result_SeeInErrorOutput_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Result_SeeInErrorOutput_Call) Return(_a0 bool) *Result_SeeInErrorOutput_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Result_SeeInErrorOutput_Call) RunAndReturn(run func(string) bool) *Result_SeeInErrorOutput_Call {
	_c.Call.Return(run)
	return _c
}

// SeeInOutput provides a mock function with given fields: needle
func (_m *Result) SeeInOutput(needle string) bool {
	ret := _m.Called(needle)

	if len(ret) == 0 {
		panic("no return value specified for SeeInOutput")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(needle)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Result_SeeInOutput_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SeeInOutput'
type Result_SeeInOutput_Call struct {
	*mock.Call
}

// SeeInOutput is a helper method to define mock.On call
//   - needle string
func (_e *Result_Expecter) SeeInOutput(needle interface{}) *Result_SeeInOutput_Call {
	return &Result_SeeInOutput_Call{Call: _e.mock.On("SeeInOutput", needle)}
}

func (_c *Result_SeeInOutput_Call) Run(run func(needle string)) *Result_SeeInOutput_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Result_SeeInOutput_Call) Return(_a0 bool) *Result_SeeInOutput_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Result_SeeInOutput_Call) RunAndReturn(run func(string) bool) *Result_SeeInOutput_Call {
	_c.Call.Return(run)
	return _c
}

// Successful provides a mock function with no fields
func (_m *Result) Successful() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Successful")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Result_Successful_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Successful'
type Result_Successful_Call struct {
	*mock.Call
}

// Successful is a helper method to define mock.On call
func (_e *Result_Expecter) Successful() *Result_Successful_Call {
	return &Result_Successful_Call{Call: _e.mock.On("Successful")}
}

func (_c *Result_Successful_Call) Run(run func()) *Result_Successful_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Result_Successful_Call) Return(_a0 bool) *Result_Successful_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Result_Successful_Call) RunAndReturn(run func() bool) *Result_Successful_Call {
	_c.Call.Return(run)
	return _c
}

// NewResult creates a new instance of Result. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewResult(t interface {
	mock.TestingT
	Cleanup(func())
}) *Result {
	mock := &Result{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
