// Code generated by mockery. DO NOT EDIT.

package http

import (
	http "github.com/goravel/framework/contracts/testing/http"
	mock "github.com/stretchr/testify/mock"

	nethttp "net/http"
)

// Response is an autogenerated mock type for the Response type
type Response struct {
	mock.Mock
}

type Response_Expecter struct {
	mock *mock.Mock
}

func (_m *Response) EXPECT() *Response_Expecter {
	return &Response_Expecter{mock: &_m.Mock}
}

// AssertAccepted provides a mock function with no fields
func (_m *Response) AssertAccepted() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertAccepted")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertAccepted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertAccepted'
type Response_AssertAccepted_Call struct {
	*mock.Call
}

// AssertAccepted is a helper method to define mock.On call
func (_e *Response_Expecter) AssertAccepted() *Response_AssertAccepted_Call {
	return &Response_AssertAccepted_Call{Call: _e.mock.On("AssertAccepted")}
}

func (_c *Response_AssertAccepted_Call) Run(run func()) *Response_AssertAccepted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertAccepted_Call) Return(_a0 http.Response) *Response_AssertAccepted_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertAccepted_Call) RunAndReturn(run func() http.Response) *Response_AssertAccepted_Call {
	_c.Call.Return(run)
	return _c
}

// AssertBadRequest provides a mock function with no fields
func (_m *Response) AssertBadRequest() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertBadRequest")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertBadRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertBadRequest'
type Response_AssertBadRequest_Call struct {
	*mock.Call
}

// AssertBadRequest is a helper method to define mock.On call
func (_e *Response_Expecter) AssertBadRequest() *Response_AssertBadRequest_Call {
	return &Response_AssertBadRequest_Call{Call: _e.mock.On("AssertBadRequest")}
}

func (_c *Response_AssertBadRequest_Call) Run(run func()) *Response_AssertBadRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertBadRequest_Call) Return(_a0 http.Response) *Response_AssertBadRequest_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertBadRequest_Call) RunAndReturn(run func() http.Response) *Response_AssertBadRequest_Call {
	_c.Call.Return(run)
	return _c
}

// AssertConflict provides a mock function with no fields
func (_m *Response) AssertConflict() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertConflict")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertConflict_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertConflict'
type Response_AssertConflict_Call struct {
	*mock.Call
}

// AssertConflict is a helper method to define mock.On call
func (_e *Response_Expecter) AssertConflict() *Response_AssertConflict_Call {
	return &Response_AssertConflict_Call{Call: _e.mock.On("AssertConflict")}
}

func (_c *Response_AssertConflict_Call) Run(run func()) *Response_AssertConflict_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertConflict_Call) Return(_a0 http.Response) *Response_AssertConflict_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertConflict_Call) RunAndReturn(run func() http.Response) *Response_AssertConflict_Call {
	_c.Call.Return(run)
	return _c
}

// AssertCookie provides a mock function with given fields: name, value
func (_m *Response) AssertCookie(name string, value string) http.Response {
	ret := _m.Called(name, value)

	if len(ret) == 0 {
		panic("no return value specified for AssertCookie")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(string, string) http.Response); ok {
		r0 = rf(name, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertCookie_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertCookie'
type Response_AssertCookie_Call struct {
	*mock.Call
}

// AssertCookie is a helper method to define mock.On call
//   - name string
//   - value string
func (_e *Response_Expecter) AssertCookie(name interface{}, value interface{}) *Response_AssertCookie_Call {
	return &Response_AssertCookie_Call{Call: _e.mock.On("AssertCookie", name, value)}
}

func (_c *Response_AssertCookie_Call) Run(run func(name string, value string)) *Response_AssertCookie_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Response_AssertCookie_Call) Return(_a0 http.Response) *Response_AssertCookie_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertCookie_Call) RunAndReturn(run func(string, string) http.Response) *Response_AssertCookie_Call {
	_c.Call.Return(run)
	return _c
}

// AssertCookieExpired provides a mock function with given fields: _a0
func (_m *Response) AssertCookieExpired(_a0 string) http.Response {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertCookieExpired")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(string) http.Response); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertCookieExpired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertCookieExpired'
type Response_AssertCookieExpired_Call struct {
	*mock.Call
}

// AssertCookieExpired is a helper method to define mock.On call
//   - _a0 string
func (_e *Response_Expecter) AssertCookieExpired(_a0 interface{}) *Response_AssertCookieExpired_Call {
	return &Response_AssertCookieExpired_Call{Call: _e.mock.On("AssertCookieExpired", _a0)}
}

func (_c *Response_AssertCookieExpired_Call) Run(run func(_a0 string)) *Response_AssertCookieExpired_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Response_AssertCookieExpired_Call) Return(_a0 http.Response) *Response_AssertCookieExpired_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertCookieExpired_Call) RunAndReturn(run func(string) http.Response) *Response_AssertCookieExpired_Call {
	_c.Call.Return(run)
	return _c
}

// AssertCookieMissing provides a mock function with given fields: _a0
func (_m *Response) AssertCookieMissing(_a0 string) http.Response {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertCookieMissing")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(string) http.Response); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertCookieMissing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertCookieMissing'
type Response_AssertCookieMissing_Call struct {
	*mock.Call
}

// AssertCookieMissing is a helper method to define mock.On call
//   - _a0 string
func (_e *Response_Expecter) AssertCookieMissing(_a0 interface{}) *Response_AssertCookieMissing_Call {
	return &Response_AssertCookieMissing_Call{Call: _e.mock.On("AssertCookieMissing", _a0)}
}

func (_c *Response_AssertCookieMissing_Call) Run(run func(_a0 string)) *Response_AssertCookieMissing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Response_AssertCookieMissing_Call) Return(_a0 http.Response) *Response_AssertCookieMissing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertCookieMissing_Call) RunAndReturn(run func(string) http.Response) *Response_AssertCookieMissing_Call {
	_c.Call.Return(run)
	return _c
}

// AssertCookieNotExpired provides a mock function with given fields: _a0
func (_m *Response) AssertCookieNotExpired(_a0 string) http.Response {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertCookieNotExpired")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(string) http.Response); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertCookieNotExpired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertCookieNotExpired'
type Response_AssertCookieNotExpired_Call struct {
	*mock.Call
}

// AssertCookieNotExpired is a helper method to define mock.On call
//   - _a0 string
func (_e *Response_Expecter) AssertCookieNotExpired(_a0 interface{}) *Response_AssertCookieNotExpired_Call {
	return &Response_AssertCookieNotExpired_Call{Call: _e.mock.On("AssertCookieNotExpired", _a0)}
}

func (_c *Response_AssertCookieNotExpired_Call) Run(run func(_a0 string)) *Response_AssertCookieNotExpired_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Response_AssertCookieNotExpired_Call) Return(_a0 http.Response) *Response_AssertCookieNotExpired_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertCookieNotExpired_Call) RunAndReturn(run func(string) http.Response) *Response_AssertCookieNotExpired_Call {
	_c.Call.Return(run)
	return _c
}

// AssertCreated provides a mock function with no fields
func (_m *Response) AssertCreated() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertCreated")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertCreated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertCreated'
type Response_AssertCreated_Call struct {
	*mock.Call
}

// AssertCreated is a helper method to define mock.On call
func (_e *Response_Expecter) AssertCreated() *Response_AssertCreated_Call {
	return &Response_AssertCreated_Call{Call: _e.mock.On("AssertCreated")}
}

func (_c *Response_AssertCreated_Call) Run(run func()) *Response_AssertCreated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertCreated_Call) Return(_a0 http.Response) *Response_AssertCreated_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertCreated_Call) RunAndReturn(run func() http.Response) *Response_AssertCreated_Call {
	_c.Call.Return(run)
	return _c
}

// AssertDontSee provides a mock function with given fields: value, escaped
func (_m *Response) AssertDontSee(value []string, escaped ...bool) http.Response {
	_va := make([]interface{}, len(escaped))
	for _i := range escaped {
		_va[_i] = escaped[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssertDontSee")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func([]string, ...bool) http.Response); ok {
		r0 = rf(value, escaped...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertDontSee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertDontSee'
type Response_AssertDontSee_Call struct {
	*mock.Call
}

// AssertDontSee is a helper method to define mock.On call
//   - value []string
//   - escaped ...bool
func (_e *Response_Expecter) AssertDontSee(value interface{}, escaped ...interface{}) *Response_AssertDontSee_Call {
	return &Response_AssertDontSee_Call{Call: _e.mock.On("AssertDontSee",
		append([]interface{}{value}, escaped...)...)}
}

func (_c *Response_AssertDontSee_Call) Run(run func(value []string, escaped ...bool)) *Response_AssertDontSee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]bool, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(bool)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *Response_AssertDontSee_Call) Return(_a0 http.Response) *Response_AssertDontSee_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertDontSee_Call) RunAndReturn(run func([]string, ...bool) http.Response) *Response_AssertDontSee_Call {
	_c.Call.Return(run)
	return _c
}

// AssertExactJson provides a mock function with given fields: _a0
func (_m *Response) AssertExactJson(_a0 map[string]interface{}) http.Response {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertExactJson")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(map[string]interface{}) http.Response); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertExactJson_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertExactJson'
type Response_AssertExactJson_Call struct {
	*mock.Call
}

// AssertExactJson is a helper method to define mock.On call
//   - _a0 map[string]interface{}
func (_e *Response_Expecter) AssertExactJson(_a0 interface{}) *Response_AssertExactJson_Call {
	return &Response_AssertExactJson_Call{Call: _e.mock.On("AssertExactJson", _a0)}
}

func (_c *Response_AssertExactJson_Call) Run(run func(_a0 map[string]interface{})) *Response_AssertExactJson_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *Response_AssertExactJson_Call) Return(_a0 http.Response) *Response_AssertExactJson_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertExactJson_Call) RunAndReturn(run func(map[string]interface{}) http.Response) *Response_AssertExactJson_Call {
	_c.Call.Return(run)
	return _c
}

// AssertFluentJson provides a mock function with given fields: _a0
func (_m *Response) AssertFluentJson(_a0 func(http.AssertableJSON)) http.Response {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertFluentJson")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(func(http.AssertableJSON)) http.Response); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertFluentJson_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertFluentJson'
type Response_AssertFluentJson_Call struct {
	*mock.Call
}

// AssertFluentJson is a helper method to define mock.On call
//   - _a0 func(http.AssertableJSON)
func (_e *Response_Expecter) AssertFluentJson(_a0 interface{}) *Response_AssertFluentJson_Call {
	return &Response_AssertFluentJson_Call{Call: _e.mock.On("AssertFluentJson", _a0)}
}

func (_c *Response_AssertFluentJson_Call) Run(run func(_a0 func(http.AssertableJSON))) *Response_AssertFluentJson_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(func(http.AssertableJSON)))
	})
	return _c
}

func (_c *Response_AssertFluentJson_Call) Return(_a0 http.Response) *Response_AssertFluentJson_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertFluentJson_Call) RunAndReturn(run func(func(http.AssertableJSON)) http.Response) *Response_AssertFluentJson_Call {
	_c.Call.Return(run)
	return _c
}

// AssertForbidden provides a mock function with no fields
func (_m *Response) AssertForbidden() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertForbidden")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertForbidden_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertForbidden'
type Response_AssertForbidden_Call struct {
	*mock.Call
}

// AssertForbidden is a helper method to define mock.On call
func (_e *Response_Expecter) AssertForbidden() *Response_AssertForbidden_Call {
	return &Response_AssertForbidden_Call{Call: _e.mock.On("AssertForbidden")}
}

func (_c *Response_AssertForbidden_Call) Run(run func()) *Response_AssertForbidden_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertForbidden_Call) Return(_a0 http.Response) *Response_AssertForbidden_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertForbidden_Call) RunAndReturn(run func() http.Response) *Response_AssertForbidden_Call {
	_c.Call.Return(run)
	return _c
}

// AssertFound provides a mock function with no fields
func (_m *Response) AssertFound() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertFound")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertFound_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertFound'
type Response_AssertFound_Call struct {
	*mock.Call
}

// AssertFound is a helper method to define mock.On call
func (_e *Response_Expecter) AssertFound() *Response_AssertFound_Call {
	return &Response_AssertFound_Call{Call: _e.mock.On("AssertFound")}
}

func (_c *Response_AssertFound_Call) Run(run func()) *Response_AssertFound_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertFound_Call) Return(_a0 http.Response) *Response_AssertFound_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertFound_Call) RunAndReturn(run func() http.Response) *Response_AssertFound_Call {
	_c.Call.Return(run)
	return _c
}

// AssertGone provides a mock function with no fields
func (_m *Response) AssertGone() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertGone")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertGone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertGone'
type Response_AssertGone_Call struct {
	*mock.Call
}

// AssertGone is a helper method to define mock.On call
func (_e *Response_Expecter) AssertGone() *Response_AssertGone_Call {
	return &Response_AssertGone_Call{Call: _e.mock.On("AssertGone")}
}

func (_c *Response_AssertGone_Call) Run(run func()) *Response_AssertGone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertGone_Call) Return(_a0 http.Response) *Response_AssertGone_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertGone_Call) RunAndReturn(run func() http.Response) *Response_AssertGone_Call {
	_c.Call.Return(run)
	return _c
}

// AssertHeader provides a mock function with given fields: headerName, value
func (_m *Response) AssertHeader(headerName string, value string) http.Response {
	ret := _m.Called(headerName, value)

	if len(ret) == 0 {
		panic("no return value specified for AssertHeader")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(string, string) http.Response); ok {
		r0 = rf(headerName, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertHeader'
type Response_AssertHeader_Call struct {
	*mock.Call
}

// AssertHeader is a helper method to define mock.On call
//   - headerName string
//   - value string
func (_e *Response_Expecter) AssertHeader(headerName interface{}, value interface{}) *Response_AssertHeader_Call {
	return &Response_AssertHeader_Call{Call: _e.mock.On("AssertHeader", headerName, value)}
}

func (_c *Response_AssertHeader_Call) Run(run func(headerName string, value string)) *Response_AssertHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Response_AssertHeader_Call) Return(_a0 http.Response) *Response_AssertHeader_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertHeader_Call) RunAndReturn(run func(string, string) http.Response) *Response_AssertHeader_Call {
	_c.Call.Return(run)
	return _c
}

// AssertHeaderMissing provides a mock function with given fields: _a0
func (_m *Response) AssertHeaderMissing(_a0 string) http.Response {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertHeaderMissing")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(string) http.Response); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertHeaderMissing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertHeaderMissing'
type Response_AssertHeaderMissing_Call struct {
	*mock.Call
}

// AssertHeaderMissing is a helper method to define mock.On call
//   - _a0 string
func (_e *Response_Expecter) AssertHeaderMissing(_a0 interface{}) *Response_AssertHeaderMissing_Call {
	return &Response_AssertHeaderMissing_Call{Call: _e.mock.On("AssertHeaderMissing", _a0)}
}

func (_c *Response_AssertHeaderMissing_Call) Run(run func(_a0 string)) *Response_AssertHeaderMissing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Response_AssertHeaderMissing_Call) Return(_a0 http.Response) *Response_AssertHeaderMissing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertHeaderMissing_Call) RunAndReturn(run func(string) http.Response) *Response_AssertHeaderMissing_Call {
	_c.Call.Return(run)
	return _c
}

// AssertInternalServerError provides a mock function with no fields
func (_m *Response) AssertInternalServerError() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertInternalServerError")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertInternalServerError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertInternalServerError'
type Response_AssertInternalServerError_Call struct {
	*mock.Call
}

// AssertInternalServerError is a helper method to define mock.On call
func (_e *Response_Expecter) AssertInternalServerError() *Response_AssertInternalServerError_Call {
	return &Response_AssertInternalServerError_Call{Call: _e.mock.On("AssertInternalServerError")}
}

func (_c *Response_AssertInternalServerError_Call) Run(run func()) *Response_AssertInternalServerError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertInternalServerError_Call) Return(_a0 http.Response) *Response_AssertInternalServerError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertInternalServerError_Call) RunAndReturn(run func() http.Response) *Response_AssertInternalServerError_Call {
	_c.Call.Return(run)
	return _c
}

// AssertJson provides a mock function with given fields: _a0
func (_m *Response) AssertJson(_a0 map[string]interface{}) http.Response {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertJson")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(map[string]interface{}) http.Response); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertJson_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertJson'
type Response_AssertJson_Call struct {
	*mock.Call
}

// AssertJson is a helper method to define mock.On call
//   - _a0 map[string]interface{}
func (_e *Response_Expecter) AssertJson(_a0 interface{}) *Response_AssertJson_Call {
	return &Response_AssertJson_Call{Call: _e.mock.On("AssertJson", _a0)}
}

func (_c *Response_AssertJson_Call) Run(run func(_a0 map[string]interface{})) *Response_AssertJson_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *Response_AssertJson_Call) Return(_a0 http.Response) *Response_AssertJson_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertJson_Call) RunAndReturn(run func(map[string]interface{}) http.Response) *Response_AssertJson_Call {
	_c.Call.Return(run)
	return _c
}

// AssertJsonMissing provides a mock function with given fields: _a0
func (_m *Response) AssertJsonMissing(_a0 map[string]interface{}) http.Response {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertJsonMissing")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(map[string]interface{}) http.Response); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertJsonMissing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertJsonMissing'
type Response_AssertJsonMissing_Call struct {
	*mock.Call
}

// AssertJsonMissing is a helper method to define mock.On call
//   - _a0 map[string]interface{}
func (_e *Response_Expecter) AssertJsonMissing(_a0 interface{}) *Response_AssertJsonMissing_Call {
	return &Response_AssertJsonMissing_Call{Call: _e.mock.On("AssertJsonMissing", _a0)}
}

func (_c *Response_AssertJsonMissing_Call) Run(run func(_a0 map[string]interface{})) *Response_AssertJsonMissing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *Response_AssertJsonMissing_Call) Return(_a0 http.Response) *Response_AssertJsonMissing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertJsonMissing_Call) RunAndReturn(run func(map[string]interface{}) http.Response) *Response_AssertJsonMissing_Call {
	_c.Call.Return(run)
	return _c
}

// AssertMethodNotAllowed provides a mock function with no fields
func (_m *Response) AssertMethodNotAllowed() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertMethodNotAllowed")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertMethodNotAllowed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertMethodNotAllowed'
type Response_AssertMethodNotAllowed_Call struct {
	*mock.Call
}

// AssertMethodNotAllowed is a helper method to define mock.On call
func (_e *Response_Expecter) AssertMethodNotAllowed() *Response_AssertMethodNotAllowed_Call {
	return &Response_AssertMethodNotAllowed_Call{Call: _e.mock.On("AssertMethodNotAllowed")}
}

func (_c *Response_AssertMethodNotAllowed_Call) Run(run func()) *Response_AssertMethodNotAllowed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertMethodNotAllowed_Call) Return(_a0 http.Response) *Response_AssertMethodNotAllowed_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertMethodNotAllowed_Call) RunAndReturn(run func() http.Response) *Response_AssertMethodNotAllowed_Call {
	_c.Call.Return(run)
	return _c
}

// AssertMovedPermanently provides a mock function with no fields
func (_m *Response) AssertMovedPermanently() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertMovedPermanently")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertMovedPermanently_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertMovedPermanently'
type Response_AssertMovedPermanently_Call struct {
	*mock.Call
}

// AssertMovedPermanently is a helper method to define mock.On call
func (_e *Response_Expecter) AssertMovedPermanently() *Response_AssertMovedPermanently_Call {
	return &Response_AssertMovedPermanently_Call{Call: _e.mock.On("AssertMovedPermanently")}
}

func (_c *Response_AssertMovedPermanently_Call) Run(run func()) *Response_AssertMovedPermanently_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertMovedPermanently_Call) Return(_a0 http.Response) *Response_AssertMovedPermanently_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertMovedPermanently_Call) RunAndReturn(run func() http.Response) *Response_AssertMovedPermanently_Call {
	_c.Call.Return(run)
	return _c
}

// AssertNoContent provides a mock function with given fields: status
func (_m *Response) AssertNoContent(status ...int) http.Response {
	_va := make([]interface{}, len(status))
	for _i := range status {
		_va[_i] = status[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssertNoContent")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(...int) http.Response); ok {
		r0 = rf(status...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertNoContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertNoContent'
type Response_AssertNoContent_Call struct {
	*mock.Call
}

// AssertNoContent is a helper method to define mock.On call
//   - status ...int
func (_e *Response_Expecter) AssertNoContent(status ...interface{}) *Response_AssertNoContent_Call {
	return &Response_AssertNoContent_Call{Call: _e.mock.On("AssertNoContent",
		append([]interface{}{}, status...)...)}
}

func (_c *Response_AssertNoContent_Call) Run(run func(status ...int)) *Response_AssertNoContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Response_AssertNoContent_Call) Return(_a0 http.Response) *Response_AssertNoContent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertNoContent_Call) RunAndReturn(run func(...int) http.Response) *Response_AssertNoContent_Call {
	_c.Call.Return(run)
	return _c
}

// AssertNotAcceptable provides a mock function with no fields
func (_m *Response) AssertNotAcceptable() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertNotAcceptable")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertNotAcceptable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertNotAcceptable'
type Response_AssertNotAcceptable_Call struct {
	*mock.Call
}

// AssertNotAcceptable is a helper method to define mock.On call
func (_e *Response_Expecter) AssertNotAcceptable() *Response_AssertNotAcceptable_Call {
	return &Response_AssertNotAcceptable_Call{Call: _e.mock.On("AssertNotAcceptable")}
}

func (_c *Response_AssertNotAcceptable_Call) Run(run func()) *Response_AssertNotAcceptable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertNotAcceptable_Call) Return(_a0 http.Response) *Response_AssertNotAcceptable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertNotAcceptable_Call) RunAndReturn(run func() http.Response) *Response_AssertNotAcceptable_Call {
	_c.Call.Return(run)
	return _c
}

// AssertNotFound provides a mock function with no fields
func (_m *Response) AssertNotFound() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertNotFound")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertNotFound_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertNotFound'
type Response_AssertNotFound_Call struct {
	*mock.Call
}

// AssertNotFound is a helper method to define mock.On call
func (_e *Response_Expecter) AssertNotFound() *Response_AssertNotFound_Call {
	return &Response_AssertNotFound_Call{Call: _e.mock.On("AssertNotFound")}
}

func (_c *Response_AssertNotFound_Call) Run(run func()) *Response_AssertNotFound_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertNotFound_Call) Return(_a0 http.Response) *Response_AssertNotFound_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertNotFound_Call) RunAndReturn(run func() http.Response) *Response_AssertNotFound_Call {
	_c.Call.Return(run)
	return _c
}

// AssertNotModified provides a mock function with no fields
func (_m *Response) AssertNotModified() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertNotModified")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertNotModified_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertNotModified'
type Response_AssertNotModified_Call struct {
	*mock.Call
}

// AssertNotModified is a helper method to define mock.On call
func (_e *Response_Expecter) AssertNotModified() *Response_AssertNotModified_Call {
	return &Response_AssertNotModified_Call{Call: _e.mock.On("AssertNotModified")}
}

func (_c *Response_AssertNotModified_Call) Run(run func()) *Response_AssertNotModified_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertNotModified_Call) Return(_a0 http.Response) *Response_AssertNotModified_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertNotModified_Call) RunAndReturn(run func() http.Response) *Response_AssertNotModified_Call {
	_c.Call.Return(run)
	return _c
}

// AssertOk provides a mock function with no fields
func (_m *Response) AssertOk() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertOk")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertOk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertOk'
type Response_AssertOk_Call struct {
	*mock.Call
}

// AssertOk is a helper method to define mock.On call
func (_e *Response_Expecter) AssertOk() *Response_AssertOk_Call {
	return &Response_AssertOk_Call{Call: _e.mock.On("AssertOk")}
}

func (_c *Response_AssertOk_Call) Run(run func()) *Response_AssertOk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertOk_Call) Return(_a0 http.Response) *Response_AssertOk_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertOk_Call) RunAndReturn(run func() http.Response) *Response_AssertOk_Call {
	_c.Call.Return(run)
	return _c
}

// AssertPartialContent provides a mock function with no fields
func (_m *Response) AssertPartialContent() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertPartialContent")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertPartialContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertPartialContent'
type Response_AssertPartialContent_Call struct {
	*mock.Call
}

// AssertPartialContent is a helper method to define mock.On call
func (_e *Response_Expecter) AssertPartialContent() *Response_AssertPartialContent_Call {
	return &Response_AssertPartialContent_Call{Call: _e.mock.On("AssertPartialContent")}
}

func (_c *Response_AssertPartialContent_Call) Run(run func()) *Response_AssertPartialContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertPartialContent_Call) Return(_a0 http.Response) *Response_AssertPartialContent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertPartialContent_Call) RunAndReturn(run func() http.Response) *Response_AssertPartialContent_Call {
	_c.Call.Return(run)
	return _c
}

// AssertPaymentRequired provides a mock function with no fields
func (_m *Response) AssertPaymentRequired() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertPaymentRequired")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertPaymentRequired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertPaymentRequired'
type Response_AssertPaymentRequired_Call struct {
	*mock.Call
}

// AssertPaymentRequired is a helper method to define mock.On call
func (_e *Response_Expecter) AssertPaymentRequired() *Response_AssertPaymentRequired_Call {
	return &Response_AssertPaymentRequired_Call{Call: _e.mock.On("AssertPaymentRequired")}
}

func (_c *Response_AssertPaymentRequired_Call) Run(run func()) *Response_AssertPaymentRequired_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertPaymentRequired_Call) Return(_a0 http.Response) *Response_AssertPaymentRequired_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertPaymentRequired_Call) RunAndReturn(run func() http.Response) *Response_AssertPaymentRequired_Call {
	_c.Call.Return(run)
	return _c
}

// AssertRequestTimeout provides a mock function with no fields
func (_m *Response) AssertRequestTimeout() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertRequestTimeout")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertRequestTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertRequestTimeout'
type Response_AssertRequestTimeout_Call struct {
	*mock.Call
}

// AssertRequestTimeout is a helper method to define mock.On call
func (_e *Response_Expecter) AssertRequestTimeout() *Response_AssertRequestTimeout_Call {
	return &Response_AssertRequestTimeout_Call{Call: _e.mock.On("AssertRequestTimeout")}
}

func (_c *Response_AssertRequestTimeout_Call) Run(run func()) *Response_AssertRequestTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertRequestTimeout_Call) Return(_a0 http.Response) *Response_AssertRequestTimeout_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertRequestTimeout_Call) RunAndReturn(run func() http.Response) *Response_AssertRequestTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// AssertSee provides a mock function with given fields: value, escaped
func (_m *Response) AssertSee(value []string, escaped ...bool) http.Response {
	_va := make([]interface{}, len(escaped))
	for _i := range escaped {
		_va[_i] = escaped[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssertSee")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func([]string, ...bool) http.Response); ok {
		r0 = rf(value, escaped...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertSee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertSee'
type Response_AssertSee_Call struct {
	*mock.Call
}

// AssertSee is a helper method to define mock.On call
//   - value []string
//   - escaped ...bool
func (_e *Response_Expecter) AssertSee(value interface{}, escaped ...interface{}) *Response_AssertSee_Call {
	return &Response_AssertSee_Call{Call: _e.mock.On("AssertSee",
		append([]interface{}{value}, escaped...)...)}
}

func (_c *Response_AssertSee_Call) Run(run func(value []string, escaped ...bool)) *Response_AssertSee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]bool, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(bool)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *Response_AssertSee_Call) Return(_a0 http.Response) *Response_AssertSee_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertSee_Call) RunAndReturn(run func([]string, ...bool) http.Response) *Response_AssertSee_Call {
	_c.Call.Return(run)
	return _c
}

// AssertSeeInOrder provides a mock function with given fields: value, escaped
func (_m *Response) AssertSeeInOrder(value []string, escaped ...bool) http.Response {
	_va := make([]interface{}, len(escaped))
	for _i := range escaped {
		_va[_i] = escaped[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssertSeeInOrder")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func([]string, ...bool) http.Response); ok {
		r0 = rf(value, escaped...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertSeeInOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertSeeInOrder'
type Response_AssertSeeInOrder_Call struct {
	*mock.Call
}

// AssertSeeInOrder is a helper method to define mock.On call
//   - value []string
//   - escaped ...bool
func (_e *Response_Expecter) AssertSeeInOrder(value interface{}, escaped ...interface{}) *Response_AssertSeeInOrder_Call {
	return &Response_AssertSeeInOrder_Call{Call: _e.mock.On("AssertSeeInOrder",
		append([]interface{}{value}, escaped...)...)}
}

func (_c *Response_AssertSeeInOrder_Call) Run(run func(value []string, escaped ...bool)) *Response_AssertSeeInOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]bool, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(bool)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *Response_AssertSeeInOrder_Call) Return(_a0 http.Response) *Response_AssertSeeInOrder_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertSeeInOrder_Call) RunAndReturn(run func([]string, ...bool) http.Response) *Response_AssertSeeInOrder_Call {
	_c.Call.Return(run)
	return _c
}

// AssertServerError provides a mock function with no fields
func (_m *Response) AssertServerError() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertServerError")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertServerError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertServerError'
type Response_AssertServerError_Call struct {
	*mock.Call
}

// AssertServerError is a helper method to define mock.On call
func (_e *Response_Expecter) AssertServerError() *Response_AssertServerError_Call {
	return &Response_AssertServerError_Call{Call: _e.mock.On("AssertServerError")}
}

func (_c *Response_AssertServerError_Call) Run(run func()) *Response_AssertServerError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertServerError_Call) Return(_a0 http.Response) *Response_AssertServerError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertServerError_Call) RunAndReturn(run func() http.Response) *Response_AssertServerError_Call {
	_c.Call.Return(run)
	return _c
}

// AssertServiceUnavailable provides a mock function with no fields
func (_m *Response) AssertServiceUnavailable() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertServiceUnavailable")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertServiceUnavailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertServiceUnavailable'
type Response_AssertServiceUnavailable_Call struct {
	*mock.Call
}

// AssertServiceUnavailable is a helper method to define mock.On call
func (_e *Response_Expecter) AssertServiceUnavailable() *Response_AssertServiceUnavailable_Call {
	return &Response_AssertServiceUnavailable_Call{Call: _e.mock.On("AssertServiceUnavailable")}
}

func (_c *Response_AssertServiceUnavailable_Call) Run(run func()) *Response_AssertServiceUnavailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertServiceUnavailable_Call) Return(_a0 http.Response) *Response_AssertServiceUnavailable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertServiceUnavailable_Call) RunAndReturn(run func() http.Response) *Response_AssertServiceUnavailable_Call {
	_c.Call.Return(run)
	return _c
}

// AssertStatus provides a mock function with given fields: status
func (_m *Response) AssertStatus(status int) http.Response {
	ret := _m.Called(status)

	if len(ret) == 0 {
		panic("no return value specified for AssertStatus")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func(int) http.Response); ok {
		r0 = rf(status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertStatus'
type Response_AssertStatus_Call struct {
	*mock.Call
}

// AssertStatus is a helper method to define mock.On call
//   - status int
func (_e *Response_Expecter) AssertStatus(status interface{}) *Response_AssertStatus_Call {
	return &Response_AssertStatus_Call{Call: _e.mock.On("AssertStatus", status)}
}

func (_c *Response_AssertStatus_Call) Run(run func(status int)) *Response_AssertStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Response_AssertStatus_Call) Return(_a0 http.Response) *Response_AssertStatus_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertStatus_Call) RunAndReturn(run func(int) http.Response) *Response_AssertStatus_Call {
	_c.Call.Return(run)
	return _c
}

// AssertSuccessful provides a mock function with no fields
func (_m *Response) AssertSuccessful() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertSuccessful")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertSuccessful_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertSuccessful'
type Response_AssertSuccessful_Call struct {
	*mock.Call
}

// AssertSuccessful is a helper method to define mock.On call
func (_e *Response_Expecter) AssertSuccessful() *Response_AssertSuccessful_Call {
	return &Response_AssertSuccessful_Call{Call: _e.mock.On("AssertSuccessful")}
}

func (_c *Response_AssertSuccessful_Call) Run(run func()) *Response_AssertSuccessful_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertSuccessful_Call) Return(_a0 http.Response) *Response_AssertSuccessful_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertSuccessful_Call) RunAndReturn(run func() http.Response) *Response_AssertSuccessful_Call {
	_c.Call.Return(run)
	return _c
}

// AssertTemporaryRedirect provides a mock function with no fields
func (_m *Response) AssertTemporaryRedirect() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertTemporaryRedirect")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertTemporaryRedirect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertTemporaryRedirect'
type Response_AssertTemporaryRedirect_Call struct {
	*mock.Call
}

// AssertTemporaryRedirect is a helper method to define mock.On call
func (_e *Response_Expecter) AssertTemporaryRedirect() *Response_AssertTemporaryRedirect_Call {
	return &Response_AssertTemporaryRedirect_Call{Call: _e.mock.On("AssertTemporaryRedirect")}
}

func (_c *Response_AssertTemporaryRedirect_Call) Run(run func()) *Response_AssertTemporaryRedirect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertTemporaryRedirect_Call) Return(_a0 http.Response) *Response_AssertTemporaryRedirect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertTemporaryRedirect_Call) RunAndReturn(run func() http.Response) *Response_AssertTemporaryRedirect_Call {
	_c.Call.Return(run)
	return _c
}

// AssertTooManyRequests provides a mock function with no fields
func (_m *Response) AssertTooManyRequests() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertTooManyRequests")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertTooManyRequests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertTooManyRequests'
type Response_AssertTooManyRequests_Call struct {
	*mock.Call
}

// AssertTooManyRequests is a helper method to define mock.On call
func (_e *Response_Expecter) AssertTooManyRequests() *Response_AssertTooManyRequests_Call {
	return &Response_AssertTooManyRequests_Call{Call: _e.mock.On("AssertTooManyRequests")}
}

func (_c *Response_AssertTooManyRequests_Call) Run(run func()) *Response_AssertTooManyRequests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertTooManyRequests_Call) Return(_a0 http.Response) *Response_AssertTooManyRequests_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertTooManyRequests_Call) RunAndReturn(run func() http.Response) *Response_AssertTooManyRequests_Call {
	_c.Call.Return(run)
	return _c
}

// AssertUnauthorized provides a mock function with no fields
func (_m *Response) AssertUnauthorized() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertUnauthorized")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertUnauthorized_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertUnauthorized'
type Response_AssertUnauthorized_Call struct {
	*mock.Call
}

// AssertUnauthorized is a helper method to define mock.On call
func (_e *Response_Expecter) AssertUnauthorized() *Response_AssertUnauthorized_Call {
	return &Response_AssertUnauthorized_Call{Call: _e.mock.On("AssertUnauthorized")}
}

func (_c *Response_AssertUnauthorized_Call) Run(run func()) *Response_AssertUnauthorized_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertUnauthorized_Call) Return(_a0 http.Response) *Response_AssertUnauthorized_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertUnauthorized_Call) RunAndReturn(run func() http.Response) *Response_AssertUnauthorized_Call {
	_c.Call.Return(run)
	return _c
}

// AssertUnprocessableEntity provides a mock function with no fields
func (_m *Response) AssertUnprocessableEntity() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertUnprocessableEntity")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertUnprocessableEntity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertUnprocessableEntity'
type Response_AssertUnprocessableEntity_Call struct {
	*mock.Call
}

// AssertUnprocessableEntity is a helper method to define mock.On call
func (_e *Response_Expecter) AssertUnprocessableEntity() *Response_AssertUnprocessableEntity_Call {
	return &Response_AssertUnprocessableEntity_Call{Call: _e.mock.On("AssertUnprocessableEntity")}
}

func (_c *Response_AssertUnprocessableEntity_Call) Run(run func()) *Response_AssertUnprocessableEntity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertUnprocessableEntity_Call) Return(_a0 http.Response) *Response_AssertUnprocessableEntity_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertUnprocessableEntity_Call) RunAndReturn(run func() http.Response) *Response_AssertUnprocessableEntity_Call {
	_c.Call.Return(run)
	return _c
}

// AssertUnsupportedMediaType provides a mock function with no fields
func (_m *Response) AssertUnsupportedMediaType() http.Response {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertUnsupportedMediaType")
	}

	var r0 http.Response
	if rf, ok := ret.Get(0).(func() http.Response); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Response)
		}
	}

	return r0
}

// Response_AssertUnsupportedMediaType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertUnsupportedMediaType'
type Response_AssertUnsupportedMediaType_Call struct {
	*mock.Call
}

// AssertUnsupportedMediaType is a helper method to define mock.On call
func (_e *Response_Expecter) AssertUnsupportedMediaType() *Response_AssertUnsupportedMediaType_Call {
	return &Response_AssertUnsupportedMediaType_Call{Call: _e.mock.On("AssertUnsupportedMediaType")}
}

func (_c *Response_AssertUnsupportedMediaType_Call) Run(run func()) *Response_AssertUnsupportedMediaType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_AssertUnsupportedMediaType_Call) Return(_a0 http.Response) *Response_AssertUnsupportedMediaType_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_AssertUnsupportedMediaType_Call) RunAndReturn(run func() http.Response) *Response_AssertUnsupportedMediaType_Call {
	_c.Call.Return(run)
	return _c
}

// Bind provides a mock function with given fields: value
func (_m *Response) Bind(value interface{}) error {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for Bind")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Response_Bind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Bind'
type Response_Bind_Call struct {
	*mock.Call
}

// Bind is a helper method to define mock.On call
//   - value interface{}
func (_e *Response_Expecter) Bind(value interface{}) *Response_Bind_Call {
	return &Response_Bind_Call{Call: _e.mock.On("Bind", value)}
}

func (_c *Response_Bind_Call) Run(run func(value interface{})) *Response_Bind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Response_Bind_Call) Return(_a0 error) *Response_Bind_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_Bind_Call) RunAndReturn(run func(interface{}) error) *Response_Bind_Call {
	_c.Call.Return(run)
	return _c
}

// Content provides a mock function with no fields
func (_m *Response) Content() (string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Content")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Response_Content_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Content'
type Response_Content_Call struct {
	*mock.Call
}

// Content is a helper method to define mock.On call
func (_e *Response_Expecter) Content() *Response_Content_Call {
	return &Response_Content_Call{Call: _e.mock.On("Content")}
}

func (_c *Response_Content_Call) Run(run func()) *Response_Content_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_Content_Call) Return(_a0 string, _a1 error) *Response_Content_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Response_Content_Call) RunAndReturn(run func() (string, error)) *Response_Content_Call {
	_c.Call.Return(run)
	return _c
}

// Cookie provides a mock function with given fields: name
func (_m *Response) Cookie(name string) *nethttp.Cookie {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Cookie")
	}

	var r0 *nethttp.Cookie
	if rf, ok := ret.Get(0).(func(string) *nethttp.Cookie); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nethttp.Cookie)
		}
	}

	return r0
}

// Response_Cookie_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cookie'
type Response_Cookie_Call struct {
	*mock.Call
}

// Cookie is a helper method to define mock.On call
//   - name string
func (_e *Response_Expecter) Cookie(name interface{}) *Response_Cookie_Call {
	return &Response_Cookie_Call{Call: _e.mock.On("Cookie", name)}
}

func (_c *Response_Cookie_Call) Run(run func(name string)) *Response_Cookie_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Response_Cookie_Call) Return(_a0 *nethttp.Cookie) *Response_Cookie_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_Cookie_Call) RunAndReturn(run func(string) *nethttp.Cookie) *Response_Cookie_Call {
	_c.Call.Return(run)
	return _c
}

// Cookies provides a mock function with no fields
func (_m *Response) Cookies() []*nethttp.Cookie {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Cookies")
	}

	var r0 []*nethttp.Cookie
	if rf, ok := ret.Get(0).(func() []*nethttp.Cookie); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*nethttp.Cookie)
		}
	}

	return r0
}

// Response_Cookies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cookies'
type Response_Cookies_Call struct {
	*mock.Call
}

// Cookies is a helper method to define mock.On call
func (_e *Response_Expecter) Cookies() *Response_Cookies_Call {
	return &Response_Cookies_Call{Call: _e.mock.On("Cookies")}
}

func (_c *Response_Cookies_Call) Run(run func()) *Response_Cookies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_Cookies_Call) Return(_a0 []*nethttp.Cookie) *Response_Cookies_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_Cookies_Call) RunAndReturn(run func() []*nethttp.Cookie) *Response_Cookies_Call {
	_c.Call.Return(run)
	return _c
}

// Headers provides a mock function with no fields
func (_m *Response) Headers() nethttp.Header {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Headers")
	}

	var r0 nethttp.Header
	if rf, ok := ret.Get(0).(func() nethttp.Header); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nethttp.Header)
		}
	}

	return r0
}

// Response_Headers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Headers'
type Response_Headers_Call struct {
	*mock.Call
}

// Headers is a helper method to define mock.On call
func (_e *Response_Expecter) Headers() *Response_Headers_Call {
	return &Response_Headers_Call{Call: _e.mock.On("Headers")}
}

func (_c *Response_Headers_Call) Run(run func()) *Response_Headers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_Headers_Call) Return(_a0 nethttp.Header) *Response_Headers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_Headers_Call) RunAndReturn(run func() nethttp.Header) *Response_Headers_Call {
	_c.Call.Return(run)
	return _c
}

// IsServerError provides a mock function with no fields
func (_m *Response) IsServerError() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsServerError")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Response_IsServerError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsServerError'
type Response_IsServerError_Call struct {
	*mock.Call
}

// IsServerError is a helper method to define mock.On call
func (_e *Response_Expecter) IsServerError() *Response_IsServerError_Call {
	return &Response_IsServerError_Call{Call: _e.mock.On("IsServerError")}
}

func (_c *Response_IsServerError_Call) Run(run func()) *Response_IsServerError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_IsServerError_Call) Return(_a0 bool) *Response_IsServerError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_IsServerError_Call) RunAndReturn(run func() bool) *Response_IsServerError_Call {
	_c.Call.Return(run)
	return _c
}

// IsSuccessful provides a mock function with no fields
func (_m *Response) IsSuccessful() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsSuccessful")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Response_IsSuccessful_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsSuccessful'
type Response_IsSuccessful_Call struct {
	*mock.Call
}

// IsSuccessful is a helper method to define mock.On call
func (_e *Response_Expecter) IsSuccessful() *Response_IsSuccessful_Call {
	return &Response_IsSuccessful_Call{Call: _e.mock.On("IsSuccessful")}
}

func (_c *Response_IsSuccessful_Call) Run(run func()) *Response_IsSuccessful_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_IsSuccessful_Call) Return(_a0 bool) *Response_IsSuccessful_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Response_IsSuccessful_Call) RunAndReturn(run func() bool) *Response_IsSuccessful_Call {
	_c.Call.Return(run)
	return _c
}

// Json provides a mock function with no fields
func (_m *Response) Json() (map[string]interface{}, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Json")
	}

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func() (map[string]interface{}, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() map[string]interface{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Response_Json_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Json'
type Response_Json_Call struct {
	*mock.Call
}

// Json is a helper method to define mock.On call
func (_e *Response_Expecter) Json() *Response_Json_Call {
	return &Response_Json_Call{Call: _e.mock.On("Json")}
}

func (_c *Response_Json_Call) Run(run func()) *Response_Json_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_Json_Call) Return(_a0 map[string]interface{}, _a1 error) *Response_Json_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Response_Json_Call) RunAndReturn(run func() (map[string]interface{}, error)) *Response_Json_Call {
	_c.Call.Return(run)
	return _c
}

// Session provides a mock function with no fields
func (_m *Response) Session() (map[string]interface{}, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Session")
	}

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func() (map[string]interface{}, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() map[string]interface{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Response_Session_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Session'
type Response_Session_Call struct {
	*mock.Call
}

// Session is a helper method to define mock.On call
func (_e *Response_Expecter) Session() *Response_Session_Call {
	return &Response_Session_Call{Call: _e.mock.On("Session")}
}

func (_c *Response_Session_Call) Run(run func()) *Response_Session_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Response_Session_Call) Return(_a0 map[string]interface{}, _a1 error) *Response_Session_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Response_Session_Call) RunAndReturn(run func() (map[string]interface{}, error)) *Response_Session_Call {
	_c.Call.Return(run)
	return _c
}

// NewResponse creates a new instance of Response. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewResponse(t interface {
	mock.TestingT
	Cleanup(func())
}) *Response {
	mock := &Response{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
