// Code generated by mockery. DO NOT EDIT.

package cache

import (
	context "context"
	time "time"

	cache "github.com/goravel/framework/contracts/cache"
	docker "github.com/goravel/framework/contracts/testing/docker"
	mock "github.com/stretchr/testify/mock"
)

// Cache is an autogenerated mock type for the Cache type
type Cache struct {
	mock.Mock
}

type Cache_Expecter struct {
	mock *mock.Mock
}

func (_m *Cache) EXPECT() *Cache_Expecter {
	return &Cache_Expecter{mock: &_m.Mock}
}

// Add provides a mock function with given fields: key, value, t
func (_m *Cache) Add(key string, value interface{}, t time.Duration) bool {
	ret := _m.Called(key, value, t)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) bool); ok {
		r0 = rf(key, value, t)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Cache_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type Cache_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - key string
//   - value interface{}
//   - t time.Duration
func (_e *Cache_Expecter) Add(key interface{}, value interface{}, t interface{}) *Cache_Add_Call {
	return &Cache_Add_Call{Call: _e.mock.On("Add", key, value, t)}
}

func (_c *Cache_Add_Call) Run(run func(key string, value interface{}, t time.Duration)) *Cache_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(time.Duration))
	})
	return _c
}

func (_c *Cache_Add_Call) Return(_a0 bool) *Cache_Add_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_Add_Call) RunAndReturn(run func(string, interface{}, time.Duration) bool) *Cache_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Decrement provides a mock function with given fields: key, value
func (_m *Cache) Decrement(key string, value ...int64) (int64, error) {
	_va := make([]interface{}, len(value))
	for _i := range value {
		_va[_i] = value[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Decrement")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...int64) (int64, error)); ok {
		return rf(key, value...)
	}
	if rf, ok := ret.Get(0).(func(string, ...int64) int64); ok {
		r0 = rf(key, value...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string, ...int64) error); ok {
		r1 = rf(key, value...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cache_Decrement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decrement'
type Cache_Decrement_Call struct {
	*mock.Call
}

// Decrement is a helper method to define mock.On call
//   - key string
//   - value ...int64
func (_e *Cache_Expecter) Decrement(key interface{}, value ...interface{}) *Cache_Decrement_Call {
	return &Cache_Decrement_Call{Call: _e.mock.On("Decrement",
		append([]interface{}{key}, value...)...)}
}

func (_c *Cache_Decrement_Call) Run(run func(key string, value ...int64)) *Cache_Decrement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Cache_Decrement_Call) Return(_a0 int64, _a1 error) *Cache_Decrement_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cache_Decrement_Call) RunAndReturn(run func(string, ...int64) (int64, error)) *Cache_Decrement_Call {
	_c.Call.Return(run)
	return _c
}

// Docker provides a mock function with no fields
func (_m *Cache) Docker() (docker.CacheDriver, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Docker")
	}

	var r0 docker.CacheDriver
	var r1 error
	if rf, ok := ret.Get(0).(func() (docker.CacheDriver, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() docker.CacheDriver); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(docker.CacheDriver)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cache_Docker_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Docker'
type Cache_Docker_Call struct {
	*mock.Call
}

// Docker is a helper method to define mock.On call
func (_e *Cache_Expecter) Docker() *Cache_Docker_Call {
	return &Cache_Docker_Call{Call: _e.mock.On("Docker")}
}

func (_c *Cache_Docker_Call) Run(run func()) *Cache_Docker_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Cache_Docker_Call) Return(_a0 docker.CacheDriver, _a1 error) *Cache_Docker_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cache_Docker_Call) RunAndReturn(run func() (docker.CacheDriver, error)) *Cache_Docker_Call {
	_c.Call.Return(run)
	return _c
}

// Flush provides a mock function with no fields
func (_m *Cache) Flush() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Cache_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type Cache_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
func (_e *Cache_Expecter) Flush() *Cache_Flush_Call {
	return &Cache_Flush_Call{Call: _e.mock.On("Flush")}
}

func (_c *Cache_Flush_Call) Run(run func()) *Cache_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Cache_Flush_Call) Return(_a0 bool) *Cache_Flush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_Flush_Call) RunAndReturn(run func() bool) *Cache_Flush_Call {
	_c.Call.Return(run)
	return _c
}

// Forever provides a mock function with given fields: key, value
func (_m *Cache) Forever(key string, value interface{}) bool {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for Forever")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, interface{}) bool); ok {
		r0 = rf(key, value)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Cache_Forever_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Forever'
type Cache_Forever_Call struct {
	*mock.Call
}

// Forever is a helper method to define mock.On call
//   - key string
//   - value interface{}
func (_e *Cache_Expecter) Forever(key interface{}, value interface{}) *Cache_Forever_Call {
	return &Cache_Forever_Call{Call: _e.mock.On("Forever", key, value)}
}

func (_c *Cache_Forever_Call) Run(run func(key string, value interface{})) *Cache_Forever_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Cache_Forever_Call) Return(_a0 bool) *Cache_Forever_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_Forever_Call) RunAndReturn(run func(string, interface{}) bool) *Cache_Forever_Call {
	_c.Call.Return(run)
	return _c
}

// Forget provides a mock function with given fields: key
func (_m *Cache) Forget(key string) bool {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Forget")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Cache_Forget_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Forget'
type Cache_Forget_Call struct {
	*mock.Call
}

// Forget is a helper method to define mock.On call
//   - key string
func (_e *Cache_Expecter) Forget(key interface{}) *Cache_Forget_Call {
	return &Cache_Forget_Call{Call: _e.mock.On("Forget", key)}
}

func (_c *Cache_Forget_Call) Run(run func(key string)) *Cache_Forget_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Cache_Forget_Call) Return(_a0 bool) *Cache_Forget_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_Forget_Call) RunAndReturn(run func(string) bool) *Cache_Forget_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: key, def
func (_m *Cache) Get(key string, def ...interface{}) interface{} {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, def...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) interface{}); ok {
		r0 = rf(key, def...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// Cache_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Cache_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key string
//   - def ...interface{}
func (_e *Cache_Expecter) Get(key interface{}, def ...interface{}) *Cache_Get_Call {
	return &Cache_Get_Call{Call: _e.mock.On("Get",
		append([]interface{}{key}, def...)...)}
}

func (_c *Cache_Get_Call) Run(run func(key string, def ...interface{})) *Cache_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Cache_Get_Call) Return(_a0 interface{}) *Cache_Get_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_Get_Call) RunAndReturn(run func(string, ...interface{}) interface{}) *Cache_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetBool provides a mock function with given fields: key, def
func (_m *Cache) GetBool(key string, def ...bool) bool {
	_va := make([]interface{}, len(def))
	for _i := range def {
		_va[_i] = def[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBool")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, ...bool) bool); ok {
		r0 = rf(key, def...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Cache_GetBool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBool'
type Cache_GetBool_Call struct {
	*mock.Call
}

// GetBool is a helper method to define mock.On call
//   - key string
//   - def ...bool
func (_e *Cache_Expecter) GetBool(key interface{}, def ...interface{}) *Cache_GetBool_Call {
	return &Cache_GetBool_Call{Call: _e.mock.On("GetBool",
		append([]interface{}{key}, def...)...)}
}

func (_c *Cache_GetBool_Call) Run(run func(key string, def ...bool)) *Cache_GetBool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]bool, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(bool)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Cache_GetBool_Call) Return(_a0 bool) *Cache_GetBool_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_GetBool_Call) RunAndReturn(run func(string, ...bool) bool) *Cache_GetBool_Call {
	_c.Call.Return(run)
	return _c
}

// GetInt provides a mock function with given fields: key, def
func (_m *Cache) GetInt(key string, def ...int) int {
	_va := make([]interface{}, len(def))
	for _i := range def {
		_va[_i] = def[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInt")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func(string, ...int) int); ok {
		r0 = rf(key, def...)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Cache_GetInt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInt'
type Cache_GetInt_Call struct {
	*mock.Call
}

// GetInt is a helper method to define mock.On call
//   - key string
//   - def ...int
func (_e *Cache_Expecter) GetInt(key interface{}, def ...interface{}) *Cache_GetInt_Call {
	return &Cache_GetInt_Call{Call: _e.mock.On("GetInt",
		append([]interface{}{key}, def...)...)}
}

func (_c *Cache_GetInt_Call) Run(run func(key string, def ...int)) *Cache_GetInt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Cache_GetInt_Call) Return(_a0 int) *Cache_GetInt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_GetInt_Call) RunAndReturn(run func(string, ...int) int) *Cache_GetInt_Call {
	_c.Call.Return(run)
	return _c
}

// GetInt64 provides a mock function with given fields: key, def
func (_m *Cache) GetInt64(key string, def ...int64) int64 {
	_va := make([]interface{}, len(def))
	for _i := range def {
		_va[_i] = def[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInt64")
	}

	var r0 int64
	if rf, ok := ret.Get(0).(func(string, ...int64) int64); ok {
		r0 = rf(key, def...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// Cache_GetInt64_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInt64'
type Cache_GetInt64_Call struct {
	*mock.Call
}

// GetInt64 is a helper method to define mock.On call
//   - key string
//   - def ...int64
func (_e *Cache_Expecter) GetInt64(key interface{}, def ...interface{}) *Cache_GetInt64_Call {
	return &Cache_GetInt64_Call{Call: _e.mock.On("GetInt64",
		append([]interface{}{key}, def...)...)}
}

func (_c *Cache_GetInt64_Call) Run(run func(key string, def ...int64)) *Cache_GetInt64_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Cache_GetInt64_Call) Return(_a0 int64) *Cache_GetInt64_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_GetInt64_Call) RunAndReturn(run func(string, ...int64) int64) *Cache_GetInt64_Call {
	_c.Call.Return(run)
	return _c
}

// GetString provides a mock function with given fields: key, def
func (_m *Cache) GetString(key string, def ...string) string {
	_va := make([]interface{}, len(def))
	for _i := range def {
		_va[_i] = def[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetString")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string, ...string) string); ok {
		r0 = rf(key, def...)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Cache_GetString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetString'
type Cache_GetString_Call struct {
	*mock.Call
}

// GetString is a helper method to define mock.On call
//   - key string
//   - def ...string
func (_e *Cache_Expecter) GetString(key interface{}, def ...interface{}) *Cache_GetString_Call {
	return &Cache_GetString_Call{Call: _e.mock.On("GetString",
		append([]interface{}{key}, def...)...)}
}

func (_c *Cache_GetString_Call) Run(run func(key string, def ...string)) *Cache_GetString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Cache_GetString_Call) Return(_a0 string) *Cache_GetString_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_GetString_Call) RunAndReturn(run func(string, ...string) string) *Cache_GetString_Call {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function with given fields: key
func (_m *Cache) Has(key string) bool {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Cache_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type Cache_Has_Call struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - key string
func (_e *Cache_Expecter) Has(key interface{}) *Cache_Has_Call {
	return &Cache_Has_Call{Call: _e.mock.On("Has", key)}
}

func (_c *Cache_Has_Call) Run(run func(key string)) *Cache_Has_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Cache_Has_Call) Return(_a0 bool) *Cache_Has_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_Has_Call) RunAndReturn(run func(string) bool) *Cache_Has_Call {
	_c.Call.Return(run)
	return _c
}

// Increment provides a mock function with given fields: key, value
func (_m *Cache) Increment(key string, value ...int64) (int64, error) {
	_va := make([]interface{}, len(value))
	for _i := range value {
		_va[_i] = value[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Increment")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...int64) (int64, error)); ok {
		return rf(key, value...)
	}
	if rf, ok := ret.Get(0).(func(string, ...int64) int64); ok {
		r0 = rf(key, value...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string, ...int64) error); ok {
		r1 = rf(key, value...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cache_Increment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Increment'
type Cache_Increment_Call struct {
	*mock.Call
}

// Increment is a helper method to define mock.On call
//   - key string
//   - value ...int64
func (_e *Cache_Expecter) Increment(key interface{}, value ...interface{}) *Cache_Increment_Call {
	return &Cache_Increment_Call{Call: _e.mock.On("Increment",
		append([]interface{}{key}, value...)...)}
}

func (_c *Cache_Increment_Call) Run(run func(key string, value ...int64)) *Cache_Increment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Cache_Increment_Call) Return(_a0 int64, _a1 error) *Cache_Increment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cache_Increment_Call) RunAndReturn(run func(string, ...int64) (int64, error)) *Cache_Increment_Call {
	_c.Call.Return(run)
	return _c
}

// Lock provides a mock function with given fields: key, t
func (_m *Cache) Lock(key string, t ...time.Duration) cache.Lock {
	_va := make([]interface{}, len(t))
	for _i := range t {
		_va[_i] = t[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Lock")
	}

	var r0 cache.Lock
	if rf, ok := ret.Get(0).(func(string, ...time.Duration) cache.Lock); ok {
		r0 = rf(key, t...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Lock)
		}
	}

	return r0
}

// Cache_Lock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Lock'
type Cache_Lock_Call struct {
	*mock.Call
}

// Lock is a helper method to define mock.On call
//   - key string
//   - t ...time.Duration
func (_e *Cache_Expecter) Lock(key interface{}, t ...interface{}) *Cache_Lock_Call {
	return &Cache_Lock_Call{Call: _e.mock.On("Lock",
		append([]interface{}{key}, t...)...)}
}

func (_c *Cache_Lock_Call) Run(run func(key string, t ...time.Duration)) *Cache_Lock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]time.Duration, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(time.Duration)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Cache_Lock_Call) Return(_a0 cache.Lock) *Cache_Lock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_Lock_Call) RunAndReturn(run func(string, ...time.Duration) cache.Lock) *Cache_Lock_Call {
	_c.Call.Return(run)
	return _c
}

// Pull provides a mock function with given fields: key, def
func (_m *Cache) Pull(key string, def ...interface{}) interface{} {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, def...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Pull")
	}

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) interface{}); ok {
		r0 = rf(key, def...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// Cache_Pull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pull'
type Cache_Pull_Call struct {
	*mock.Call
}

// Pull is a helper method to define mock.On call
//   - key string
//   - def ...interface{}
func (_e *Cache_Expecter) Pull(key interface{}, def ...interface{}) *Cache_Pull_Call {
	return &Cache_Pull_Call{Call: _e.mock.On("Pull",
		append([]interface{}{key}, def...)...)}
}

func (_c *Cache_Pull_Call) Run(run func(key string, def ...interface{})) *Cache_Pull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Cache_Pull_Call) Return(_a0 interface{}) *Cache_Pull_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_Pull_Call) RunAndReturn(run func(string, ...interface{}) interface{}) *Cache_Pull_Call {
	_c.Call.Return(run)
	return _c
}

// Put provides a mock function with given fields: key, value, t
func (_m *Cache) Put(key string, value interface{}, t time.Duration) error {
	ret := _m.Called(key, value, t)

	if len(ret) == 0 {
		panic("no return value specified for Put")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) error); ok {
		r0 = rf(key, value, t)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Cache_Put_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Put'
type Cache_Put_Call struct {
	*mock.Call
}

// Put is a helper method to define mock.On call
//   - key string
//   - value interface{}
//   - t time.Duration
func (_e *Cache_Expecter) Put(key interface{}, value interface{}, t interface{}) *Cache_Put_Call {
	return &Cache_Put_Call{Call: _e.mock.On("Put", key, value, t)}
}

func (_c *Cache_Put_Call) Run(run func(key string, value interface{}, t time.Duration)) *Cache_Put_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(time.Duration))
	})
	return _c
}

func (_c *Cache_Put_Call) Return(_a0 error) *Cache_Put_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_Put_Call) RunAndReturn(run func(string, interface{}, time.Duration) error) *Cache_Put_Call {
	_c.Call.Return(run)
	return _c
}

// Remember provides a mock function with given fields: key, ttl, callback
func (_m *Cache) Remember(key string, ttl time.Duration, callback func() (interface{}, error)) (interface{}, error) {
	ret := _m.Called(key, ttl, callback)

	if len(ret) == 0 {
		panic("no return value specified for Remember")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, time.Duration, func() (interface{}, error)) (interface{}, error)); ok {
		return rf(key, ttl, callback)
	}
	if rf, ok := ret.Get(0).(func(string, time.Duration, func() (interface{}, error)) interface{}); ok {
		r0 = rf(key, ttl, callback)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, time.Duration, func() (interface{}, error)) error); ok {
		r1 = rf(key, ttl, callback)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cache_Remember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remember'
type Cache_Remember_Call struct {
	*mock.Call
}

// Remember is a helper method to define mock.On call
//   - key string
//   - ttl time.Duration
//   - callback func()(interface{} , error)
func (_e *Cache_Expecter) Remember(key interface{}, ttl interface{}, callback interface{}) *Cache_Remember_Call {
	return &Cache_Remember_Call{Call: _e.mock.On("Remember", key, ttl, callback)}
}

func (_c *Cache_Remember_Call) Run(run func(key string, ttl time.Duration, callback func() (interface{}, error))) *Cache_Remember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Duration), args[2].(func() (interface{}, error)))
	})
	return _c
}

func (_c *Cache_Remember_Call) Return(_a0 interface{}, _a1 error) *Cache_Remember_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cache_Remember_Call) RunAndReturn(run func(string, time.Duration, func() (interface{}, error)) (interface{}, error)) *Cache_Remember_Call {
	_c.Call.Return(run)
	return _c
}

// RememberForever provides a mock function with given fields: key, callback
func (_m *Cache) RememberForever(key string, callback func() (interface{}, error)) (interface{}, error) {
	ret := _m.Called(key, callback)

	if len(ret) == 0 {
		panic("no return value specified for RememberForever")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, func() (interface{}, error)) (interface{}, error)); ok {
		return rf(key, callback)
	}
	if rf, ok := ret.Get(0).(func(string, func() (interface{}, error)) interface{}); ok {
		r0 = rf(key, callback)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, func() (interface{}, error)) error); ok {
		r1 = rf(key, callback)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cache_RememberForever_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RememberForever'
type Cache_RememberForever_Call struct {
	*mock.Call
}

// RememberForever is a helper method to define mock.On call
//   - key string
//   - callback func()(interface{} , error)
func (_e *Cache_Expecter) RememberForever(key interface{}, callback interface{}) *Cache_RememberForever_Call {
	return &Cache_RememberForever_Call{Call: _e.mock.On("RememberForever", key, callback)}
}

func (_c *Cache_RememberForever_Call) Run(run func(key string, callback func() (interface{}, error))) *Cache_RememberForever_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(func() (interface{}, error)))
	})
	return _c
}

func (_c *Cache_RememberForever_Call) Return(_a0 interface{}, _a1 error) *Cache_RememberForever_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Cache_RememberForever_Call) RunAndReturn(run func(string, func() (interface{}, error)) (interface{}, error)) *Cache_RememberForever_Call {
	_c.Call.Return(run)
	return _c
}

// Store provides a mock function with given fields: name
func (_m *Cache) Store(name string) cache.Driver {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Store")
	}

	var r0 cache.Driver
	if rf, ok := ret.Get(0).(func(string) cache.Driver); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Driver)
		}
	}

	return r0
}

// Cache_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type Cache_Store_Call struct {
	*mock.Call
}

// Store is a helper method to define mock.On call
//   - name string
func (_e *Cache_Expecter) Store(name interface{}) *Cache_Store_Call {
	return &Cache_Store_Call{Call: _e.mock.On("Store", name)}
}

func (_c *Cache_Store_Call) Run(run func(name string)) *Cache_Store_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Cache_Store_Call) Return(_a0 cache.Driver) *Cache_Store_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_Store_Call) RunAndReturn(run func(string) cache.Driver) *Cache_Store_Call {
	_c.Call.Return(run)
	return _c
}

// WithContext provides a mock function with given fields: ctx
func (_m *Cache) WithContext(ctx context.Context) cache.Driver {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WithContext")
	}

	var r0 cache.Driver
	if rf, ok := ret.Get(0).(func(context.Context) cache.Driver); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Driver)
		}
	}

	return r0
}

// Cache_WithContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithContext'
type Cache_WithContext_Call struct {
	*mock.Call
}

// WithContext is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Cache_Expecter) WithContext(ctx interface{}) *Cache_WithContext_Call {
	return &Cache_WithContext_Call{Call: _e.mock.On("WithContext", ctx)}
}

func (_c *Cache_WithContext_Call) Run(run func(ctx context.Context)) *Cache_WithContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Cache_WithContext_Call) Return(_a0 cache.Driver) *Cache_WithContext_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Cache_WithContext_Call) RunAndReturn(run func(context.Context) cache.Driver) *Cache_WithContext_Call {
	_c.Call.Return(run)
	return _c
}

// NewCache creates a new instance of Cache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *Cache {
	mock := &Cache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
