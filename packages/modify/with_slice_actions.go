package modify

import (
	"path/filepath"
	"strings"

	"github.com/dave/dst"
	"github.com/dave/dst/dstutil"

	"github.com/goravel/framework/contracts/packages/match"
	"github.com/goravel/framework/contracts/packages/modify"
	packagesmatch "github.com/goravel/framework/packages/match"
	supportfile "github.com/goravel/framework/support/file"
	"github.com/goravel/framework/support/path/internals"
)

// withSliceConfig holds configuration for adding items to a slice in foundation.Setup() chain.
type withSliceConfig struct {
	// fileName is the name of the file to create (e.g., "commands.go", "migrations.go")
	fileName string
	// withMethodName is the name of the method in foundation.Setup() chain (e.g., "WithCommands", "WithMigrations")
	withMethodName string
	// helperFuncName is the name of the helper function (e.g., "Commands", "Migrations")
	helperFuncName string
	// typePackage is the package name for the slice element type (e.g., "console", "schema")
	typePackage string
	// typeName is the type name for the slice element (e.g., "Command", "Migration")
	typeName string
	// typeImportPath is the import path for the type package (e.g., "github.com/goravel/framework/contracts/console")
	typeImportPath string
	// fileExistsError is the error to return when the file exists but WithMethod is not registered
	fileExistsError error
	// stubTemplate is the function that returns the stub content for creating the file
	stubTemplate func() string
	// matcherFunc is the function that returns the matcher to find the target location (e.g., matchPkg.Commands, matchPkg.Migrations)
	matcherFunc func() []match.GoNode
}

// withSliceHandler handles adding items to a slice in foundation.Setup() chain.
type withSliceHandler struct {
	config      withSliceConfig
	appFilePath string
	filePath    string
	fileExists  bool
}

// newWithSliceHandler creates a new withSliceHandler with the given configuration.
func newWithSliceHandler(config withSliceConfig) *withSliceHandler {
	appFilePath := internals.BootstrapApp()
	bootstrapDir := filepath.Dir(appFilePath)
	filePath := filepath.Join(bootstrapDir, config.fileName)

	return &withSliceHandler{
		config:      config,
		appFilePath: appFilePath,
		filePath:    filePath,
		fileExists:  supportfile.Exists(filePath),
	}
}

// AddItem adds an item to the slice in foundation.Setup() chain.
func (r *withSliceHandler) AddItem(pkg, item string) error {
	withMethodExists, err := r.checkWithMethodExists()
	if err != nil {
		return err
	}

	if !withMethodExists {
		if r.fileExists {
			return r.config.fileExistsError
		}

		if err := r.createFile(); err != nil {
			return err
		}

		if err := r.addItemToFile(pkg, item); err != nil {
			return err
		}

		return GoFile(r.appFilePath).Find(packagesmatch.FoundationSetup()).Modify(r.setupWithFunction()).Apply()
	}

	if r.fileExists {
		if err := r.addItemToFile(pkg, item); err != nil {
			return err
		}
		return nil
	}

	if err := r.addImports(pkg); err != nil {
		return err
	}

	return GoFile(r.appFilePath).Find(packagesmatch.FoundationSetup()).Modify(r.setupInline(item)).Apply()
}

// checkWithMethodExists checks if the WithMethod exists in the foundation.Setup() chain.
//
// Example: For a config with withMethodName="WithCommands", it searches for:
//
//	foundation.Setup().WithCommands(Commands()).Boot()
//
// Returns true if ".WithCommands" is found in the app file content.
func (r *withSliceHandler) checkWithMethodExists() (bool, error) {
	content, err := supportfile.GetContent(r.appFilePath)
	if err != nil {
		return false, err
	}

	return strings.Contains(content, r.config.withMethodName), nil
}

// createFile creates the file with the helper function.
//
// Example: Creates a new file like "bootstrap/commands.go" with content:
//
//	func Commands() []console.Command {
//	    return []console.Command{}
//	}
//
// The actual content is generated by config.stubTemplate().
func (r *withSliceHandler) createFile() error {
	return supportfile.PutContent(r.filePath, r.config.stubTemplate())
}

// addImports adds the required imports for the item package and type package.
//
// Example: For pkg="github.com/user/app/commands" and typeImportPath="github.com/goravel/framework/contracts/console":
//
//	import (
//	    "github.com/user/app/commands"
//	    "github.com/goravel/framework/contracts/console"
//	)
func (r *withSliceHandler) addImports(pkg string) error {
	importMatchers := packagesmatch.Imports()
	if err := GoFile(r.appFilePath).FindOrCreate(importMatchers, CreateImport).Modify(AddImport(pkg)).Apply(); err != nil {
		return err
	}

	return GoFile(r.appFilePath).Find(importMatchers).Modify(AddImport(r.config.typeImportPath)).Apply()
}

// addItemToFile adds an item to the existing helper function in the file.
//
// Example: For pkg="github.com/user/app/commands" and item="&commands.MyCommand{}":
//
// Before:
//
//	func Commands() []console.Command {
//	    return []console.Command{}
//	}
//
// After:
//
//	import "github.com/user/app/commands"
//
//	func Commands() []console.Command {
//	    return []console.Command{
//	        &commands.MyCommand{},
//	    }
//	}
func (r *withSliceHandler) addItemToFile(pkg, item string) error {
	// Add the item package import
	importMatchers := packagesmatch.Imports()
	if err := GoFile(r.filePath).FindOrCreate(importMatchers, CreateImport).Modify(AddImport(pkg)).Apply(); err != nil {
		return err
	}

	// Add the item to the helper function using the provided matcher function
	return GoFile(r.filePath).Find(r.config.matcherFunc()).Modify(Register(item)).Apply()
}

// appendToExisting appends an item to an existing WithMethod call.
//
// Example: For withCall representing ".WithCommands([]console.Command{&commands.Cmd1{}})" and itemExpr="&commands.Cmd2{}":
//
// Before:
//
//	.WithCommands([]console.Command{
//	    &commands.Cmd1{},
//	})
//
// After:
//
//	.WithCommands([]console.Command{
//	    &commands.Cmd1{},
//	    &commands.Cmd2{},
//	})
func (r *withSliceHandler) appendToExisting(withCall *dst.CallExpr, itemExpr dst.Expr) {
	if len(withCall.Args) == 0 {
		return
	}

	compositeLit, ok := withCall.Args[0].(*dst.CompositeLit)
	if !ok {
		return
	}

	compositeLit.Elts = append(compositeLit.Elts, itemExpr)
}

// createWithMethod creates a new WithMethod call and inserts it into the chain.
//
// Example: For setupCall="foundation.Setup()", withMethodName="WithCommands", and itemExpr="&commands.MyCommand{}":
//
// Before:
//
//	foundation.Setup().Boot()
//
// After:
//
//	foundation.Setup().
//	    WithCommands([]console.Command{
//	        &commands.MyCommand{},
//	    }).
//	    Boot()
func (r *withSliceHandler) createWithMethod(setupCall *dst.CallExpr, parentOfSetup *dst.SelectorExpr, itemExpr dst.Expr) {
	compositeLit := &dst.CompositeLit{
		Type: &dst.ArrayType{
			Elt: &dst.SelectorExpr{
				X:   &dst.Ident{Name: r.config.typePackage},
				Sel: &dst.Ident{Name: r.config.typeName},
			},
		},
		Elts: []dst.Expr{itemExpr},
	}

	newWithCall := &dst.CallExpr{
		Fun: &dst.SelectorExpr{
			X: setupCall,
			Sel: &dst.Ident{
				Name: r.config.withMethodName,
				Decs: dst.IdentDecorations{
					NodeDecs: dst.NodeDecs{
						Before: dst.NewLine,
					},
				},
			},
		},
		Args: []dst.Expr{compositeLit},
	}

	parentOfSetup.X = newWithCall
}

// findFoundationSetupCalls walks the chain to find Setup() and WithMethod() calls.
//
// Example: For a chain like:
//
//	foundation.Setup().WithCommands(Commands()).WithMigrations(Migrations()).Boot()
//
// If withMethodName="WithCommands", returns:
//   - setupCall: the CallExpr for "foundation.Setup()"
//   - withCall: the CallExpr for "WithCommands(Commands())" (if it exists)
//   - parentOfSetup: the SelectorExpr representing the next method after Setup (e.g., ".WithCommands")
func (r *withSliceHandler) findFoundationSetupCalls(callExpr *dst.CallExpr) (setupCall, withCall *dst.CallExpr, parentOfSetup *dst.SelectorExpr) {
	current := callExpr
	for current != nil {
		if sel, ok := current.Fun.(*dst.SelectorExpr); ok {
			if innerCall, ok := sel.X.(*dst.CallExpr); ok {
				if innerSel, ok := innerCall.Fun.(*dst.SelectorExpr); ok {
					// Check if this is the Setup() call
					if innerSel.Sel.Name == "Setup" {
						if ident, ok := innerSel.X.(*dst.Ident); ok && ident.Name == "foundation" {
							setupCall = innerCall
							parentOfSetup = sel
							break
						}
					}
					// Check if this is the WithMethod
					if innerSel.Sel.Name == r.config.withMethodName {
						withCall = innerCall
					}
				}
				current = innerCall
				continue
			}
		}
		break
	}
	return
}

// setupInline returns an action that modifies the foundation.Setup() chain (inline array).
//
// This is used when WithMethod already exists in app.go but the helper file doesn't exist.
// It adds items directly into the inline array instead of using a helper function.
//
// Example: For item="&commands.MyCommand{}" with existing WithCommands:
//
// Before:
//
//	foundation.Setup().
//	    WithCommands([]console.Command{
//	        &commands.ExistingCmd{},
//	    }).
//	    Boot()
//
// After:
//
//	foundation.Setup().
//	    WithCommands([]console.Command{
//	        &commands.ExistingCmd{},
//	        &commands.MyCommand{},
//	    }).
//	    Boot()
//
// Or if WithCommands doesn't exist:
//
// Before:
//
//	foundation.Setup().Boot()
//
// After:
//
//	foundation.Setup().
//	    WithCommands([]console.Command{
//	        &commands.MyCommand{},
//	    }).
//	    Boot()
func (r *withSliceHandler) setupInline(item string) modify.Action {
	return func(cursor *dstutil.Cursor) {
		stmt := cursor.Node().(*dst.ExprStmt)

		if !containsFoundationSetup(stmt) {
			return
		}

		callExpr, ok := stmt.X.(*dst.CallExpr)
		if !ok {
			return
		}

		setupCall, withCall, parentOfSetup := r.findFoundationSetupCalls(callExpr)
		if setupCall == nil || parentOfSetup == nil {
			return
		}

		itemExpr := MustParseExpr(item).(dst.Expr)

		if withCall != nil {
			r.appendToExisting(withCall, itemExpr)
		} else {
			r.createWithMethod(setupCall, parentOfSetup, itemExpr)
		}
	}
}

// setupWithFunction returns an action that adds WithMethod(HelperFunc()) to the foundation.Setup() chain.
//
// This is used when the helper file is created and we need to wire it into app.go using a helper function call.
//
// Example: For withMethodName="WithCommands" and helperFuncName="Commands":
//
// Before:
//
//	foundation.Setup().Boot()
//
// After:
//
//	foundation.Setup().
//	    WithCommands(Commands()).
//	    Boot()
//
// Where Commands() is a helper function defined in bootstrap/commands.go that returns []console.Command.
func (r *withSliceHandler) setupWithFunction() modify.Action {
	return func(cursor *dstutil.Cursor) {
		stmt := cursor.Node().(*dst.ExprStmt)

		if !containsFoundationSetup(stmt) {
			return
		}

		callExpr, ok := stmt.X.(*dst.CallExpr)
		if !ok {
			return
		}

		setupCall, _, parentOfSetup := r.findFoundationSetupCalls(callExpr)
		if setupCall == nil || parentOfSetup == nil {
			return
		}

		// Create WithMethod(HelperFunc()) call
		newWithCall := &dst.CallExpr{
			Fun: &dst.SelectorExpr{
				X: setupCall,
				Sel: &dst.Ident{
					Name: r.config.withMethodName,
					Decs: dst.IdentDecorations{
						NodeDecs: dst.NodeDecs{
							Before: dst.NewLine,
						},
					},
				},
			},
			Args: []dst.Expr{
				&dst.CallExpr{
					Fun: &dst.Ident{Name: r.config.helperFuncName},
				},
			},
		}

		// Insert WithMethod into the chain
		parentOfSetup.X = newWithCall
	}
}
